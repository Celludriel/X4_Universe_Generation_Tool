<?xml version="1.0" encoding="utf-8" ?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">

  <!-- ===== Text simple types ==== -->

  <xs:simpleType name="boolean">
    <xs:restriction base="xs:boolean"/>
  </xs:simpleType>

  <xs:simpleType name="booleanexpression">
    <xs:union memberTypes="boolean expression"/>
  </xs:simpleType>

  <!-- Non-expression name, don't allow single quote. Technically it would be allowed, but this helps detecting mistakes. -->
  <xs:simpleType name="namestring">
    <xs:restriction base="xs:string">
      <xs:pattern value="[^']*" />
    </xs:restriction>
  </xs:simpleType>

  <!-- Script name (MD script, cue...) starts with upper case letter so it can't be a keyword, AI script is slightly different -->
  <xs:simpleType name="scriptname">
    <xs:restriction base="xs:string">
      <xs:pattern value="[A-Z][A-Za-z0-9_]+" />
    </xs:restriction>
  </xs:simpleType>

  <!-- Variables start with $ character. (Visual Studio requires \$, but \$ is not allowed by libxml2... so we use [$]) -->
  <xs:simpleType name="variablename">
    <xs:restriction base="xs:string">
      <xs:pattern value="[$][a-zA-Z0-9_]+" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="idname">
    <xs:restriction base="xs:string">
      <xs:pattern value="[a-zA-Z_][a-zA-Z0-9_]*" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="paramname">
    <xs:restriction base="xs:string">
      <xs:pattern value="[a-zA-Z_][a-zA-Z0-9_]*" />
    </xs:restriction>
  </xs:simpleType>

  <!-- TextDB reference: {pageid, textid} -->
  <xs:simpleType name="textdbref">
    <xs:restriction base="xs:string">
      <xs:pattern value=" *\{[1-9][0-9]*, *[1-9][0-9]*\} *" />
    </xs:restriction>
  </xs:simpleType>

  <!-- Expressions - also checks string 'delimiters', strings may contain anything, even \' -->
  <xs:simpleType name="expression">
    <xs:restriction base="xs:string">
      <!--                *([ initial character ]|('  any string   '))([ a non-string character                   ]|('  any string   '))* -->
      <xs:pattern value=" *([A-Za-z0-9_$@+\-({\[]|(#?'([^'\\]|\\.)*'))([A-Za-z0-9_$!?@=&lt;&gt;,.+\-*/%\^(){}\[\] ]|(#?'([^'\\]|\\.)*'))*" />
    </xs:restriction>
  </xs:simpleType>

  <!-- Lvalue expression, with various supported styles:
    $variable:            lvalue is a variable of name '$variable' in the current context/namespace (see simpleType "variablename")
    <expression>.{value}: lvalue is a property value of the base expression, e.g. a list index or a table key
    <expression>.$var:    lvalue is a string property '$var' of the base expression, e.g. a variable of an MD cue or an entity, or a string key in a table
    stat.foo:             lvalue is a statistics value, typically used in <set_value> to update the stat (exceptionally not using $variable style)
    userdata.foo:         lvalue is a user data value in userdata.xml, typically used in <set_value> to update the value or set a new one (exceptionally not using $variable style)
  -->
  <xs:simpleType name="lvalueexpression">
    <xs:restriction base="xs:string">
      <!--       either:    $ <varname....>   -->
      <xs:pattern value=" *[$][a-zA-Z0-9_]+ *" />
      <!--           or:   <property base expression....................................................> .     {<property expression..............................................> }                        -->
      <!--           or:   <property base expression....................................................> .                                                                               $ <varname....>     -->
      <xs:pattern value=" *[A-Za-z_$(]([A-Za-z0-9_$!?@=&lt;&gt;,.+\-*/%\^(){}\[\] ]|(#?'([^'\\]|\\.)*'))*\. *((\{([A-Za-z0-9_$!?@=&lt;&gt;,.+\-*/%\^(){}\[\] ]|(#?'([^'\\]|\\.)*'))+\})|([$][a-zA-Z0-9_]+)) *" />
      <!--           or:   stat              .  <statname............>   -->
      <!--           or:   userdata          .  <valuename...........>   -->
      <xs:pattern value=" *(stat|userdata) *\. *[a-zA-Z_][a-zA-Z0-9_]* *" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="lvaluename">
    <xs:annotation>
      <xs:documentation>
        Name of the value that will receive the result
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="lvalueexpression" />
  </xs:simpleType>

  <xs:simpleType name="groupname">
    <xs:annotation>
      <xs:documentation>
        Name of the group to which the result will be added (group will be created if it does not exist yet)
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="lvalueexpression" />
  </xs:simpleType>

  <xs:simpleType name="group">
    <xs:annotation>
      <xs:documentation>
        Group of objects
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="object">
    <xs:annotation>
      <xs:documentation>
        Object
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="objectlist">
    <xs:annotation>
      <xs:documentation>
        Object or a list of objects
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="destructible">
    <xs:annotation>
      <xs:documentation>
        Destructible
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="entity">
    <xs:annotation>
      <xs:documentation>
        Entity
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="factionorobject">
    <xs:annotation>
      <xs:documentation>
        Faction or Object
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="ship">
    <xs:annotation>
      <xs:documentation>
        Ship
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="station">
    <xs:annotation>
      <xs:documentation>
        Station
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="space">
    <xs:annotation>
      <xs:documentation>
        Containing space (zone, sector, cluster, or galaxy)
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="spacelist">
    <xs:annotation>
      <xs:documentation>
        Containing space (zone, sector, cluster, or galaxy) or a list of containing spaces
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="cluster">
    <xs:annotation>
      <xs:documentation>
        Cluster
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="room">
    <xs:annotation>
      <xs:documentation>
        Room
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="sector">
    <xs:annotation>
      <xs:documentation>
        Sector
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="zone">
    <xs:annotation>
      <xs:documentation>
        Zone
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="holomap">
    <xs:annotation>
      <xs:documentation>
        HoloMap
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="actor">
    <xs:annotation>
      <xs:documentation>
        Actor object (NPC)
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="genericactor">
    <xs:annotation>
      <xs:documentation>
        Actor entity (NPC) or list containing context and NPC template
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="targetobject">
    <xs:annotation>
      <xs:documentation>
        Target object
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="targetcomponent">
    <xs:annotation>
      <xs:documentation>
        Target component
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="targetcomponentslot">
    <xs:annotation>
      <xs:documentation>
        Target component slot
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="asteroid">
    <xs:annotation>
      <xs:documentation>
        Asteroid
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="weapon">
    <xs:annotation>
      <xs:documentation>
        Weapon
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="source">
    <xs:annotation>
      <xs:documentation>
        Source object
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="killer">
    <xs:annotation>
      <xs:documentation>
        Killer object
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="killedobject">
    <xs:annotation>
      <xs:documentation>
        Killed object
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="attacker">
    <xs:annotation>
      <xs:documentation>
        Attacker object
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="attackedobject">
    <xs:annotation>
      <xs:documentation>
        Attacked object
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="attackedcomponent">
    <xs:annotation>
      <xs:documentation>
        Attacked component object
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="damagedcomponent">
    <xs:annotation>
      <xs:documentation>
        Damaged component
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="repairedcomponent">
    <xs:annotation>
      <xs:documentation>
        Repaired component
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="buildmodule">
    <xs:annotation>
      <xs:documentation>
        Build module
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="buildprocessor">
    <xs:annotation>
      <xs:documentation>
        Build processor
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="productionmodule">
    <xs:annotation>
      <xs:documentation>
        Production module
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="buyer">
    <xs:annotation>
      <xs:documentation>
        Buyer object
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="seller">
    <xs:annotation>
      <xs:documentation>
        Seller object
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="buyerrequired">
    <xs:annotation>
      <xs:documentation>
        Buyer object (attribute must be present if seller not supplied)
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="sellerrequired">
    <xs:annotation>
      <xs:documentation>
        Seller object (attribute must be present if buyer not supplied)
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="tradeoffer">
    <xs:annotation>
      <xs:documentation>
        Trade Offer
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="eventtradeoffer">
    <xs:annotation>
      <xs:documentation>
        Trade offer to match. All other attributes and amount check nodes are ignored.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="build">
    <xs:annotation>
      <xs:documentation>
        Build Task
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="ware">
    <xs:annotation>
      <xs:documentation>
        Ware
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="dropware">
    <xs:annotation>
      <xs:documentation>
        Ware (paired with min-max/exact attributes) or ware amount table where the key is the ware and value is the amount
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="signalleak">
    <xs:annotation>
      <xs:documentation>
        SignalLeak object
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="scannerrequired">
    <xs:annotation>
      <xs:documentation>
        Object which performs the scanning, or group of objects (attribute must be present if scanned not supplied)
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="scannedrequired">
    <xs:annotation>
      <xs:documentation>
        Object which is scanned, or group of objects (attribute must be present if scanner not supplied)
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="hackerrequired">
    <xs:annotation>
      <xs:documentation>
        Object which performs the hacking, or group of objects (attribute must be present if hacked not supplied)
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="hackedrequired">
    <xs:annotation>
      <xs:documentation>
        Object which is hacked, or group of objects (attribute must be present if hacker not supplied)
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="lockattackerrequired">
    <xs:annotation>
      <xs:documentation>
        Attacker object (ship or station) which is doing the locking (attribute must be present if target not supplied)
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="locktargetrequired">
    <xs:annotation>
      <xs:documentation>
        The attacker's lock target object (attribute must be present if attacker not supplied)
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="locktargetcomponent">
    <xs:annotation>
      <xs:documentation>
        The attacker's lock target component (either the whole target object or a contained component)
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="observerrequired">
    <xs:annotation>
      <xs:documentation>
        Object which performs the observation, or group of objects (attribute must be present if observed not supplied)
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="observedrequired">
    <xs:annotation>
      <xs:documentation>
        Object which is observed, or group of objects (attribute must be present if observer not supplied)
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="attackerrequired">
    <xs:annotation>
      <xs:documentation>
        Object which is attacking the target (attribute must be present if target not supplied)
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="attackedrequired">
    <xs:annotation>
      <xs:documentation>
        Object which is attacked, or group of objects (attribute must be present if attacker not supplied)
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="claimedrequired">
    <xs:annotation>
      <xs:documentation>
        Object which is claimed, or group of objects (attribute must be present if pilot not supplied)
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="claimerrequired">
    <xs:annotation>
      <xs:documentation>
        The claiming entity, or group of entities (attribute must be present if claimed not supplied)
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="numfreeactorslots">
    <xs:annotation>
      <xs:documentation>
        Minimal required number of free slots for actor NPCs
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="freemissionactorslot">
    <xs:annotation>
      <xs:documentation>
        Is a free slot for a mission actor NPC required?
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="booleanexpression" />
  </xs:simpleType>

  <xs:simpleType name="cutscenekey">
    <xs:annotation>
      <xs:documentation>
        Cutscene key name
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="list">
    <xs:annotation>
      <xs:documentation>
        List
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="table">
    <xs:annotation>
      <xs:documentation>
        Table
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="order">
    <xs:annotation>
      <xs:documentation>
        AI order
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="immediateorder">
    <xs:annotation>
      <xs:documentation>
        Start this order immediately? If true, the order is inserted as the current order. If there is an active current order, it will be interrupted, so that it restarts
        when the new order is completed. If the current order cannot be interrupted (i.e. it's in the critical state) the new order is inserted right after it.
        This attribute has no effect when creating a default order.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="booleanexpression" />
  </xs:simpleType>

  <xs:simpleType name="findappend">
    <xs:annotation>
      <xs:documentation>
        If true then the found objects are appended to the value used as the result. Should the value used as the result not be a list, it will become one, losing its previous value (default false)
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="boolean" />
  </xs:simpleType>

  <xs:simpleType name="findclusterappend">
    <xs:restriction base="boolean" />
  </xs:simpleType>

  <xs:simpleType name="findsectorappend">
    <xs:restriction base="boolean" />
  </xs:simpleType>

  <xs:simpleType name="findmultiple">
    <xs:annotation>
      <xs:documentation>
        If true then the result is a list of all found objects, otherwise the result is a single object or null (default is true for count_ conditions, false for find_ actions).
        In case of multiple=false, the single result is the first object according to the sort criteria, or randomly selected from all matching objects if no sort criteria are specified.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="boolean" />
  </xs:simpleType>

  <xs:simpleType name="findrequired">
    <xs:annotation>
      <xs:documentation>
        If true then an error message will be produced if no result is found (default is false)
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="boolean" />
  </xs:simpleType>

  <xs:simpleType name="findrecursive">
    <xs:annotation>
      <xs:documentation>
        If true then the search does not stop at contained objects, but these objects and their sub-components are searched recursively as well (default is false)
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="boolean" />
  </xs:simpleType>

  <xs:simpleType name="findincludeobjects">
    <xs:annotation>
      <xs:documentation>
        If true then the search will include contained objects (of class object, e.g. docked ships). Sub-components of these objects are not included, unless the recursive attribute is set.
        The recursive attribute takes precedence over includeobjects. Default is false.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="boolean" />
  </xs:simpleType>

  <xs:simpleType name="offset">
    <xs:annotation>
      <xs:documentation>
        Offset from reference object
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="comment">
    <xs:annotation>
      <xs:documentation>
        Comment for documentation purposes only
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string" />
  </xs:simpleType>

  <xs:simpleType name="container">
    <xs:annotation>
      <xs:documentation>
        Container (ship or station)
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="crate">
    <xs:annotation>
      <xs:documentation>
        Crate (on first-person platform)
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="macro">
    <xs:annotation>
      <xs:documentation>
        Macro
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="macroname">
    <xs:annotation>
      <xs:documentation>
        Macro name (either a plain macro string or a script expression that evaluates to a string or macro)
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="constructionplan">
    <xs:annotation>
      <xs:documentation>
        Construction plan
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="moduletypelimit">
    <xs:annotation>
      <xs:documentation>
        Module type limit. Integer or a script expression that evaluates to an integer
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="docked">
    <xs:annotation>
      <xs:documentation>
        Ship is docked or parked at another object, including internal storage and piers
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="booleanexpression" />
  </xs:simpleType>

  <xs:simpleType name="known">
    <xs:annotation>
      <xs:documentation>
        Known to player?
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="boolean" />
  </xs:simpleType>

  <xs:simpleType name="hasmasstraffic">
    <xs:annotation>
      <xs:documentation>
        Is the station connected to a mass traffic network?
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="boolean" />
  </xs:simpleType>

  <xs:simpleType name="page">
    <xs:annotation>
      <xs:documentation>
        Text page ID
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="pagewithdefault">
    <xs:annotation>
      <xs:documentation>
        Text page ID (defaults to the speaker's voice page if not supplied)
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="line">
    <xs:annotation>
      <xs:documentation>
        Line ID in a text page
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="speakdelay">
    <xs:annotation>
      <xs:documentation>
        Optional short delay before the speech. Note that the delay is technically treated like a part of the actual speech, except for the display of subtitles.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="lineorlist">
    <xs:annotation>
      <xs:documentation>
        Line ID or a list of line IDs on a text page (list may include time values within the line ID sequence, to insert delays/pauses between lines)
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="section">
    <xs:annotation>
      <xs:documentation>
        Conversation section name
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="namestring" />
  </xs:simpleType>

  <xs:simpleType name="conversation">
    <xs:annotation>
      <xs:documentation>
        Conversation name
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="namestring" />
  </xs:simpleType>

  <xs:simpleType name="negatecondition">
    <xs:annotation>
      <xs:documentation>
        Negate condition?
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="boolean" />
  </xs:simpleType>

  <xs:simpleType name="negatefilter">
    <xs:annotation>
      <xs:documentation>
        Negate filter outcome? The negation applies to the whole element, e.g. &lt;match_content negate=&quot;true&quot;&gt; matches objects which do NOT have the specified content.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="boolean" />
  </xs:simpleType>

  <xs:simpleType name="colour">
    <xs:annotation>
      <xs:documentation>
        Colour Value (0 - 255)
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="masstraffic">
    <xs:annotation>
      <xs:documentation>
        Mass traffic network ID
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="pricemodifieramount">
    <xs:annotation>
      <xs:documentation>
        Discount/commission amount as percentage of a ware's price variation range, valid range from 1 to 100.
        NOTE: This is not the actual discount/commission percentage, which depends on the ware that the price modifier is applied to. Discounts/Commissions apply to all sell/buy offers of object/faction respectively.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="countresult">
    <xs:annotation>
      <xs:documentation>
        Single result value if multiple="false", otherwise list of result values
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="lvalueexpression" />
  </xs:simpleType>

  <xs:simpleType name="groupeventsource">
    <xs:annotation>
      <xs:documentation>
        Group of event objects (can be supplied instead of a single event object). The check attribute does not apply. The group is required to exist but may be empty.
        Adding/removing group members is possible even after the event is set up.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <xs:simpleType name="checkeventsource">
    <xs:annotation>
      <xs:documentation>
        Produce an error message if the provided event object does not exist? Default is true.
        NOTE: If the event object is a variable or a changeable property, changing it at a later time has no direct effect on this event condition,
        i.e. it is not re-enabled automatically. It is only updated under certain conditions, e.g. when loading a savegame or when
        the event condition is restarted explicitly (resetting MD cue or starting AI script).
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="boolean" />
  </xs:simpleType>

  <xs:simpleType name="notificationtext">
    <xs:annotation>
      <xs:documentation>
        Notification text to be displayed, either a single string with possible line breaks (left-aligned), or a list of strings.
        In a list, each pair of strings defines a single row (left-aligned and right-aligned text).
        In the list you can use [ string, r, g, b ] instead of a simple string to specify an RGB text color, with color values between 0 and 255.
        The default color is determined by the notification priority (a priority above 1 will turn the color red).
        Numbers are also accepted instead of strings.
        The maximum number of rows is 4 in the message ticker (&lt;show_notification&gt;), and 7 in the target monitor (&lt;show_interactive_message&gt;)
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="expression" />
  </xs:simpleType>

  <!-- ===== Enumeration simple types ===== -->

  <xs:simpleType name="versionstatus">
    <xs:annotation>
      <xs:documentation>
        Version status
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="concept">
        <xs:annotation>
          <xs:documentation>
            Proof of concept only
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="development">
        <xs:annotation>
          <xs:documentation>
            Under development
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="testing">
        <xs:annotation>
          <xs:documentation>
            Test version
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="candidate">
        <xs:annotation>
          <xs:documentation>
            Release candidate
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="release">
        <xs:annotation>
          <xs:documentation>
            Released
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="waiting">
        <xs:annotation>
          <xs:documentation>
            Waiting for other assets
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="selectionlookup">
    <xs:annotation>
      <xs:documentation>
        Selection type (used with select sub-nodes)
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <!-- TODO: Improve documentation -->
      <xs:enumeration value="one">
        <xs:annotation>
          <xs:documentation>
            One
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="random">
        <xs:annotation>
          <xs:documentation>
            Random
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="random_except">
        <xs:annotation>
          <xs:documentation>
            Random, excluding an item that can be optionally specified by code
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="choose">
        <xs:annotation>
          <xs:documentation>
            Choose
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="selectionweight">
    <xs:annotation>
      <xs:documentation>
        Weight which determines the chance of this node being selected
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:integer">
      <xs:minInclusive value="0" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="setoperationlookup">
    <xs:annotation>
      <xs:documentation>
        Operation to perform (default is set)
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="set">
        <xs:annotation>
          <xs:documentation>
            Set value (default operation if not supplied, default action is to set to 1 if no random range supplied)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="add">
        <xs:annotation>
          <xs:documentation>
            Add to value (default is to add 1 if no random range supplied)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="subtract">
        <xs:annotation>
          <xs:documentation>
            Subtract from value (default is to subtract 1 if no random range supplied)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <!--
      <xs:enumeration value="multiply">
        <xs:annotation>
          <xs:documentation>
            Multiply value (default is to do nothing if no random range supplied)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="divide">
        <xs:annotation>
          <xs:documentation>
            Divide value (default is to do nothing if no random range supplied)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      -->
      <xs:enumeration value="insert">
        <xs:annotation>
          <xs:documentation>
            Insert value into the list as the specified list element, moving all following elements. Insertion at list count + 1 is allowed. (Default value is null if no random range supplied)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="killmethodlookup">
    <xs:annotation>
      <xs:documentation>
        Kill method
      </xs:documentation>
    </xs:annotation>
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <!-- TODO: Improve documentation -->
          <xs:enumeration value="killmethod.unknown">
            <xs:annotation>
              <xs:documentation>
                Unknown
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="killmethod.collected">
            <xs:annotation>
              <xs:documentation>
                Collected
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="killmethod.collided">
            <xs:annotation>
              <xs:documentation>
                Collided
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="killmethod.contextkilled">
            <xs:annotation>
              <xs:documentation>
                Context killed
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="killmethod.detached">
            <xs:annotation>
              <xs:documentation>
                Detached (used for bombs that are turned into floating collectables)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="killmethod.hitbyareadamage">
            <xs:annotation>
              <xs:documentation>
                Hit by area damage
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="killmethod.hitbybomb">
            <xs:annotation>
              <xs:documentation>
                Hit by bomb
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="killmethod.hitbybullet">
            <xs:annotation>
              <xs:documentation>
                Hit by bullet
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="killmethod.hitbymine">
            <xs:annotation>
              <xs:documentation>
                Hit by mine
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="killmethod.hitbymissile">
            <xs:annotation>
              <xs:documentation>
                Hit by missile
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="killmethod.lowattentionattack">
            <xs:annotation>
              <xs:documentation>
                Attacked in low attention
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="killmethod.removed">
            <xs:annotation>
              <xs:documentation>
                Removed
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="killmethod.selfdestructed">
            <xs:annotation>
              <xs:documentation>
                Self-destructed
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="killmethod.suffocated">
            <xs:annotation>
              <xs:documentation>
                Suffocated
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="killmethod.targetpointdiscarded">
            <xs:annotation>
              <xs:documentation>
                Target point discarded
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="killmethod.timedout">
            <xs:annotation>
              <xs:documentation>
                Timed out
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="killmethod.weaponswap">
            <xs:annotation>
              <xs:documentation>
                Weapon swap
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="racelookup">
    <xs:restriction base="xs:string">
      <xs:enumeration value="argon">
        <xs:annotation>
          <xs:documentation>
            Argon
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="boron">
        <xs:annotation>
          <xs:documentation>
            Boron
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="split">
        <xs:annotation>
          <xs:documentation>
            Split
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="drone">
        <xs:annotation>
          <xs:documentation>
            Drone
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="khaak">
        <xs:annotation>
          <xs:documentation>
            Kha'ak
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="paranid">
        <xs:annotation>
          <xs:documentation>
            Paranid
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="teladi">
        <xs:annotation>
          <xs:documentation>
            Teladi
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="terran">
        <xs:annotation>
          <xs:documentation>
            Terran
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="xenon">
        <xs:annotation>
          <xs:documentation>
            Xenon
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="rawraceexprlookup">
    <xs:union memberTypes="expression racelookup" />
  </xs:simpleType>

  <xs:simpleType name="raceexprlookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="race.argon">
            <xs:annotation>
              <xs:documentation>
                Argon
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="race.boron">
            <xs:annotation>
              <xs:documentation>
                Boron
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="race.drone">
            <xs:annotation>
              <xs:documentation>
                Drone
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="race.khaak">
            <xs:annotation>
              <xs:documentation>
                Kha'ak
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="race.split">
            <xs:annotation>
              <xs:documentation>
                Split
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="race.paranid">
            <xs:annotation>
              <xs:documentation>
                Paranid
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="race.teladi">
            <xs:annotation>
              <xs:documentation>
                Teladi
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="race.terran">
            <xs:annotation>
              <xs:documentation>
                Terran
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="race.xenon">
            <xs:annotation>
              <xs:documentation>
                Xenon
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="race">
    <xs:annotation>
      <xs:documentation>
        Race (species)
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="raceexprlookup" />
  </xs:simpleType>

  <xs:simpleType name="factionlookup">
    <xs:restriction base="xs:string">
      <xs:enumeration value="alliance">
        <xs:annotation>
          <xs:documentation>
            Alliance of the Word
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="antigone">
        <xs:annotation>
          <xs:documentation>
            Antigone Republic
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="argon">
        <xs:annotation>
          <xs:documentation>
            Argon Federation
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="buccaneers">
        <xs:annotation>
          <xs:documentation>
            Duke's Buccaneers
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="court">
        <xs:annotation>
          <xs:documentation>
            Court of Curbs (only valid if Split Vendetta extension is active)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="civilian">
        <xs:annotation>
          <xs:documentation>
            Civilian
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="criminal">
        <xs:annotation>
          <xs:documentation>
            Criminal
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="freesplit">
        <xs:annotation>
          <xs:documentation>
            Free Families (only valid if Split Vendetta extension is active)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="hatikvah">
        <xs:annotation>
          <xs:documentation>
            Hatikvah Free League
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="holyorder">
        <xs:annotation>
          <xs:documentation>
            Holy Order of the Pontifex
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="khaak">
        <xs:annotation>
          <xs:documentation>
            Kha'ak
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ministry">
        <xs:annotation>
          <xs:documentation>
            Ministry of Finance
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ownerless">
        <xs:annotation>
          <xs:documentation>
            Ownerless
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="paranid">
        <xs:annotation>
          <xs:documentation>
            Paranid
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="pioneers">
        <xs:annotation>
          <xs:documentation>
            Pioneers (only valid if Terran extension is active)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="player">
        <xs:annotation>
          <xs:documentation>
            Player
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="scaleplate">
        <xs:annotation>
          <xs:documentation>
            Scale Plate Pact
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="smuggler">
        <xs:annotation>
          <xs:documentation>
            Smuggler
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="split">
        <xs:annotation>
          <xs:documentation>
            Zyarth Patriarchy (only valid if Split Vendetta extension is active)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="teladi">
        <xs:annotation>
          <xs:documentation>
            Teladi Company
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="terran">
        <xs:annotation>
          <xs:documentation>
            Terran main faction (only valid if Terran extension is active)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="trinity">
        <xs:annotation>
          <xs:documentation>
            Realm of the Trinity
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="yaki">
        <xs:annotation>
          <xs:documentation>
            Yaki (only valid if Terran extension is active)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="xenon">
        <xs:annotation>
          <xs:documentation>
            Xenon
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="rawfactionexprlookup">
    <xs:union memberTypes="expression factionlookup" />
  </xs:simpleType>

  <xs:simpleType name="factionexprlookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="faction.alliance">
            <xs:annotation>
              <xs:documentation>
                Alliance of the Word
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="faction.antigone">
            <xs:annotation>
              <xs:documentation>
                Antigone Republic
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="faction.argon">
            <xs:annotation>
              <xs:documentation>
                Argon Federation
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="faction.buccaneers">
            <xs:annotation>
              <xs:documentation>
                Duke's Buccaneers
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="faction.court">
            <xs:annotation>
              <xs:documentation>
                Court of Curbs (only valid if Split Vendetta extension is active)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="faction.civilian">
            <xs:annotation>
              <xs:documentation>
                Civilian
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="faction.criminal">
            <xs:annotation>
              <xs:documentation>
                Criminal
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="faction.freesplit">
            <xs:annotation>
              <xs:documentation>
                Free Families (only valid if Split Vendetta extension is active)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="faction.hatikvah">
            <xs:annotation>
              <xs:documentation>
                Hatikvah Free League
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="faction.holyorder">
            <xs:annotation>
              <xs:documentation>
                Holy Order of the Pontifex
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="faction.khaak">
            <xs:annotation>
              <xs:documentation>
                Kha'ak
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="faction.ministry">
            <xs:annotation>
              <xs:documentation>
                Ministry of Finance
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="faction.ownerless">
            <xs:annotation>
              <xs:documentation>
                Ownerless
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="faction.paranid">
            <xs:annotation>
              <xs:documentation>
                Paranid
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="faction.pioneers">
            <xs:annotation>
              <xs:documentation>
                Pioneers (only valid if Terran extension is active)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="faction.player">
            <xs:annotation>
              <xs:documentation>
                Player
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="faction.scaleplate">
            <xs:annotation>
              <xs:documentation>
                Scale Plate Pact
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="faction.smuggler">
            <xs:annotation>
              <xs:documentation>
                Smuggler
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="faction.split">
            <xs:annotation>
              <xs:documentation>
                Zyarth Patriarchy (only valid if Split Vendetta extension is active)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="faction.teladi">
            <xs:annotation>
              <xs:documentation>
                Teladi Company
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="faction.terran">
            <xs:annotation>
              <xs:documentation>
                Terran main faction (only valid if Terran extension is active)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="faction.trinity">
            <xs:annotation>
              <xs:documentation>
                Realm of the Trinity
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="faction.yaki">
            <xs:annotation>
              <xs:documentation>
                Yaki (only valid if Terran extension is active)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="faction.xenon">
            <xs:annotation>
              <xs:documentation>
                Xenon
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="faction">
    <xs:annotation>
      <xs:documentation>
        Faction
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="factionexprlookup" />
  </xs:simpleType>

  <xs:simpleType name="modulesettypelookup">
    <xs:restriction base="xs:string">
      <xs:enumeration value="defence" />
      <xs:enumeration value="equipmentdock" />
      <xs:enumeration value="factory" />
      <xs:enumeration value="tradingstation" />
      <xs:enumeration value="shipyard" />
      <xs:enumeration value="headquarters" />
      <xs:enumeration value="piratebase" />
      <xs:enumeration value="yakistation" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="owner">
    <xs:annotation>
      <xs:documentation>
        Owner faction
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="factionexprlookup" />
  </xs:simpleType>

  <xs:simpleType name="owners">
    <xs:annotation>
      <xs:documentation>
        Owner faction, or list of owner factions
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="factionexprlookup" />
  </xs:simpleType>

  <xs:simpleType name="quadrantlookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="quadrant.none" />
          <xs:enumeration value="quadrant.front" />
          <xs:enumeration value="quadrant.back" />
          <xs:enumeration value="quadrant.left" />
          <xs:enumeration value="quadrant.right" />
          <xs:enumeration value="quadrant.up" />
          <xs:enumeration value="quadrant.down" />
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="quadrant">
    <xs:annotation>
      <xs:documentation>
        Directional Quadrant
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="quadrantlookup" />
  </xs:simpleType>

  <xs:simpleType name="ammotypelookup">
    <xs:restriction base="xs:string">
      <xs:enumeration value="missile" />
      <xs:enumeration value="countermeasure" />
      <xs:enumeration value="deployable" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="roomtypelookup">
    <xs:restriction base="xs:string">
      <xs:enumeration value="bar" />
      <xs:enumeration value="corridor" />
      <xs:enumeration value="factionrep" />
      <xs:enumeration value="infrastructure" />
      <xs:enumeration value="manager" />
      <xs:enumeration value="office" />
      <xs:enumeration value="prison" />
      <xs:enumeration value="security" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="roomtypeexprlookup">
    <xs:annotation>
      <xs:documentation>
        Room type
      </xs:documentation>
    </xs:annotation>
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="roomtype.bar" />
          <xs:enumeration value="roomtype.corridor" />
          <xs:enumeration value="roomtype.factionrep" />
          <xs:enumeration value="roomtype.infrastructure" />
          <xs:enumeration value="roomtype.manager" />
          <xs:enumeration value="roomtype.office" />
          <xs:enumeration value="roomtype.prison" />
          <xs:enumeration value="roomtype.security" />
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="weaponsystemlookup">
    <xs:restriction base="xs:string">
      <xs:enumeration value="all" />
      <xs:enumeration value="drone_attack" />
      <xs:enumeration value="drone_defence" />
      <xs:enumeration value="drone_repair" />
      <xs:enumeration value="laser" />
      <xs:enumeration value="missile" />
      <xs:enumeration value="torpedo" />
      <xs:enumeration value="turret_shortrange" />
      <xs:enumeration value="turret_midrange" />
      <xs:enumeration value="turret_longrange" />
      <xs:enumeration value="turret_missile" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="weapontypelookup">
    <xs:restriction base="xs:string">
      <xs:enumeration value="all">
        <xs:annotation>
          <xs:documentation>
            All weapons (including mining or repair lasers!)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="combat">
        <xs:annotation>
          <xs:documentation>
            Combat weapons (default)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="mining">
        <xs:annotation>
          <xs:documentation>
            Mining weapons
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="repair">
        <xs:annotation>
          <xs:documentation>
            Repair weapons
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="weaponmodelookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="weaponmode.any">
            <xs:annotation>
              <xs:documentation>
                Any mode applies
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="weaponmode.attackenemies">
            <xs:annotation>
              <xs:documentation>
                Attack all enemies
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="weaponmode.attackcapital">
            <xs:annotation>
              <xs:documentation>
                Attack only capital ships (All ships of size class L or XL)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="weaponmode.attackfighters">
            <xs:annotation>
              <xs:documentation>
                Attack only non-capital ships (All ships of size class XS, S, or M)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="weaponmode.defend">
            <xs:annotation>
              <xs:documentation>
                Defend against attackers (default for non-mining weapons)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="weaponmode.mining">
            <xs:annotation>
              <xs:documentation>
                Mining asteroids (default for mining weapons)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="weaponmode.missiledefence">
            <xs:annotation>
              <xs:documentation>
                Attempt to shoot down missiles
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="extendedweaponmodelookup">
    <xs:union memberTypes="weaponmodelookup">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="weaponmode.autoassist">
            <xs:annotation>
              <xs:documentation>
                Automatically target the current target (player only)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="weaponmode.holdfire">
            <xs:annotation>
              <xs:documentation>
                Do not shoot
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="dockstatelookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="dockstate.default">
            <xs:annotation>
              <xs:documentation>
                Dock is either empty or the docked ship is stationary
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="dockstate.docking">
            <xs:annotation>
              <xs:documentation>
                A ship is in its final docking manoeuvre
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="dockstate.retrieving">
            <xs:annotation>
              <xs:documentation>
                A ship is currently being retrieved
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="dockstate.retrieving_to_undock">
            <xs:annotation>
              <xs:documentation>
                A ship is currently being retrieved, it will undock as soon as this is done
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="dockstate.storing">
            <xs:annotation>
              <xs:documentation>
                A ship is currently being stored
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="dockstate.undocking">
            <xs:annotation>
              <xs:documentation>
                A ship is currently undocking
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="shiptypelookup">
    <xs:restriction base="xs:string">
      <xs:enumeration value="personalvehicle" />
      <xs:enumeration value="police" />
      <xs:enumeration value="xsdrone" />
      <xs:enumeration value="escapepod" />
      <xs:enumeration value="distressdrone" />
      <xs:enumeration value="lasertower" />
      <xs:enumeration value="scout" />
      <xs:enumeration value="fighter" />
      <xs:enumeration value="heavyfighter" />
      <xs:enumeration value="interceptor" />
      <xs:enumeration value="courier" />
      <xs:enumeration value="smalldrone" />
      <xs:enumeration value="bomber" />
      <xs:enumeration value="frigate" />
      <xs:enumeration value="corvette" />
      <xs:enumeration value="gunboat" />
      <xs:enumeration value="transporter" />
      <xs:enumeration value="miner" />
      <xs:enumeration value="personnelcarrier" />
      <xs:enumeration value="scavenger" />
      <xs:enumeration value="destroyer" />
      <xs:enumeration value="freighter" />
      <xs:enumeration value="largeminer" />
      <xs:enumeration value="carrier" />
      <xs:enumeration value="resupplier" />
      <xs:enumeration value="builder" />
      <xs:enumeration value="battleship" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="shiptypeexprlookup">
    <xs:annotation>
      <xs:documentation>
        Ship type
      </xs:documentation>
    </xs:annotation>
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="shiptype.personalvehicle" />
          <xs:enumeration value="shiptype.police" />
          <xs:enumeration value="shiptype.xsdrone" />
          <xs:enumeration value="shiptype.escapepod" />
          <xs:enumeration value="shiptype.distressdrone" />
          <xs:enumeration value="shiptype.lasertower" />
          <xs:enumeration value="shiptype.scout" />
          <xs:enumeration value="shiptype.fighter" />
          <xs:enumeration value="shiptype.heavyfighter" />
          <xs:enumeration value="shiptype.interceptor" />
          <xs:enumeration value="shiptype.courier" />
          <xs:enumeration value="shiptype.smalldrone" />
          <xs:enumeration value="shiptype.bomber" />
          <xs:enumeration value="shiptype.frigate" />
          <xs:enumeration value="shiptype.corvette" />
          <xs:enumeration value="shiptype.gunboat" />
          <xs:enumeration value="shiptype.transporter" />
          <xs:enumeration value="shiptype.miner" />
          <xs:enumeration value="shiptype.personnelcarrier" />
          <xs:enumeration value="shiptype.scavenger" />
          <xs:enumeration value="shiptype.destroyer" />
          <xs:enumeration value="shiptype.freighter" />
          <xs:enumeration value="shiptype.largeminer" />
          <xs:enumeration value="shiptype.carrier" />
          <xs:enumeration value="shiptype.resupplier" />
          <xs:enumeration value="shiptype.builder" />
          <xs:enumeration value="shiptype.battleship" />
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="orientationlookup">
    <xs:restriction base="xs:string">
      <xs:enumeration value="align_left">
        <xs:annotation>
          <xs:documentation>
            Align so that refpos/refobj is on the left side
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="align_left_bbox">
        <xs:annotation>
          <xs:documentation>
            Align so that refobj-bounding-box is on the left side (requires valid refobject!)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="align_right">
        <xs:annotation>
          <xs:documentation>
            Align so that refpos/refobj is on the right side
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="align_right_bbox">
        <xs:annotation>
          <xs:documentation>
            Align so that refobj-bounding-box is on the right side (requires valid refobject!)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="look_at">
        <xs:annotation>
          <xs:documentation>
            Orientation that looks directly at refpos/refobj-center
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="look_at_bbox">
        <xs:annotation>
          <xs:documentation>
            Orientation that looks directly at refobj-bounding-box (requires valid refobject!)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="look_away">
        <xs:annotation>
          <xs:documentation>
            Orientation that looks away from refpos/refobj-center
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="look_away_bbox">
        <xs:annotation>
          <xs:documentation>
            Orientation that looks away from refobj-bounding-box (requires valid refobject!)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="activityexprlookup">
    <xs:annotation>
      <xs:documentation>
        Player activity
      </xs:documentation>
    </xs:annotation>
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="activity.none" >
            <xs:annotation>
              <xs:documentation>
                No activity
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="activity.scan_longrange" >
            <xs:annotation>
              <xs:documentation>
                Long-Range Scanning activity
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="activity.scan" >
            <xs:annotation>
              <xs:documentation>
                Object Scanning activity
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="activity.travel" >
            <xs:annotation>
              <xs:documentation>
                Travel drive
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="alertlevellookup">
    <xs:restriction base="xs:string">
      <xs:enumeration value="green" >
        <xs:annotation>
          <xs:documentation>
            No alert
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="red" >
        <xs:annotation>
          <xs:documentation>
            Red alert
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="yellow" >
        <xs:annotation>
          <xs:documentation>
            Yellow alert
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="classlookup">
    <xs:union memberTypes="positionalclasslookup expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="class.component">
            <xs:annotation>
              <xs:documentation>
                Component
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.buildprocessor">
            <xs:annotation>
              <xs:documentation>
                Build processor
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="positionalclasslookup">
    <xs:union memberTypes="destructibleclasslookup spaceclasslookup roomclasslookup expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="class.accessory">
            <xs:annotation>
              <xs:documentation>
                Accessory
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.bullet">
            <xs:annotation>
              <xs:documentation>
                Bullet
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.countermeasure">
            <xs:annotation>
              <xs:documentation>
                Countermeasure
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.crate">
            <xs:annotation>
              <xs:documentation>
                Crate
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.positional">
            <xs:annotation>
              <xs:documentation>
                Positional
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="destructibleclasslookup">
    <xs:union memberTypes="objectclasslookup entityclasslookup expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="class.adsign">
            <xs:annotation>
              <xs:documentation>
                Ad Sign (child of an object)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.buildmodule">
            <xs:annotation>
              <xs:documentation>
                Build Module
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.cargobay">
            <xs:annotation>
              <xs:documentation>
                Cargo Bay
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.construction">
            <xs:annotation>
              <xs:documentation>
                Construction
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.controlcomponent">
            <xs:annotation>
              <xs:documentation>
                Control Component
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.controlpanel">
            <xs:annotation>
              <xs:documentation>
                Control Panel
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.destructible">
            <xs:annotation>
              <xs:documentation>
                Destructible
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.dockarea">
            <xs:annotation>
              <xs:documentation>
                Dock Area
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.engine">
            <xs:annotation>
              <xs:documentation>
                Engine
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.habitation">
            <xs:annotation>
              <xs:documentation>
                Habitation Module
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.interior">
            <xs:annotation>
              <xs:documentation>
                Interior
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.launcher">
            <xs:annotation>
              <xs:documentation>
                Launcher
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.lock">
            <xs:annotation>
              <xs:documentation>
                Lock
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.module">
            <xs:annotation>
              <xs:documentation>
                Module
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.navcontext">
            <xs:annotation>
              <xs:documentation>
                Nav Context
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.pier">
            <xs:annotation>
              <xs:documentation>
                Pier
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.production">
            <xs:annotation>
              <xs:documentation>
                Production
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.radar">
            <xs:annotation>
              <xs:documentation>
                Radar
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.scanner">
            <xs:annotation>
              <xs:documentation>
                Scanner
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.shieldgenerator">
            <xs:annotation>
              <xs:documentation>
                Shield Generator
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.storage">
            <xs:annotation>
              <xs:documentation>
                Storage Module
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.turret">
            <xs:annotation>
              <xs:documentation>
                Turret
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.ventureplatform">
            <xs:annotation>
              <xs:documentation>
                Venture Platform Module
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.walkablemodule">
            <xs:annotation>
              <xs:documentation>
                Walkable Module (Docking Bay or Build Module)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.weapon">
            <xs:annotation>
              <xs:documentation>
                Weapon
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <!--TODO Finish-->
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="objectclasslookup">
    <xs:union memberTypes="shipclasslookup stationclasslookup expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="class.adsignobject">
            <xs:annotation>
              <xs:documentation>
                Ad Sign Object (child of a zone)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.asteroid">
            <xs:annotation>
              <xs:documentation>
                Asteroid
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.bomb">
            <xs:annotation>
              <xs:documentation>
                Bomb
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.collectable">
            <xs:annotation>
              <xs:documentation>
                Collectable
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.container">
            <xs:annotation>
              <xs:documentation>
                Container
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.controllable">
            <xs:annotation>
              <xs:documentation>
                Controllable
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.defensible">
            <xs:annotation>
              <xs:documentation>
                Defensible
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.drop">
            <xs:annotation>
              <xs:documentation>
                Drop
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.explosive">
            <xs:annotation>
              <xs:documentation>
                Explosive
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.gate">
            <xs:annotation>
              <xs:documentation>
                Gate
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.highwayentrygate">
            <xs:annotation>
              <xs:documentation>
                Highway Entry Gate
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.highwayexitgate">
            <xs:annotation>
              <xs:documentation>
                Highway Exit Gate
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.lockbox">
            <xs:annotation>
              <xs:documentation>
                Lockbox
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.mine">
            <xs:annotation>
              <xs:documentation>
                Mine
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.missile">
            <xs:annotation>
              <xs:documentation>
                Missile
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.navbeacon">
            <xs:annotation>
              <xs:documentation>
                Nav Beacon
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.nebula">
            <xs:annotation>
              <xs:documentation>
                Nebula
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.object">
            <xs:annotation>
              <xs:documentation>
                Object
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.resourceprobe">
            <xs:annotation>
              <xs:documentation>
                Resource Probe
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.satellite">
            <xs:annotation>
              <xs:documentation>
                Satellite
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="shipclasslookup">
    <xs:union memberTypes="shipsizeclasslookup">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="class.ship">
            <xs:annotation>
              <xs:documentation>
                Ship
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.spacesuit">
            <xs:annotation>
              <xs:documentation>
                Spacesuit
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="shipsizeclasslookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="class.ship_xs">
            <xs:annotation>
              <xs:documentation>
                XS sized ship
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.ship_s">
            <xs:annotation>
              <xs:documentation>
                S sized ship
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.ship_m">
            <xs:annotation>
              <xs:documentation>
                M sized ship
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.ship_l">
            <xs:annotation>
              <xs:documentation>
                L sized ship
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.ship_xl">
            <xs:annotation>
              <xs:documentation>
                XL sized ship
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="stationclasslookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="class.station">
            <xs:annotation>
              <xs:documentation>
                Station
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="spaceclasslookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="class.area">
            <xs:annotation>
              <xs:documentation>
                Area
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.cluster">
            <xs:annotation>
              <xs:documentation>
                Cluster
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.galaxy">
            <xs:annotation>
              <xs:documentation>
                Galaxy
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.highway">
            <xs:annotation>
              <xs:documentation>
                Highway
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.sector">
            <xs:annotation>
              <xs:documentation>
                Sector
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.zone">
            <xs:annotation>
              <xs:documentation>
                Zone
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="entityclasslookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="class.entity">
            <xs:annotation>
              <xs:documentation>
                Entity
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.player">
            <xs:annotation>
              <xs:documentation>
                Player
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.nonplayer">
            <xs:annotation>
              <xs:documentation>
                Non-player
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.computer">
            <xs:annotation>
              <xs:documentation>
                Computer
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.npc">
            <xs:annotation>
              <xs:documentation>
                NPC
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="roomclasslookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="class.room">
            <xs:annotation>
              <xs:documentation>
                Room
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.cockpit">
            <xs:annotation>
              <xs:documentation>
                Cockpit
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.controlroom">
            <xs:annotation>
              <xs:documentation>
                Control Room
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.dockingbay">
            <xs:annotation>
              <xs:documentation>
                Docking bay
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="class.transporterroom">
            <xs:annotation>
              <xs:documentation>
                Transporter room
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="attentionlookup">
    <xs:restriction base="xs:string">
      <xs:enumeration value="unknown" />
      <xs:enumeration value="ingalaxy" />
      <xs:enumeration value="incluster" />
      <xs:enumeration value="sectorvisible" />
      <xs:enumeration value="insector" />
      <xs:enumeration value="adjacentzone" />
      <xs:enumeration value="visible" />
      <xs:enumeration value="inzone" />
      <xs:enumeration value="nearby" />
      <xs:enumeration value="adjacentroom" />
      <xs:enumeration value="inroom" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="attentionexprlookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="attention.unknown" />
          <xs:enumeration value="attention.ingalaxy" />
          <xs:enumeration value="attention.incluster" />
          <xs:enumeration value="attention.sectorvisible" />
          <xs:enumeration value="attention.insector" />
          <xs:enumeration value="attention.adjacentzone" />
          <xs:enumeration value="attention.visible" />
          <xs:enumeration value="attention.inzone" />
          <xs:enumeration value="attention.nearby" />
          <xs:enumeration value="attention.adjacentroom" />
          <xs:enumeration value="attention.inroom" />
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="componentstatelookup">
    <xs:restriction base="xs:string">
      <xs:enumeration value="construction" />
      <xs:enumeration value="operational" />
      <xs:enumeration value="wreck" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="componentstateexprlookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="componentstate.construction" />
          <xs:enumeration value="componentstate.operational" />
          <xs:enumeration value="componentstate.wreck" />
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="dronemodeexprlookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="dronemode.attackenemies" />
          <xs:enumeration value="dronemode.autoassist" />
          <xs:enumeration value="dronemode.defend" />
          <xs:enumeration value="dronemode.escort" />
          <xs:enumeration value="dronemode.missiledefence" />
          <xs:enumeration value="dronemode.collectanymineable" />
          <xs:enumeration value="dronemode.collectice" />
          <xs:enumeration value="dronemode.collectnividium" />
          <xs:enumeration value="dronemode.collectore" />
          <xs:enumeration value="dronemode.collectsilicon" />
          <xs:enumeration value="dronemode.collecthelium" />
          <xs:enumeration value="dronemode.collecthydrogen" />
          <xs:enumeration value="dronemode.collectmethane" />
          <xs:enumeration value="dronemode.collectanycrate" />
          <xs:enumeration value="dronemode.collectillegal" />
          <xs:enumeration value="dronemode.collectlegal" />
          <xs:enumeration value="dronemode.collectselected" />
          <xs:enumeration value="dronemode.trade" />
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="entitytypelookup">
    <xs:restriction base="xs:string">
      <xs:enumeration value="officer" />
      <xs:enumeration value="trader" />
      <xs:enumeration value="factionrepresentative" />
      <xs:enumeration value="shadyguy" />
      <xs:enumeration value="crowd" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="entitytypeexprlookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="entitytype.officer" />
          <xs:enumeration value="entitytype.trader" />
          <xs:enumeration value="entitytype.factionrepresentative" />
          <xs:enumeration value="entitytype.shadyguy" />
          <xs:enumeration value="entitytype.crowd" />
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="entitytype">
    <xs:annotation>
      <xs:documentation>
        Actor (entity) type
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="entitytypeexprlookup" />
  </xs:simpleType>

  <xs:simpleType name="entityroleexprlookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="entityrole.service" />
          <xs:enumeration value="entityrole.marine" />
          <xs:enumeration value="entityrole.passenger" />
          <xs:enumeration value="entityrole.prisoner" />
          <xs:enumeration value="entityrole.trainee_group" />
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="entityrole">
    <xs:annotation>
      <xs:documentation>
        Actor (entity) role
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="entityroleexprlookup" />
  </xs:simpleType>

  <xs:simpleType name="skilltypelookup">
    <xs:restriction base="xs:string">
      <xs:enumeration value="boarding" />
      <xs:enumeration value="engineering" />
      <xs:enumeration value="management" />
      <xs:enumeration value="morale" />
      <xs:enumeration value="piloting" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="skilltypeexprlookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="skilltype.boarding" />
          <xs:enumeration value="skilltype.engineering" />
          <xs:enumeration value="skilltype.management" />
          <xs:enumeration value="skilltype.morale" />
          <xs:enumeration value="skilltype.piloting" />
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="skilltype">
    <xs:annotation>
      <xs:documentation>
        Skill type
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="skilltypeexprlookup" />
  </xs:simpleType>

  <xs:simpleType name="controlpostexprlookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="controlpost.aipilot" />
          <xs:enumeration value="controlpost.defence" />
          <xs:enumeration value="controlpost.manager" />
          <xs:enumeration value="controlpost.engineer" />
          <xs:enumeration value="controlpost.shadyguy" />
          <xs:enumeration value="controlpost.shiptrader" />
          <xs:enumeration value="controlpost.trainee_individual" />
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="controlpost">
    <xs:annotation>
      <xs:documentation>
        Control post
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="controlpostexprlookup" />
  </xs:simpleType>

  <xs:simpleType name="assignmentexprlookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="assignment.defence" />
          <xs:enumeration value="assignment.attack" />
          <xs:enumeration value="assignment.interception" />
          <xs:enumeration value="assignment.assist" />
          <xs:enumeration value="assignment.mining" />
          <xs:enumeration value="assignment.trade" />
          <xs:enumeration value="assignment.build" />
          <xs:enumeration value="assignment.supplyfleet" />
          <xs:enumeration value="assignment.tradeforbuildstorage" />
          <xs:enumeration value="assignment.follow" />
          <xs:enumeration value="assignment.police" />
          <xs:enumeration value="assignment.watchdog" />
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="assignment">
    <xs:annotation>
      <xs:documentation>
        Subordinate assignment
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="assignmentexprlookup" />
  </xs:simpleType>

  <xs:simpleType name="controlpositionexprlookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="controlposition.comms" />
          <xs:enumeration value="controlposition.coordination" />
          <xs:enumeration value="controlposition.engineering" />
          <xs:enumeration value="controlposition.flight" />
          <xs:enumeration value="controlposition.gunner" />
          <xs:enumeration value="controlposition.manager" />
          <xs:enumeration value="controlposition.navigation" />
          <xs:enumeration value="controlposition.pilot" />
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="controlposition">
    <xs:annotation>
      <xs:documentation>
        Control position lookup
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="controlpositionexprlookup" />
  </xs:simpleType>

  <xs:simpleType name="infolibrarytypelookup">
    <xs:restriction base="xs:string">
      <xs:enumeration value="shiptypes_xl" />
      <xs:enumeration value="shiptypes_l" />
      <xs:enumeration value="shiptypes_m" />
      <xs:enumeration value="shiptypes_s" />
      <xs:enumeration value="shiptypes_xs" />
      <xs:enumeration value="stationtypes" />
      <xs:enumeration value="moduletypes_production" />
      <xs:enumeration value="moduletypes_build" />
      <xs:enumeration value="moduletypes_storage" />
      <xs:enumeration value="moduletypes_habitation" />
      <xs:enumeration value="moduletypes_defence" />
      <xs:enumeration value="moduletypes_communication" />
      <xs:enumeration value="moduletypes_dock" />
      <xs:enumeration value="moduletypes_pier" />
      <xs:enumeration value="moduletypes_other" />
      <xs:enumeration value="moduletypes_venture" />
      <xs:enumeration value="weapons_lasers" />
      <xs:enumeration value="weapons_missilelaunchers" />
      <xs:enumeration value="weapons_turrets" />
      <xs:enumeration value="weapons_missileturrets" />
      <xs:enumeration value="shieldgentypes" />
      <xs:enumeration value="enginetypes" />
      <xs:enumeration value="thrustertypes" />
      <xs:enumeration value="missiletypes" />
      <xs:enumeration value="marines" />
      <xs:enumeration value="unique_npcs" />
      <xs:enumeration value="wares" />
      <xs:enumeration value="productionmethods" />
      <xs:enumeration value="researchmethods" />
      <xs:enumeration value="researchables" />
      <xs:enumeration value="inventory_wares" />
      <xs:enumeration value="races" />
      <xs:enumeration value="factions" />
      <xs:enumeration value="licences" />
      <xs:enumeration value="entitytypes" />
      <xs:enumeration value="equipmentmods" />
      <xs:enumeration value="paintmods" />
      <xs:enumeration value="clothingmods" />
      <xs:enumeration value="software" />
      <xs:enumeration value="bombs" />
      <xs:enumeration value="lasertowers" />
      <xs:enumeration value="mines" />
      <xs:enumeration value="navbeacons" />
      <xs:enumeration value="resourceprobes" />
      <xs:enumeration value="satellites" />
      <xs:enumeration value="timeline" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="roompopulationtypelookup">
    <xs:restriction base="xs:string">
      <xs:enumeration value="build" />
      <xs:enumeration value="trade" />
      <xs:enumeration value="drones" />
      <xs:enumeration value="ships" />
      <xs:enumeration value="repair" />
      <xs:enumeration value="ammo" />
      <xs:enumeration value="bar" />
      <xs:enumeration value="administrative" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="roompopulationtypeexprlookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="roompopulationtype.build" />
          <xs:enumeration value="roompopulationtype.trade" />
          <xs:enumeration value="roompopulationtype.drones" />
          <xs:enumeration value="roompopulationtype.ships" />
          <xs:enumeration value="roompopulationtype.repair" />
          <xs:enumeration value="roompopulationtype.ammo" />
          <xs:enumeration value="roompopulationtype.bar" />
          <xs:enumeration value="roompopulationtype.administrative" />
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="profilelookup">
    <xs:restriction base="xs:string">
      <xs:enumeration value="flat">
        <xs:annotation>
          <xs:documentation>
            Flat (linear) distribution, default if no profile specified
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="increasing">
        <xs:annotation>
          <xs:documentation>
            Higher numbers are more likely
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="decreasing">
        <xs:annotation>
          <xs:documentation>
            Lower numbers are more likely
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="bell">
        <xs:annotation>
          <xs:documentation>
            Numbers in the middle of the range are more likely
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="inversebell">
        <xs:annotation>
          <xs:documentation>
            Higher and lower numbers are more likely than those in the middle
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="uipositionlookup">
    <xs:annotation>
      <xs:documentation>
        Position in conversation menu (a free position is selected if not supplied). This can be either a fixed named value, or a variable script expression (providing the option number between 1 and 6).
      </xs:documentation>
    </xs:annotation>
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="top_left" />
          <xs:enumeration value="left" />
          <xs:enumeration value="bottom_left" />
          <xs:enumeration value="top_right" />
          <xs:enumeration value="right" />
          <xs:enumeration value="bottom_right" />
          <xs:enumeration value="close">
            <xs:annotation>
              <xs:documentation>
                Hidden player choice that is selected when the player presses the &quot;close conversation&quot; button
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="helppositionlookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="0">
            <xs:annotation>
              <xs:documentation>
                Top left corner (default)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="1">
            <xs:annotation>
              <xs:documentation>
                Middle of screen (targeting)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="2">
            <xs:annotation>
              <xs:documentation>
                Near weapon monitor
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="3">
            <xs:annotation>
              <xs:documentation>
                Near event monitor
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="4">
            <xs:annotation>
              <xs:documentation>
                Near speedbar
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="levellookup">
    <xs:annotation>
      <xs:documentation>
        Difficulty level
      </xs:documentation>
    </xs:annotation>
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="level.trivial">
            <xs:annotation>
              <xs:documentation>
                Trivial difficulty level
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="level.veryeasy">
            <xs:annotation>
              <xs:documentation>
                Very easy difficulty level
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="level.easy">
            <xs:annotation>
              <xs:documentation>
                Easy difficulty level
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="level.medium">
            <xs:annotation>
              <xs:documentation>
                Medium difficulty level
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="level.hard">
            <xs:annotation>
              <xs:documentation>
                Hard difficulty level
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="level.veryhard">
            <xs:annotation>
              <xs:documentation>
                Very hard difficulty level
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="level.impossible">
            <xs:annotation>
              <xs:documentation>
                Impossible difficulty level
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="upkeepalertlevellookup">
    <xs:annotation>
      <xs:documentation>
        Upkeep alert level
      </xs:documentation>
    </xs:annotation>
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="alertlevel.low">
            <xs:annotation>
              <xs:documentation>
                Low upkeep alert level
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="alertlevel.medium">
            <xs:annotation>
              <xs:documentation>
                Medium upkeep alert level
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="alertlevel.high">
            <xs:annotation>
              <xs:documentation>
                High upkeep alert level
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="logcategorylookup">
    <xs:annotation>
      <xs:documentation>
        Logbook category
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="general" />
      <xs:enumeration value="missions" />
      <xs:enumeration value="news" />
      <xs:enumeration value="upkeep" />
      <xs:enumeration value="alerts" />
      <xs:enumeration value="tips" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="loginteractionlookup">
    <xs:annotation>
      <xs:documentation>
        Logbook interaction type
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="guidance">
        <xs:annotation>
          <xs:documentation>
            Starts guidance to the object from the logbook UI
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="showonmap">
        <xs:annotation>
          <xs:documentation>
            Opens the map focused on the object from the logbook UI
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="relationcomparison">
    <xs:annotation>
      <xs:documentation>
        Behaviour to compare the relation range
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="exact">
        <xs:annotation>
          <xs:documentation>
            Relation is in range (default)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ge">
        <xs:annotation>
          <xs:documentation>
            Relation is greater than or equal
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="gt">
        <xs:annotation>
          <xs:documentation>
            Relation is greater than
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="le">
        <xs:annotation>
          <xs:documentation>
            Relation is less than or equal
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="lt">
        <xs:annotation>
          <xs:documentation>
            Relation is less than
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="not">
        <xs:annotation>
          <xs:documentation>
            Relation is not in range
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="formationshapelookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="formationshape.dummy">
            <xs:annotation>
              <xs:documentation>
                unsupported - Dummy, no param
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="formationshape.circle">
            <xs:annotation>
              <xs:documentation>
                param = radius
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="formationshape.halfcircle">
            <xs:annotation>
              <xs:documentation>
                param = radius
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="formationshape.invpointguard">
            <xs:annotation>
              <xs:documentation>
                param = radius
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="formationshape.pointguard">
            <xs:annotation>
              <xs:documentation>
                param = radius
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="formationshape.randomshape">
            <xs:annotation>
              <xs:documentation>
                unsupported
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="formationshape.rotatingcircle">
            <xs:annotation>
              <xs:documentation>
                unsupported
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="formationshape.singlefile">
            <xs:annotation>
              <xs:documentation>
                param = distance
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="formationshape.vshape">
            <xs:annotation>
              <xs:documentation>
                param = distance
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="formationshape.invvshape">
            <xs:annotation>
              <xs:documentation>
                param = distance
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="formationshape.cross">
            <xs:annotation>
              <xs:documentation>
                param = distance
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="formationshape.crossback">
            <xs:annotation>
              <xs:documentation>
                param = distance
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="formationshape.crossforward">
            <xs:annotation>
              <xs:documentation>
                param = distance
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="formationshape.xshape">
            <xs:annotation>
              <xs:documentation>
                param = distance
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="formationshape.xshapeforward">
            <xs:annotation>
              <xs:documentation>
                param = distance
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="formationshape.xshapeback">
            <xs:annotation>
              <xs:documentation>
                param = distance
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="formationshape.triangle">
            <xs:annotation>
              <xs:documentation>
                param = distance
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="formationshape.lineabreast">
            <xs:annotation>
              <xs:documentation>
                param = distance
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="formationshape.lineastern">
            <xs:annotation>
              <xs:documentation>
                param = distance
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="formationshape.wshape">
            <xs:annotation>
              <xs:documentation>
                param = distance
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="formationshape.eagle">
            <xs:annotation>
              <xs:documentation>
                param = distance
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="formationshape.twin">
            <xs:annotation>
              <xs:documentation>
                param = distance
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="formationshape.vulcan">
            <xs:annotation>
              <xs:documentation>
                param = distance
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="formationshape.dartvertical">
            <xs:annotation>
              <xs:documentation>
                param = distance
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="formationshape.darthorizontal">
            <xs:annotation>
              <xs:documentation>
                param = distance
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="formationshape.echelon">
            <xs:annotation>
              <xs:documentation>
                param = distance
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="licencelookup">
    <xs:restriction base="xs:string">
      <xs:enumeration value="capitalequipment" />
      <xs:enumeration value="capitalship" />
      <xs:enumeration value="ceremonyfriend" />
      <xs:enumeration value="ceremonyally" />
      <xs:enumeration value="generaluseequipment" />
      <xs:enumeration value="generaluseship" />
      <xs:enumeration value="intelligence" />
      <xs:enumeration value="militaryequipment" />
      <xs:enumeration value="militaryship" />
      <xs:enumeration value="police" />
      <xs:enumeration value="station_gen_basic" />
      <xs:enumeration value="station_gen_intermediate" />
      <xs:enumeration value="station_gen_advanced" />
      <xs:enumeration value="station_equip_sm" />
      <xs:enumeration value="station_equip_lxl" />
      <xs:enumeration value="station_illegal" />
      <xs:enumeration value="station_race_basic" />
      <xs:enumeration value="station_race_intermediate" />
      <xs:enumeration value="station_race_advanced" />
      <xs:enumeration value="station_venture" />
      <xs:enumeration value="subgroupfriend" />
      <xs:enumeration value="tradesubscription" />
      <xs:enumeration value="innercore_access" />
      <xs:enumeration value="outercore_access" />
      <xs:enumeration value="shipsalecontract" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="relationlookup">
    <xs:restriction base="xs:string">
      <xs:enumeration value="dock" />
      <xs:enumeration value="enemy" />
      <xs:enumeration value="friend" />
      <xs:enumeration value="kill" />
      <xs:enumeration value="killmilitary" />
      <xs:enumeration value="member" />
      <xs:enumeration value="nemesis" />
      <xs:enumeration value="neutral" />
      <xs:enumeration value="self" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="tradesorterlookup">
    <xs:restriction base="xs:string">
      <xs:enumeration value="amount" />
      <xs:enumeration value="distance" />
      <xs:enumeration value="name" />
      <xs:enumeration value="offeramount" />
      <xs:enumeration value="price" />
      <xs:enumeration value="relativeprice" />
      <xs:enumeration value="stocklevel" />
      <xs:enumeration value="totalprice" />
      <xs:enumeration value="totalvolume" />
      <xs:enumeration value="volume" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="npcsummarysorterlookup">
    <xs:restriction base="xs:string">
      <xs:enumeration value="template" />
      <xs:enumeration value="name" />
      <xs:enumeration value="role" />
      <xs:enumeration value="skill" />
      <xs:enumeration value="combinedskill" />
      <xs:enumeration value="potentialskillforpost" />
      <xs:enumeration value="potentialskillforrole" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="unitcategorylookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="unitcategory.attack" />
          <xs:enumeration value="unitcategory.build" />
          <xs:enumeration value="unitcategory.defence" />
          <xs:enumeration value="unitcategory.gascollector" />
          <xs:enumeration value="unitcategory.guard" />
          <xs:enumeration value="unitcategory.orecollector" />
          <xs:enumeration value="unitcategory.police" />
          <xs:enumeration value="unitcategory.repair" />
          <xs:enumeration value="unitcategory.transport" />
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="deployablecategorylookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="deployablecategory.lasertower" />
          <xs:enumeration value="deployablecategory.mine" />
          <xs:enumeration value="deployablecategory.navbeacon" />
          <xs:enumeration value="deployablecategory.resourceprobe" />
          <xs:enumeration value="deployablecategory.satellite" />
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="entityhirablerolelookup">
    <xs:restriction base="xs:string">
      <xs:enumeration value="service" />
      <xs:enumeration value="marine" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="entityrolelookup">
    <xs:restriction base="xs:string">
      <xs:enumeration value="service" />
      <xs:enumeration value="marine" />
      <xs:enumeration value="passenger" />
      <xs:enumeration value="prisoner" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="purposelookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="purpose.trade" />
          <xs:enumeration value="purpose.fight" />
          <xs:enumeration value="purpose.build" />
          <xs:enumeration value="purpose.mine" />
          <xs:enumeration value="purpose.auxiliary" />
          <xs:enumeration value="purpose.hack" />
          <xs:enumeration value="purpose.scan" />
          <xs:enumeration value="purpose.production" />
          <xs:enumeration value="purpose.storage" />
          <xs:enumeration value="purpose.connection" />
          <xs:enumeration value="purpose.habitation" />
          <xs:enumeration value="purpose.defence" />
          <xs:enumeration value="purpose.docking" />
          <xs:enumeration value="purpose.venture" />
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="targetpointtypelookup">
    <xs:annotation>
      <xs:documentation>
        Implicitly defines the interactions and the icon this target point should have
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="scan" />
      <xs:enumeration value="hack" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="controlpaneltypelookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="controlpaneltype.hack_all_turrets" />
          <xs:enumeration value="controlpaneltype.hack_buildmodules" />
          <xs:enumeration value="controlpaneltype.hack_discount" />
          <xs:enumeration value="controlpaneltype.hack_engineer" />
          <xs:enumeration value="controlpaneltype.hack_production" />
          <xs:enumeration value="controlpaneltype.hack_shieldgenerators" />
          <xs:enumeration value="controlpaneltype.hack_storage" />
          <xs:enumeration value="controlpaneltype.hack_watchdogs" />
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="signalleaktypelookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="signalleaktype.claim" />
          <xs:enumeration value="signalleaktype.data" />
          <xs:enumeration value="signalleaktype.mission" />
          <xs:enumeration value="signalleaktype.voice" />
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="boardingphaselookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="boardingphase.setup" />
          <xs:enumeration value="boardingphase.pre_approach" />
          <xs:enumeration value="boardingphase.approach" />
          <xs:enumeration value="boardingphase.pre_infiltration" />
          <xs:enumeration value="boardingphase.infiltration" />
          <xs:enumeration value="boardingphase.internalfight" />
          <xs:enumeration value="boardingphase.failed" />
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="boardingbehaviourlookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="boardingbehaviour.attackescorts" />
          <xs:enumeration value="boardingbehaviour.targetengines" />
          <xs:enumeration value="boardingbehaviour.targetturrets" />
          <xs:enumeration value="boardingbehaviour.disabletarget" />
          <xs:enumeration value="boardingbehaviour.maintaindistance" />
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="blacklisttypelookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="blacklisttype.sectortravel" />
          <xs:enumeration value="blacklisttype.sectoractivity" />
          <xs:enumeration value="blacklisttype.objectactivity" />
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="blacklistgrouplookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="blacklistgroup.civilian" />
          <xs:enumeration value="blacklistgroup.military" />
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="marinestatuslookup">
    <xs:restriction base="xs:string">
      <xs:enumeration value="infiltrating" />
      <xs:enumeration value="fighting" />
      <xs:enumeration value="killed" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="waretransportlookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="waretransport.container" />
          <xs:enumeration value="waretransport.solid" />
          <xs:enumeration value="waretransport.liquid" />
          <xs:enumeration value="waretransport.passenger" />
          <xs:enumeration value="waretransport.equipment" />
          <xs:enumeration value="waretransport.inventory" />
          <xs:enumeration value="waretransport.software" />
          <xs:enumeration value="waretransport.ship" />
          <xs:enumeration value="waretransport.workunit" />
          <xs:enumeration value="waretransport.research" />
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="relationchangereasonlookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="relationchangereason.missioncompleted" />
          <xs:enumeration value="relationchangereason.destroyedfactionenemy" />
          <xs:enumeration value="relationchangereason.smalltalkreward" />
          <xs:enumeration value="relationchangereason.attackedobject" />
          <xs:enumeration value="relationchangereason.boardedobject" />
          <xs:enumeration value="relationchangereason.killedobject" />
          <xs:enumeration value="relationchangereason.hackingdiscovered" />
          <xs:enumeration value="relationchangereason.scanningdiscovered" />
          <xs:enumeration value="relationchangereason.illegalcargo" />
          <xs:enumeration value="relationchangereason.missionfailed" />
          <xs:enumeration value="relationchangereason.tradecompleted" />
          <xs:enumeration value="relationchangereason.illegalplot" />
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="moodtypelookup">
    <xs:annotation>
      <xs:documentation>
        Faction mood type
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="aggression" />
      <xs:enumeration value="avarice" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="moodlevellookup">
    <xs:annotation>
      <xs:documentation>
        Faction mood level
      </xs:documentation>
    </xs:annotation>
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="moodlevel.verylow" />
          <xs:enumeration value="moodlevel.low" />
          <xs:enumeration value="moodlevel.normal" />
          <xs:enumeration value="moodlevel.high" />
          <xs:enumeration value="moodlevel.veryhigh" />
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="orderstatelookup">
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="orderstate.setup">
            <xs:annotation>
              <xs:documentation>
                Order is in the parameter setup process, not all parameters have been provided yet. In this state the order cannot be enabled.
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="orderstate.disabled">
            <xs:annotation>
              <xs:documentation>
                Order is disabled (this state is automatically entered when parameter setup is complete)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="orderstate.ready">
            <xs:annotation>
              <xs:documentation>
                Order is enabled but not running yet. In this state, an order in the queue is started when it becomes the current order (which is always the first order, except in order loops).
                A default order is started if no order in the queue is ready.
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="orderstate.started">
            <xs:annotation>
              <xs:documentation>
                Order script has started and has not entered the critical state or the finish state.
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="orderstate.critical">
            <xs:annotation>
              <xs:documentation>
                Order script has entered its critical state. In this state, the order cannot be cancelled directly any more, and parameters can only be edited if allowed by the order definition.
                Moving or disabling the order is not possible any more. Requests to cancel the order can be made, but they are not necessarily processed immediately; the cancelling behaviour
                is order-specific. To handle a cancel request in the critical state, the order script stack has to listen to &lt;event_object_order_cancelled&gt; with immediate=&quot;false&quot;.
                If not cancelled, the order can optionally leave the critical state by entering the finish state.
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="orderstate.finish">
            <xs:annotation>
              <xs:documentation>
                Optional state that can be entered by the order script for finalisation actions. Disabling, moving and editing the order is not possible any more.
                The critical state cannot be entered any more. The order can be cancelled instantly at any time (unlike in the critical state, cancel requests are not passed to the script stack
                and cannot fail). This state could e.g. be useful if the actual order is already completed but the ship should move &quot;out of the way&quot; before continuing with the next order.
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <!-- 
          <xs:enumeration value="orderstate.finished">
            <xs:annotation>
              <xs:documentation>
                The order script has finished running and the order is about to be removed (or reset in case of a user-created loop order). This state is not supposed to be encountered by scripts.
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
 -->
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="loadoutflaglookup">
    <xs:restriction base="xs:string">
      <xs:enumeration value="engines">
        <xs:annotation>
          <xs:documentation>
            Engines.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="weapons">
        <xs:annotation>
          <xs:documentation>
            Weapons.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="shields">
        <xs:annotation>
          <xs:documentation>
            Shields.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="turrets">
        <xs:annotation>
          <xs:documentation>
            Turrets.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="shieldgroups">
        <xs:annotation>
          <xs:documentation>
            Shield groups.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="turretgroups">
        <xs:annotation>
          <xs:documentation>
            Turret groups.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ammo">
        <xs:annotation>
          <xs:documentation>
            Ammunition.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="units">
        <xs:annotation>
          <xs:documentation>
            Units (drones).
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="software">
        <xs:annotation>
          <xs:documentation>
            Software.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="thrusters">
        <xs:annotation>
          <xs:documentation>
            Thrusters.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="crew">
        <xs:annotation>
          <xs:documentation>
            Crew (only used when applying player-created loadouts or when people data is not supplied)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="drones">
        <xs:annotation>
          <xs:documentation>
            Ability drones.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="add">
        <xs:annotation>
          <xs:documentation>
            Add loadout elements (not used for loadout generation).
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="remove">
        <xs:annotation>
          <xs:documentation>
            Remove loadout elements (not used for loadout generation).
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="loadoutflagbitmask">
    <xs:annotation>
      <xs:documentation>
        Loadout flag bitmask (use as many as required).
      </xs:documentation>
    </xs:annotation>
    <xs:list itemType="loadoutflaglookup" />
  </xs:simpleType>

  <xs:simpleType name="propflaglookup">
    <xs:restriction base="xs:string">
      <xs:enumeration value="canbuildships">
        <xs:annotation>
          <xs:documentation>
            Object has ship production facilities
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="cannotbuildships">
        <xs:annotation>
          <xs:documentation>
            Object does not have ship production facilities
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="cannotequipships">
        <xs:annotation>
          <xs:documentation>
            Object does not have ship equiping facilities
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="factionrepresentative">
        <xs:annotation>
          <xs:documentation>
            Object has faction leader on board
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="equipmentdock">
        <xs:annotation>
          <xs:documentation>
            Object has ship equipping facilities but no ship production
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="propflagbitmask">
    <xs:annotation>
      <xs:documentation>
        Prop flag bitmask (use as many as required).
      </xs:documentation>
    </xs:annotation>
    <xs:list itemType="propflaglookup" />
  </xs:simpleType>

  <xs:simpleType name="wareflaglookup">
    <xs:restriction base="xs:string">
      <xs:enumeration value="allowplayerblueprint">
        <xs:annotation>
          <xs:documentation>
            Allow Player Blueprint
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="blueprint">
        <xs:annotation>
          <xs:documentation>
            Blueprint
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="clothingmod">
        <xs:annotation>
          <xs:documentation>
            Clothing Mod
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="crafting">
        <xs:annotation>
          <xs:documentation>
            Crafting
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="economy">
        <xs:annotation>
          <xs:documentation>
            Economy
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="equipment">
        <xs:annotation>
          <xs:documentation>
            Equipment
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="illegal">
        <xs:annotation>
          <xs:documentation>
            Illegal
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="inventory">
        <xs:annotation>
          <xs:documentation>
            Inventory
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="gift">
        <xs:annotation>
          <xs:documentation>
            Gift
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="rare">
        <xs:annotation>
          <xs:documentation>
            Rare
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="allowdrop">
        <xs:annotation>
          <xs:documentation>
            Allow Drop
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="equipmentmod">
        <xs:annotation>
          <xs:documentation>
            Equipment Mod
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="lockbox">
        <xs:annotation>
          <xs:documentation>
            Lockbox
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="missiononly">
        <xs:annotation>
          <xs:documentation>
            Mission Only
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="module">
        <xs:annotation>
          <xs:documentation>
            Module
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="paintmod">
        <xs:annotation>
          <xs:documentation>
            Paint Mod
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="personalupgrade">
        <xs:annotation>
          <xs:documentation>
            Personal Upgrade
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="resource">
        <xs:annotation>
          <xs:documentation>
            Resource
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="scanner">
        <xs:annotation>
          <xs:documentation>
            Scanner
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ship">
        <xs:annotation>
          <xs:documentation>
            Ship
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="singlecraft">
        <xs:annotation>
          <xs:documentation>
            Single Craft
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="tradeonly">
        <xs:annotation>
          <xs:documentation>
            Trade Only
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="tradeware">
        <xs:annotation>
          <xs:documentation>
            Trade Ware
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="unbundleammo">
        <xs:annotation>
          <xs:documentation>
            Unbundle Ammo
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="useritem">
        <xs:annotation>
          <xs:documentation>
            User Item
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="volatile">
        <xs:annotation>
          <xs:documentation>
            Volatile
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="wareflags">
    <xs:annotation>
      <xs:documentation>
        Ware flag (use as many as required).
      </xs:documentation>
    </xs:annotation>
    <xs:list itemType="wareflaglookup" />
  </xs:simpleType>

  <xs:simpleType name="animationtriggerlookup">
    <xs:restriction base="xs:string">
      <xs:enumeration value="abort" />
      <xs:enumeration value="assign_dockingbay" />
      <xs:enumeration value="attacked" />
      <xs:enumeration value="activate" />
      <xs:enumeration value="activate_chair" />
      <xs:enumeration value="activate_chair_holo" />
      <xs:enumeration value="activate_dockguidance" />
      <xs:enumeration value="activate_dockingbay_warning" />
      <xs:enumeration value="activate_landinggears" />
      <xs:enumeration value="battlestate_red" />
      <xs:enumeration value="battlestate_yellow" />
      <xs:enumeration value="battlestate_jumpprep" />
      <xs:enumeration value="chairconfig_default" />
      <xs:enumeration value="chairconfig_paranid" />
      <xs:enumeration value="close_cockpit" />
      <xs:enumeration value="close_dockingbay" />
      <xs:enumeration value="close_dockingbay_fence" />
      <xs:enumeration value="close_doors" />
      <xs:enumeration value="close_doors2" />
      <xs:enumeration value="close_hangar" />
      <xs:enumeration value="cockpit_active" />
      <xs:enumeration value="cockpit_inactive" />
      <xs:enumeration value="damage_high" />
      <xs:enumeration value="damage_low" />
      <xs:enumeration value="damage_medium" />
      <xs:enumeration value="damage_none" />
      <xs:enumeration value="deactivate" />
      <xs:enumeration value="deactivate_chair" />
      <xs:enumeration value="deactivate_chair_holo" />
      <xs:enumeration value="deactivate_dockguidance" />
      <xs:enumeration value="deactivate_dockingbay_warning" />
      <xs:enumeration value="deactivate_landinggears" />
      <xs:enumeration value="fire" />
      <xs:enumeration value="open_cockpit" />
      <xs:enumeration value="open_dockingbay" />
      <xs:enumeration value="open_dockingbay_fence" />
      <xs:enumeration value="open_doors" />
      <xs:enumeration value="open_doors2" />
      <xs:enumeration value="open_hangar" />
      <xs:enumeration value="quickenter" />
      <xs:enumeration value="retrieve_ship" />
      <xs:enumeration value="retrieve_ship_faster" />
      <xs:enumeration value="retrieve_ship_fastest" />
      <xs:enumeration value="startcontrol" />
      <xs:enumeration value="stopcontrol" />
      <xs:enumeration value="store_ship" />
      <xs:enumeration value="store_ship_faster" />
      <xs:enumeration value="store_ship_fastest" />
      <xs:enumeration value="unassign_dockingbay" />
      <xs:enumeration value="music_default" />
      <xs:enumeration value="music_01" />
      <xs:enumeration value="music_02" />
      <xs:enumeration value="music_03" />
      <xs:enumeration value="music_04" />
      <xs:enumeration value="music_off" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="encountertypelookup">
    <xs:restriction base="xs:string">
      <xs:enumeration value="destruction">
        <xs:annotation>
          <xs:documentation>
            Object has been destroyed.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="damage">
        <xs:annotation>
          <xs:documentation>
            Object has been damaged. Param = string describing the severity: low, medium, high
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="loot">
        <xs:annotation>
          <xs:documentation>
            Object has acquired loot. Param = string describing the value: low, medium, high
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="terraformingpricescalelookup">
    <xs:restriction base="xs:string">
      <xs:enumeration value="absolute">
        <xs:annotation>
          <xs:documentation>
            Defined price value is in Credits, not to be scaled.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="playeraccount">
        <xs:annotation>
          <xs:documentation>
            Defined price value is a percentage applied to the player's current account.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="population">
        <xs:annotation>
          <xs:documentation>
            Price scales with the world's current population. Defined value is for 100k inhabitants.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <!-- ===== Attribute groups ==== -->

  <!-- Base attribute group for filters, does not contain class attribute and class-specific attributes. They are added in sub-groups where required. -->
  <xs:attributeGroup name="find">
    <xs:attribute name="macro" type="expression">
      <xs:annotation>
        <xs:documentation>
          Macro or list of macros
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="owner" type="owners" />
    <xs:attribute name="trueowner" type="owners" />
    <xs:attribute name="coverowner" type="owners" />
    <xs:attribute name="policefaction" type="owners" />
    <xs:attribute name="negateownerfilter" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Treat owner, trueowner or coverowner as "not"-list?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tag" type="expression">
      <xs:annotation>
        <xs:documentation>
          Connection tag
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="excluded" type="expression">
      <xs:annotation>
        <xs:documentation>
          Component, list of components or a group to exclude from being found
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="grouptag" type="expression">
      <xs:annotation>
        <xs:documentation>
          Connection group tag
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="state" type="componentstateexprlookup">
      <xs:annotation>
        <xs:documentation>
          State of component
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="integrated" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is integrated to the parent? (built-in component)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="invulnerable" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is either hull or shield invulnerable, i.e it cannot take damage? Note: An object can be vulnerable but still indestructible.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hullinvulnerable" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is hull invulnerable, i.e it cannot take take damage?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="shieldinvulnerable" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is shield invulnerable, i.e it cannot take damage?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="indestructible" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Can the object not be destroyed through damage?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="checkoperational" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Should the search be restricted to operational objects? If yes, this is equivalent to state="componentstate.operational".
          This is implicitly enabled in action elements (e.g. &lt;find_...&gt;) or condition elements (e.g. &lt;count_...&gt;),
          so it is true by default and can be disabled by supplying checkoperational="false".
          On any sub-elements (e.g. &lt;match...&gt;) it is false by default, so also non-operational objects are matched by default (unless already filtered out elsewhere).
          If the state attribute is present on a node, checkoperational is ignored.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="functional" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is functional?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="surfaceelement" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is a surface element?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="module" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is a module?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="known" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Known to player?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="knownto" type="factionexprlookup">
      <xs:annotation>
        <xs:documentation>
          Known to faction? (Faction or list of factions)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="suspicious" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Suspicious?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destination" type="expression">
      <xs:annotation>
        <xs:documentation>
          Leads to this destination? (could be space, gate or highway exit gate)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hastradeoffer" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Component contains a trade offer?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tradesknownto" type="factionexprlookup">
      <xs:annotation>
        <xs:documentation>
          Does the provided faction have knowledge of trade offers of the container?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="canhaveofferlocation" type="expression">
      <xs:annotation>
        <xs:documentation>
          Offer tag
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="freemissionofferslot" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is a free mission offer location available at the container?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="freesignalleakslot" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is a free signal leak location available at the object?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numfreeactorslots" type="numfreeactorslots" />
    <xs:attribute name="freemissionactorslot" type="freemissionactorslot" />
    <xs:attribute name="masstraffic" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is object from mass traffic?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="onlineobject" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is object an online object?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="visitor" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is object a visitor?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="walkable" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the room walkable, i.e. accessible to the player and NPCs?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="roompopulationtype" type="roompopulationtypeexprlookup">
      <xs:annotation>
        <xs:documentation>
          Room population type
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="building" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is build module currently building
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="busy" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is build module or build processor currently busy
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hasbuildingtask" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Does the object have a build task assigned for it?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="canbebuiltby" type="expression">
      <xs:annotation>
        <xs:documentation>
          Can be built by this object?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="canbebuiltbyany" type="expression">
      <xs:annotation>
        <xs:documentation>
          Can be built by any of these objects? (list or group)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="canbuildfor" type="factionexprlookup">
      <xs:annotation>
        <xs:documentation>
          Does the object allow the provided faction to build
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="canbuildclass" type="expression">
      <xs:annotation>
        <xs:documentation>
          Can build class? If null, filter is not applied.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="canbuildships" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Can build ships? (finds containers, not build modules)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="canequipclass" type="expression">
      <xs:annotation>
        <xs:documentation>
          Can equip class? If null, filter is not applied.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cansupplyclass" type="expression">
      <xs:annotation>
        <xs:documentation>
          Can supply class? If null, filter is not applied.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="canequipships" type="expression">
      <xs:annotation>
        <xs:documentation>
          Can equip ships? (finds containers, not build modules)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cansupplyships" type="expression">
      <xs:annotation>
        <xs:documentation>
          Can supply ships? (finds containers, not build modules)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="canbuildequipment" type="expression">
      <xs:annotation>
        <xs:documentation>
          Can build equipment ware (or list of wares)?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="canbuildmacro" type="expression">
      <xs:annotation>
        <xs:documentation>
          Can build macro?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="waretransport" type="waretransportlookup">
      <xs:annotation>
        <xs:documentation>
          Can carry this waretransport type or list or waretransport types (can find containers or storage modules)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="weaponmode" type="weaponmodelookup">
      <xs:annotation>
        <xs:documentation>
          Weapon mode
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="weapontype" type="weapontypelookup">
      <xs:annotation>
        <xs:documentation>
          Weapon type
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="primarypurpose" type="purposelookup">
      <xs:annotation>
        <xs:documentation>
          Primary purpose
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deployable" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is a deployable object
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datavault" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is a data vault object
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deployablecategory" type="deployablecategorylookup">
      <xs:annotation>
        <xs:documentation>
          Deployable category
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mayattack" type="expression">
      <xs:annotation>
        <xs:documentation>
          Does this object's relation and fire authorisation override allow it to attack supplied object or faction. Unless active fire authorisation override indicates otherwise, true if relation is 'kill', or if relation is 'killmilitary' and supplied object has primarypurpose.fight.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maybeattackedby" type="expression">
      <xs:annotation>
        <xs:documentation>
          May this object be attacked by supplied object or faction based on that faction's relation and fire authorisation override. Unless supplied object's active fire authorisation override indicates otherwise, true if relation is 'kill', or if relation is 'killmilitary' and this object has primarypurpose.fight
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ishostileto" type="expression">
      <xs:annotation>
        <xs:documentation>
          Do mutual object relations and fire authorisations allow either side to attack (see mayattack and maybeattackedby).
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="canbepickedup" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Can object be picked up by another object?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="commandeerable" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the object commandeerable
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="unit" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the object a unit
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hascommander" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Does the object have a commander
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hascontrolentity" type="controlpost">
      <xs:annotation>
        <xs:documentation>
          Does the object have a control entity of the specified post
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="capturable" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the object capturable
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="accelerator" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the gate an accelerator
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="active" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the object 'active'?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="paused" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the object 'paused' for any reason? Applicable for production modules.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="pausedmanually" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the object manually 'paused'? Applicable for production modules.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="signalleaktype" type="signalleaktypelookup">
      <xs:annotation>
        <xs:documentation>
          Signal Leak type
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="extension" type="expression">
      <xs:annotation>
        <xs:documentation>
          Source extension id (standard extension)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="personalextension" type="expression">
      <xs:annotation>
        <xs:documentation>
          Source extension id (personal extension)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="covered" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the object covered?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="findext_entity">
    <xs:attribute name="race" type="race" />
    <xs:attribute name="npctemplate" type="expression" />
    <xs:attribute name="entitytype" type="entitytype" />
    <xs:attribute name="entityrole" type="entityrole" />
    <xs:attribute name="controlpost" type="controlpost" />
    <xs:attribute name="controlentity" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the actor a control entity?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="missionactor" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the actor a mission actor?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="representative" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the actor a faction representative?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="temporaryentity" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the actor temporary?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="findext_station">
    <xs:attribute name="hasmasstraffic" type="hasmasstraffic" />
    <xs:attribute name="canclaimownership" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the station capable of claiming ownership of a space?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tradestation" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the station a trade station
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="shipyard" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the station a shipyard (i.e. it can build capital ships)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wharf" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the station a wharf (i.e. it can build non-capital ships)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="equipmentdock" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the station an equipment dock (i.e. it can change loadouts, but not build ships from scratch)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="defencestation" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the station a defence station
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="factionheadquarters" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the station a faction headquarters
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="planneddefencestation" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the station a planned defence station, taking future modules into accounts
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="plannedequipmentdock" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the station a planned equipment dock, taking future modules into accounts
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="plannedfactionheadquarters" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the station a planned faction headquarters
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="plannedheadquarters" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the station a planned headquarters
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="plannedpiratebase" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the station a planned piratebase
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="plannedshipyard" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the station a planned shipyard, taking future modules into accounts
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="plannedtradestation" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the station a planned trade station
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="plannedwharf" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the station a planned wharf, taking future modules into accounts
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="headquarters" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the station a headquarters
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="piratebase" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the station a pirate base
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="findext_ship">
    <xs:attribute name="docked" type="docked" />
    <xs:attribute name="shiptype" type="shiptypeexprlookup" />
    <xs:attribute name="hasjob" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Does the ship have a job
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="job" type="expression">
      <xs:annotation>
        <xs:documentation>
          Job identification string or list of job ID strings
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="validjobship" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the ship and those in its command structure organised correctly, as defined by their jobs?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jobtags" type="expression">
      <xs:annotation>
        <xs:documentation>
          Tag or list of tags to compare with the defined job category tags
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encounterid" type="expression">
      <xs:annotation>
        <xs:documentation>
          Encounter identification string or list of encounter ID strings
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="encountership" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the ship an encounter job ship?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="findext_room">
    <xs:attribute name="roomtype" type="roomtypeexprlookup" />
    <xs:attribute name="hascontrolpanel" type="controlpaneltypelookup">
      <xs:annotation>
        <xs:documentation>
          Room has a control panel of the specified type
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="findext_zone">
    <xs:attribute name="normalzone" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Include only normal zones (not temporary, not gate zone and not highway)?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tempzone" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Include temporary zones?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="findext_sector">
    <xs:attribute name="contested" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the sector contested?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="contestedby" type="factionexprlookup">
      <xs:annotation>
        <xs:documentation>
          Is the sector contested by provided faction?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="findext_cluster">
    <xs:attribute name="normalcluster" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Include only normal clusters (not presentation cluster, not venturer cluster)?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="findext_space">
    <xs:attribute name="accessgrantedto" type="factionexprlookup">
      <xs:annotation>
        <xs:documentation>
          Does the sector owner currently grant access to the provided faction?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="accessrestrictedto" type="factionexprlookup">
      <xs:annotation>
        <xs:documentation>
          Does the sector owner currently restrict access to the provided faction?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="findext_damaged">
    <xs:attribute name="restorable" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Wrecked components that can be restored (exclusive with 'repairable' and 'needsrepair')
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="repairable" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Damaged components that can be repaired but may still be functional (exclusive with 'restorable' and 'needsrepair')
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="needsrepair" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Damaged components that are no longer functional and can be repaired (exclusive with 'restorable' and 'repairable')
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="findarbitrary">
    <xs:attributeGroup ref="find" />
    <xs:attributeGroup ref="findext_cluster" />
    <xs:attributeGroup ref="findext_damaged" />
    <xs:attributeGroup ref="findext_entity" />
    <xs:attributeGroup ref="findext_room" />
    <xs:attributeGroup ref="findext_sector" />
    <xs:attributeGroup ref="findext_ship" />
    <xs:attributeGroup ref="findext_station" />
    <xs:attributeGroup ref="findext_zone" />
    <xs:attributeGroup ref="findext_space" />
    <xs:attribute name="class" type="classlookup">
      <xs:annotation>
        <xs:documentation>
          Class or list of classes (do not use in conjunction with 'exactclass' attribute)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="exactclass" type="classlookup">
      <xs:annotation>
        <xs:documentation>
          Exact class or list of exact classes, not taking subclasses into account (do not use in conjunction with 'class' attribute)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="findentity">
    <xs:attributeGroup ref="find" />
    <xs:attributeGroup ref="findext_entity" />
    <xs:attribute name="class" type="entityclasslookup">
      <xs:annotation>
        <xs:documentation>
          Entity class or list of classes (do not use with 'exactclass')
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="exactclass" type="entityclasslookup">
      <xs:annotation>
        <xs:documentation>
          Entity's exact class (or list of classes), not taking subclasses into account (do not use with 'class')
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="findobject">
    <xs:attributeGroup ref="find"/>
    <xs:attributeGroup ref="findext_ship" />
    <xs:attributeGroup ref="findext_station" />
    <xs:attribute name="class" type="objectclasslookup">
      <xs:annotation>
        <xs:documentation>
          Object class or list of classes (do not use with 'exactclass')
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="exactclass" type="objectclasslookup">
      <xs:annotation>
        <xs:documentation>
          Object's exact class (or list of classes), not taking subclasses into account (do not use with 'class')
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="findstation">
    <xs:attributeGroup ref="find"/>
    <xs:attributeGroup ref="findext_station" />
    <xs:attribute name="class" type="stationclasslookup">
      <xs:annotation>
        <xs:documentation>
          Station class
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="findship">
    <xs:attributeGroup ref="find" />
    <xs:attributeGroup ref="findext_ship" />
    <xs:attribute name="class" type="shipclasslookup">
      <xs:annotation>
        <xs:documentation>
          Ship class
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="findroom">
    <xs:attributeGroup ref="find" />
    <xs:attributeGroup ref="findext_room" />
    <xs:attribute name="class" type="roomclasslookup">
      <xs:annotation>
        <xs:documentation>
          Room class or list of classes (do not use in conjunction with 'exactclass' attribute)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="exactclass" type="roomclasslookup">
      <xs:annotation>
        <xs:documentation>
          Room's exact class or list of exact classes, not taking subclasses into account (do not use in conjunction with 'class' attribute)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="findzone">
    <xs:attributeGroup ref="find" />
    <xs:attributeGroup ref="findext_space" />
    <xs:attributeGroup ref="findext_zone" />
  </xs:attributeGroup>

  <xs:attributeGroup name="findsector">
    <xs:attributeGroup ref="find" />
    <xs:attributeGroup ref="findext_space" />
    <xs:attributeGroup ref="findext_sector" />
  </xs:attributeGroup>

  <xs:attributeGroup name="findcluster">
    <xs:attributeGroup ref="find" />
    <xs:attributeGroup ref="findext_space" />
    <xs:attributeGroup ref="findext_cluster" />
  </xs:attributeGroup>

  <xs:attributeGroup name="sortresult">
    <xs:attribute name="sortbydistanceto" type="expression">
      <xs:annotation>
        <xs:documentation>
          Sort matching objects by distance to provided object (only one sortby* attribute can be used; see also sortdescending and sortlimit, if applicable)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sortbygatedistanceto" type="expression">
      <xs:annotation>
        <xs:documentation>
          Sort matching objects by number of gate jumps to provided object (only one sortby* attribute can be used; see also sortdescending and sortlimit, if applicable)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sortbyvalue" type="expression">
      <xs:annotation>
        <xs:documentation>
          Sort matching objects by a numeric value per object, provided by this script expression, which is evaluated for each object and can access the current object via 'loop.element' (only one sortby* attribute can be used; see also sortdescending and sortlimit, if applicable)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sortdescending" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Should the objects be sorted in descending order? In this case the first object will have the highest associated value (e.g. largest distance when sorting by distance). This has no effect if no sort criteria are defined.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="sortresultwithlimit">
    <xs:attributeGroup ref="sortresult" />
    <xs:attribute name="sortlimit" type="expression">
      <xs:annotation>
        <xs:documentation>
          Optional maximum for the number of provided results after sorting. This has no effect if multiple="false" or if no sort criteria are defined.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="blacklist">
    <xs:attribute name="object" type="expression" use="required">
      <xs:annotation>
        <xs:documentation>
          Object from which to obtain blacklist filter
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="group" type="blacklistgrouplookup" use="required">
      <xs:annotation>
        <xs:documentation>
          Default faction blacklist group (civilian, military) to use if object doesn't have a blacklist of its own of the specified type
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="createship">
    <xs:attribute name="macro" type="macroname" />
    <xs:attribute name="group" type="namestring">
      <xs:annotation>
        <xs:documentation>
          Ship group for random macro selection
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ref" type="expression">
      <xs:annotation>
        <xs:documentation>
          Reference to ShipDB entry (either a plain ID string or a script expression that evaluates to an ID string)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="capturable" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the ship capturable? (default is based on class)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sellable" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the ship sellable? (default is true)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="createnpc">
    <xs:attribute name="macro" type="macroname" />
    <xs:attribute name="group" type="namestring">
      <xs:annotation>
        <xs:documentation>
          Character group for random macro selection
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="actor" type="expression">
      <xs:annotation>
        <xs:documentation>
          Existing actor to be used instead of creating a new NPC (only useful with variable expressions in scripts)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ref" type="expression">
      <xs:annotation>
        <xs:documentation>
          Reference to CharacterDB entry (either a plain ID string or a script expression that evaluates to an ID string)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="createmodule">
    <xs:attribute name="macro" type="macroname" />
    <xs:attribute name="group" type="namestring">
      <xs:annotation>
        <xs:documentation>
          Module group for random macro selection
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ref" type="expression">
      <xs:annotation>
        <xs:documentation>
          Reference to ModuleDB entry (either a plain ID string or a script expression that evaluates to an ID string)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="base" type="expression">
      <xs:annotation>
        <xs:documentation>
          The base construction plan (Optional. Either a plain ID string or a script expression that evaluates to an ID string)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="moduletypelimits">
    <xs:attribute name="build" type="moduletypelimit"/>
    <xs:attribute name="comm" type="moduletypelimit"/>
    <xs:attribute name="defence" type="moduletypelimit"/>
    <xs:attribute name="dock" type="moduletypelimit"/>
    <xs:attribute name="habitation" type="moduletypelimit"/>
    <xs:attribute name="other" type="moduletypelimit"/>
    <xs:attribute name="pier" type="moduletypelimit"/>
    <xs:attribute name="production" type="moduletypelimit"/>
    <xs:attribute name="storage" type="moduletypelimit"/>
  </xs:attributeGroup>

  <xs:attributeGroup name="createroom">
    <xs:attribute name="macro" type="macroname" />
    <xs:attribute name="group" type="namestring">
      <xs:annotation>
        <xs:documentation>
          Room group for random macro selection
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ref" type="expression">
      <xs:annotation>
        <xs:documentation>
          Reference to RoomDB entry (either a plain ID string or a script expression that evaluates to an ID string)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="createprop">
    <xs:attribute name="macro" type="macroname" />
    <xs:attribute name="group" type="namestring">
      <xs:annotation>
        <xs:documentation>
          Prop group for random macro selection
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ref" type="expression">
      <xs:annotation>
        <xs:documentation>
          Reference to PropDB entry (either a plain ID string or a script expression that evaluates to an ID string)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="createstation">
    <xs:attribute name="constructionplan" type="constructionplan" />
    <xs:attribute name="group" type="namestring">
      <xs:annotation>
        <xs:documentation>
          Station group for random construction plan selection
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="macro" type="expression">
      <xs:annotation>
        <xs:documentation>
          A station macro (either a plain macro string or a script expression that evaluates to a string or macro) to place instead of a construction plan. This station macro MUST have a moduleset defined for it.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ref" type="expression">
      <xs:annotation>
        <xs:documentation>
          Reference to StationDB entry (either a plain ID string or a script expression that evaluates to an ID string)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="createobject">
    <xs:attribute name="macro" type="expression">
      <xs:annotation>
        <xs:documentation>
          An object macro (either a plain macro string or a script expression that evaluates to a string or macro).
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="random">
    <xs:attribute name="exact" type="expression">
      <xs:annotation>
        <xs:documentation>
          Exact value (takes priority over min/max/profile/scale)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="list" type="expression">
      <xs:annotation>
        <xs:documentation>
          List of values, from which one value will be selected randomly (takes priority over min/max/profile/scale, ignored if exact is set)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="min" type="expression">
      <xs:annotation>
        <xs:documentation>
          Minimum random number (ignored if exact is set)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="max" type="expression">
      <xs:annotation>
        <xs:documentation>
          Maximum random number (ignored if exact is set)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="profile" type="profilelookup">
      <xs:annotation>
        <xs:documentation>
          Random number profile (ignored if exact is set)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="scale">
      <xs:annotation>
        <xs:documentation>
          Scale of random number profile (ignored if exact is set or if profile is flat)
        </xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:integer">
          <xs:minInclusive value="2" />
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="seed" type="expression">
      <xs:annotation>
        <xs:documentation>
          Optional source for fixed random number seed (either a numerical value or an object with a seed provided by their spawnsource e.g. job or god engine)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="counting">
    <xs:attributeGroup ref="random" />
    <xs:attribute name="counter" type="lvalueexpression">
      <xs:annotation>
        <xs:documentation>
          Name of loop counter variable
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="reverse" type="boolean">
      <xs:annotation>
        <xs:documentation>
          If true then loop counter counts from the max value down to 1
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="foreach">
    <xs:attribute name="in" type="expression">
      <xs:annotation>
        <xs:documentation>
          List, group or table that should be traversed. It is stored internally during the traversal, so the expression is evaluated only once.
          In general, avoid insertion and removal of list/group elements during the traversal; however, it is supported according to these rules:
          - In lists and groups, insertion and removal is allowed at an index greater than the current one, but not allowed at a lower index.
          - In lists and groups, insertion and removal at the current index is only allowed if reverse=&quot;true&quot;.
          - In tables, keys may be inserted or removed at any time, even the current one (but note that newly inserted keys in the already traversed range will not be reached by the traversal).
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="counter" type="lvalueexpression">
      <xs:annotation>
        <xs:documentation>
          Name of loop counter variable, which will be set to the current index in the list or group. Cannot be used when traversing a table.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="lvalueexpression">
      <xs:annotation>
        <xs:documentation>
          Name of the element/key variable, which will be set to the current element in the list or group, or the current table key, respectively.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="valuename" type="lvalueexpression">
      <xs:annotation>
        <xs:documentation>
          Name of the table value variable, which will be set to the value of the current table key. Can only be used when traversing a table.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="reverse" type="boolean">
      <xs:annotation>
        <xs:documentation>
          Set to true to traverse the list, group or table in reverse order, starting with the last element or key, respectively. In list/group cases, the index counter counts from the highest index down to 1.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="range">
    <xs:attribute name="exact" type="expression">
      <xs:annotation>
        <xs:documentation>
          Exact match value (takes priority over list and min/max)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="list" type="expression">
      <xs:annotation>
        <xs:documentation>
          List of matching values (takes priority over min/max, ignored if exact is set)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="min" type="expression">
      <xs:annotation>
        <xs:documentation>
          Minimum matching number (ignored if exact is set)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="max" type="expression">
      <xs:annotation>
        <xs:documentation>
          Maximum matching number (ignored if exact is set)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="objecteventsource">
    <xs:attribute name="object" type="expression">
      <xs:annotation>
        <xs:documentation>
          Event object (required if group attribute not supplied)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="group" type="groupeventsource" />
    <xs:attribute name="check" type="checkeventsource" />
  </xs:attributeGroup>

  <xs:attributeGroup name="clustereventsource">
    <xs:attribute name="cluster" type="expression">
      <xs:annotation>
        <xs:documentation>
          Cluster, used as event object (required if group attribute not supplied)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="group" type="groupeventsource" />
    <xs:attribute name="check" type="checkeventsource" />
  </xs:attributeGroup>

  <xs:attributeGroup name="condition">
    <xs:attribute name="chance" type="expression">
      <xs:annotation>
        <xs:documentation>
          Percentage chance of condition being checked (condition fails if not)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="comment" type="comment" />
  </xs:attributeGroup>

  <xs:attributeGroup name="eventcondition">
    <xs:attributeGroup ref="condition" />
  </xs:attributeGroup>

  <xs:attributeGroup name="noneventcondition">
    <xs:attributeGroup ref="condition" />
    <xs:attribute name="negate" type="negatecondition" />
  </xs:attributeGroup>

  <xs:attributeGroup name="action">
    <xs:attribute name="chance" type="expression">
      <xs:annotation>
        <xs:documentation>
          Chance percentage of action being performed (action is skipped if not)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="weight" type="expression">
      <xs:annotation>
        <xs:documentation>
          Weight of action which determines its chance of being selected (only evaluated in &lt;do_any&gt; blocks)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="comment" type="comment" />
  </xs:attributeGroup>

  <xs:attributeGroup name="conditionalaction">
    <xs:attribute name="value" type="expression" use="required">
      <xs:annotation>
        <xs:documentation>
          Value to match (checked for non-zero if no comparison range or list is specified)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup ref="range" />
    <xs:attribute name="negate" type="negatecondition" />
  </xs:attributeGroup>

  <xs:attributeGroup name="positionbase">
    <xs:attribute name="x" type="expression">
      <xs:annotation>
        <xs:documentation>
          X coordinate
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="y" type="expression">
      <xs:annotation>
        <xs:documentation>
          Y coordinate
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="z" type="expression">
      <xs:annotation>
        <xs:documentation>
          Z coordinate
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="position">
    <xs:attributeGroup ref="positionbase" />
    <xs:attribute name="value" type="expression">
      <xs:annotation>
        <xs:documentation>
          Position value, used in preference to coordinates if supplied
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="object" type="expression">
      <xs:annotation>
        <xs:documentation>
          An object (or any positional). Requires a space context to which its relative position is calculated. If also coordinates or a position value are supplied, they are interpreted as relative to the object.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="space" type="expression">
      <xs:annotation>
        <xs:documentation>
          Reference space to be used if the object attribute is supplied. Defaults to the space supplied by the parent XML node, if applicable, otherwise to the object's parent space.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup ref="random">
      <xs:annotation>
        <xs:documentation>
          Distance from specified position
        </xs:documentation>
      </xs:annotation>
    </xs:attributeGroup>
  </xs:attributeGroup>

  <xs:attributeGroup name="vector">
    <xs:attributeGroup ref="positionbase" />
    <xs:attribute name="value" type="expression">
      <xs:annotation>
        <xs:documentation>
          Vector value, used in preference to coordinates if supplied
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="rotation">
    <xs:attribute name="yaw" type="expression">
      <xs:annotation>
        <xs:documentation>
          Yaw rotation
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="pitch" type="expression">
      <xs:annotation>
        <xs:documentation>
          Pitch rotation
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="roll" type="expression">
      <xs:annotation>
        <xs:documentation>
          Roll rotation
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="expression">
      <xs:annotation>
        <xs:documentation>
          Rotation value, used in preference to angles if supplied
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="boundingbox">
    <xs:attribute name="max" type="expression" use="required" />
    <xs:attribute name="center" type="expression" use="required" />
  </xs:attributeGroup>

  <xs:attributeGroup name="safepos">
    <xs:attribute name="allowyaxis" type="boolean" >
      <xs:annotation>
        <xs:documentation>
          Allow the generated position to also use the up/down axis, defaults to true
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="radius" type="expression">
      <xs:annotation>
        <xs:documentation>
          Radius to indicate necessary space required for a safe position (optional, typically defaults to the radius of the bounding box if an object or macro is supplied)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="angle" type="expression">
      <xs:annotation>
        <xs:documentation>
          Angle tolerance from the specified direction
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="direction" type="quadrantlookup">
      <xs:annotation>
        <xs:documentation>
          Direction for safepos checks. Based on the orientation of the 'directionobject' if provided. Can be combined with 'direction2'
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="direction2" type="quadrantlookup">
      <xs:annotation>
        <xs:documentation>
          Direction for safepos checks. Based on the orientation of the 'directionobject' if provided. Can be combined with 'direction' but ignored if opposing
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="directionobject" type="expression">
      <xs:annotation>
        <xs:documentation>
          Direction object for safepos checks. If direction is not specified, the direction is considered to be from the base position to this object
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup ref="position" />
    <xs:attribute name="ignored" type="object" />
    <xs:attribute name="includefiringrange" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Avoid the firing range of turrets
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="includeplotbox" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Avoid the plot box of stations
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="createobjectsafepos">
    <xs:attribute name="allowyaxis" type="boolean" >
      <xs:annotation>
        <xs:documentation>
          Allow the generated position to also use the up/down axis, defaults to true
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="radius" type="expression">
      <xs:annotation>
        <xs:documentation>
          Radius to indicate necessary space required for a safe position (defaults to created object radius if null)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup ref="position" />
    <xs:attribute name="ignored" type="object" />
    <xs:attribute name="includefiringrange" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Avoid the firing range of turrets
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="includeplotbox" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Avoid the plot box of stations
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="orientation">
    <xs:attribute name="orientation" type="orientationlookup" use="required" />
    <xs:attribute name="refobject" type="expression" >
      <xs:annotation>
        <xs:documentation>
          Position of this object will be used as refposition, for boundingbox orientations the box of this object will be used.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="refposition" type="expression" >
      <xs:annotation>
        <xs:documentation>
          Position the orientation refers to (e.g. look_at means look from position to refposition), ignored if refobject is set
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="rgbcolour">
    <xs:attribute name="r" type="colour">
      <xs:annotation>
        <xs:documentation>
          Red.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="g" type="colour">
      <xs:annotation>
        <xs:documentation>
          Green.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="b" type="colour">
      <xs:annotation>
        <xs:documentation>
          Blue.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="playerchoice">
    <xs:attribute name="text" type="expression" use="required">
      <xs:annotation>
        <xs:documentation>
          Choice text
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="position" type="uipositionlookup" />
    <xs:attribute name="highlighted" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Optional, set to true to highlight the option and to indicate that it is mission-related (defaults to false)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="selectable" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Optional, determines whether the option is selectable. Defaults to true if not supplied.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tooltip" type="expression">
      <xs:annotation>
        <xs:documentation>
          Optional, specifies the tooltip displayed for this option.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="interaction">
    <xs:annotation>
      <xs:documentation>
        Interactive notification data
      </xs:documentation>
    </xs:annotation>
    <xs:attribute name="text" type="expression" use="required">
      <xs:annotation>
        <xs:documentation>
          Text displayed during interactive notification to prompt player to interact
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="param" type="expression">
      <xs:annotation>
        <xs:documentation>
          Interactive notification parameter passed to &lt;event_player_interaction&gt;
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="param2" type="expression">
      <xs:annotation>
        <xs:documentation>
          Secondary interactive notification parameter passed to &lt;event_player_interaction&gt;
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="silent" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Should the flashing effect of the target monitor be suppressed?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="conversationactor">
    <xs:attribute name="actor" type="expression">
      <xs:annotation>
        <xs:documentation>
          Conversation actor entity (use attribute context and template instead to provide an NPC template instead of an entity as conversation actor)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="context" type="expression">
      <xs:annotation>
        <xs:documentation>
          Controllable object context of the provided NPC template (when using template attribute instead of the actor attribute)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="template" type="expression">
      <xs:annotation>
        <xs:documentation>
          Conversation actor NPC template (can be used instead of actor attribute to provide an NPC template, requires context attribute)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="showhelp">
    <xs:attribute name="position" type="expression">
      <xs:annotation>
        <xs:documentation>
          Position of help text (defined in parameters.xml) - defaults to 0
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="duration" type="expression">
      <xs:annotation>
        <xs:documentation>
          Duration of help text display. If not provided, a suitable duration will be calculated.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="log" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Add help text to logbook? Default is false
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="allowpause" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Pause keeps the help text open (default is true)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="width" type="expression">
      <xs:annotation>
        <xs:documentation>
          Factor to modify help text width in percent (default is 200, minimum is 50)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="allowclose" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Whether the player is allowed to close the hint, use with care (default is false)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Whether the hint will timeout after duration (default is true); use with care, if allowclose is false (its default)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="color" type="expression">
      <xs:annotation>
        <xs:documentation>
          Defines the text color in the format [r, g, b, a] - default is white
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="halign" type="expression">
      <xs:annotation>
        <xs:documentation>
          Horizontal alignment of the hint text (default is 'left')
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="allowinmenu" type="expression">
      <xs:annotation>
        <xs:documentation>
          Whitelist this help text in menus which normally forbid them (e.g. the options menu) - format 'MenuA MenuB MenuC'
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="dropcargo">
    <xs:attribute name="groupname" type="lvalueexpression">
      <xs:annotation>
        <xs:documentation>
          Name of the group to which all spawned ware containers will be added (optional, group will be created if it does not exist yet)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="wares" type="lvalueexpression">
      <xs:annotation>
        <xs:documentation>
          Name of the value that will receive a list of all spawned ware types (optional)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="amounts" type="lvalueexpression">
      <xs:annotation>
        <xs:documentation>
          Name of the value that will receive a list of ware amounts, corresponding to the wares result list.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="unbundle" type="booleanexpression" use="optional">
      <xs:annotation>
        <xs:documentation>
          Should the ware be unbundled (turn ware into ammo/units) on transfer? (optional, defaults to false)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="bundle" type="booleanexpression" use="optional">
      <xs:annotation>
        <xs:documentation>
          Do the wares to be dropped come from ammo/unit storage? (optional, defaults to false)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="resetobjectboost">
    <xs:attribute name="object" type="object" use="required" />
    <xs:attribute name="otherobject" type="expression">
      <xs:annotation>
        <xs:documentation>
          Object the boost is towards, using the object's apparent owner (takes preference over 'faction')
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="faction" type="factionexprlookup">
      <xs:annotation>
        <xs:documentation>
          Faction the boost is towards ('otherobject' takes preference if provided)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="objectboost">
    <xs:attributeGroup ref="resetobjectboost" />
    <xs:attribute name="decay" type="expression">
      <xs:annotation>
        <xs:documentation>
          Decay rate
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="delay" type="expression">
      <xs:annotation>
        <xs:documentation>
          Decay delay
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="objectrelationboost">
    <xs:attributeGroup ref="objectboost" />
    <xs:attribute name="silent" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the relation boost silent, i.e. without player notification? See &lt;event_player_relation_changed&gt;
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="existingpeoplelist">
    <xs:attribute name="people" type="expression">
      <xs:annotation>
        <xs:documentation>
          List of NPC templates (size must match with other lists)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="newroles" type="expression">
      <xs:annotation>
        <xs:documentation>
          List of roles to reassign people (size must match with other lists)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="matchingpeoplelist">
    <xs:attribute name="amounts" type="expression">
      <xs:annotation>
        <xs:documentation>
          List of amounts (size must match with other lists)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="currentroles" type="expression">
      <xs:annotation>
        <xs:documentation>
          List of roles currently assigned to help identify people (size must match with other lists)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="newroles" type="expression">
      <xs:annotation>
        <xs:documentation>
          List of roles to reassign people (size must match with other lists)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="races" type="expression">
      <xs:annotation>
        <xs:documentation>
          List of races to help identify people (size must match with other lists)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="skills" type="expression">
      <xs:annotation>
        <xs:documentation>
          List of skills to help identify people (size must match with other lists)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="exact" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Are the skills exact or used to find a suitable tier (defaults to false)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="setentityflags">
    <xs:attribute name="customhandler" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is there a custom comm handler for player-initiated comm.?
          If so, this suppresses the generic &lt;event_conversation_started&gt; handler to avoid interference.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="intransit" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Set whether currently in transit or not? In transit actors do not activly control objects.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="busy" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Set whether currently busy or not? Busy actors do not activly control objects.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="missionactor" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Set whether the actor is a mission actor or not.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="remote" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Set whether the actor is remote commable or not.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="temporary" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Set whether the actor is temporary or not.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="hidden" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Is the actor hidden in their room
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tradesvisible" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Set trades to visible or invisible. Trades are hidden unless explicitly made visible. (e.g. Shady Guy)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="subtitlename" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Set whether the actor name should be included in subtitles when this entity speaks
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="buildexcludewares">
    <xs:attribute name="wares" type="ware">
      <xs:annotation>
        <xs:documentation>
          (optional) single ware or list of wares to set, add or remove, omitting this will clear the list if append and remove are false
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="append" type="boolean">
      <xs:annotation>
        <xs:documentation>
          Should the specified ware(s) be added to the existing exclusion list? (defaults to false which will replace or remove existing entries)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="remove" type="boolean">
      <xs:annotation>
        <xs:documentation>
          Should the specified ware(s) be removed from the existing exclusion list? (defaults to false which will add or replace existing entries)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="buildincludewares">
    <xs:attribute name="wares" type="ware">
      <xs:annotation>
        <xs:documentation>
          (optional) single ware or list of wares to set, add or remove, omitting this will clear the list if append and remove are false (default)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="append" type="boolean">
      <xs:annotation>
        <xs:documentation>
          Should the specified ware(s) be added to the existing inclusion list? (defaults to false which will replace or remove existing entries)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="remove" type="boolean">
      <xs:annotation>
        <xs:documentation>
          Should the specified ware(s) be removed from the existing inclusion list? (defaults to false which will add or replace existing entries)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="cutscenekeyorid">
    <xs:attribute name="key" type="expression">
      <xs:annotation>
        <xs:documentation>
          Cutscene key name (ignored if cutscene attribute is supplied)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cutscene" type="expression">
      <xs:annotation>
        <xs:documentation>
          Cutscene identifier as returned by &lt;play_cutscene&gt; (takes precedence over key attribute)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="terraformingstat">
    <xs:attribute name="cluster" type="cluster" use="required" />
    <xs:attribute name="id" type="expression" use="required">
      <xs:annotation>
        <xs:documentation>
          Stat ID (see terraforming.xml for valid values) or "population"
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <!-- ===== Complex types ==== -->

  <xs:complexType name="filedoc">
    <xs:sequence>
      <xs:element name="author" minOccurs="0" maxOccurs="1">
        <xs:annotation>
          <xs:documentation>
            Author details
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="name" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                Author name
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="alias" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                Author alias
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="contact" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                Author contact details
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="content" minOccurs="0" maxOccurs="1">
        <xs:complexType>
          <xs:attribute name="reference" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                File reference
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="name" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                File name
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="description" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                File description
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="version" minOccurs="0" maxOccurs="1">
        <xs:complexType>
          <xs:attribute name="number" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                Internal version number
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="date" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                Date of current version
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="status" type="versionstatus">
            <xs:annotation>
              <xs:documentation>
                Status of current version
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <!-- Usage note: Use together with one of the attributeGroups "findarbitrary", "findobject", "findstation", or "findship". -->
  <!-- If the class of result components is already determined and is neither ship nor station, you can just use attributeGroup "find". -->
  <xs:complexType name="matchbase">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element name="match" type="matchsubfilter">
        <xs:annotation>
          <xs:documentation>
            Match filter
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="match_any" type="matchsubfilter">
        <xs:annotation>
          <xs:documentation>
            Match any of the specified filters (attributes and sub-elements)
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="match_parent" type="matchsubfilter">
        <xs:annotation>
          <xs:documentation>
            Match filter for the parent of the object
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="match_context" type="matchsubfilter">
        <xs:annotation>
          <xs:documentation>
            Match filter for the context of the object
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="match_child" type="matchsubfilterrange">
        <xs:annotation>
          <xs:documentation>
            Match filter for the children of the objects
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="match_content" type="matchsubfilterrange">
        <xs:annotation>
          <xs:documentation>
            Match filter for the contained objects of the objects
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="match_macro_children" type="matchrange">
        <xs:annotation>
          <xs:documentation>
            Match filter for amount of children defined in the macro of the objects
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="match_hull" type="matchrange">
        <xs:annotation>
          <xs:documentation>
            Match hull percentage
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="match_max_hull" type="matchrange">
        <xs:annotation>
          <xs:documentation>
            Match max hull percentage
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="match_shield" type="matchrange">
        <xs:annotation>
          <xs:documentation>
            Match shield percentage
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="match_secrecy_level" type="matchrange">
        <xs:annotation>
          <xs:documentation>
            Match object secrecy level
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="match_attention">
        <xs:annotation>
          <xs:documentation>
            Match attention level
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="min" type="attentionexprlookup">
            <xs:annotation>
              <xs:documentation>
                Min attention level (not compared if not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="max" type="attentionexprlookup">
            <xs:annotation>
              <xs:documentation>
                Max attention level (not compared if not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="exact" type="attentionexprlookup">
            <xs:annotation>
              <xs:documentation>
                Exact attention level (not compared if not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="negate" type="negatefilter" />
          <xs:attribute name="comment" type="comment" />
        </xs:complexType>
      </xs:element>
      <xs:element name="match_revealed_percentage" type="matchrevealedpercentage">
        <xs:annotation>
          <xs:documentation>
            Match by reveal percentage filter
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="match_pilot">
        <xs:annotation>
          <xs:documentation>
            Match filter for the ship's pilot
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="findentity" />
              <xs:attribute name="negate" type="negatefilter" />
              <xs:attribute name="comment" type="comment" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="match_distance">
        <xs:annotation>
          <xs:documentation>
            Match by distance filter. Distance can be checked either to an object or to a position. The reference space, if supplied, must contain the searched objects. min and/or max must be set.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="x" type="expression">
            <xs:annotation>
              <xs:documentation>
                X coordinate
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="y" type="expression">
            <xs:annotation>
              <xs:documentation>
                Y coordinate
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="z" type="expression">
            <xs:annotation>
              <xs:documentation>
                Z coordinate
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="value" type="expression">
            <xs:annotation>
              <xs:documentation>
                Position value, used in preference to coordinates if supplied
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="object" type="expression">
            <xs:annotation>
              <xs:documentation>
                Object, used in preference to coordinates if supplied. If no space context is supplied, the object's sector is used, so the searched objects are required to be in the same sector.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="space" type="expression">
            <xs:annotation>
              <xs:documentation>
                Reference space which has to contain both the reference (object or position) and the searched objects.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="min" type="expression">
            <xs:annotation>
              <xs:documentation>
                Minimal distance (min distance is not compared if not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="max" type="expression">
            <xs:annotation>
              <xs:documentation>
                Maximal distance (max distance is not compared if not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="negate" type="negatefilter" />
          <xs:attribute name="comment" type="comment" />
        </xs:complexType>
      </xs:element>
      <xs:element name="match_gate_distance">
        <xs:annotation>
          <xs:documentation>
            Match by distance by jumpgates. Calculation based on the sectors of the objects. Checking distance of clusters will check between two random sectors within them.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="blacklist" minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
                  Use specified sector travel blacklist when calculating distance
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attributeGroup ref="blacklist" />
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attribute name="min" type="expression">
            <xs:annotation>
              <xs:documentation>
                Min distance by jumpgates (not compared if not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="max" type="expression">
            <xs:annotation>
              <xs:documentation>
                Max distance by jumpgates (not compared if not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Origin object for the distance calculation. Passing cluster will base the check on a random sector.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="negate" type="negatefilter" />
          <xs:attribute name="comment" type="comment" />
        </xs:complexType>
      </xs:element>
      <xs:element name="match_use_blacklist">
        <xs:annotation>
          <xs:documentation>
            Match only items that are not in the specified blacklist.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="blacklist" />
          <xs:attribute name="type" type="blacklisttypelookup" use="required">
            <xs:annotation>
              <xs:documentation>
                Blacklist type (e.g. sectoractivity) to use
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="match_size">
        <xs:annotation>
          <xs:documentation>
            Match by size filter. Size is based on diameter of the bounding box. min and/or max must be set.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="min" type="expression">
            <xs:annotation>
              <xs:documentation>
                Minimal size of the bounding box (min size is not compared if not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="max" type="expression">
            <xs:annotation>
              <xs:documentation>
                Maximal size (max size is not compared if not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="negate" type="negatefilter" />
          <xs:attribute name="comment" type="comment" />
        </xs:complexType>
      </xs:element>
      <xs:element name="match_is_in_view_of">
        <xs:annotation>
          <xs:documentation>
            Match by view angle filter. Can be checked either to an object or to a position AND rotation. The reference space, if supplied, must contain the searched objects.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="x" type="expression">
            <xs:annotation>
              <xs:documentation>
                X coordinate
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="y" type="expression">
            <xs:annotation>
              <xs:documentation>
                Y coordinate
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="z" type="expression">
            <xs:annotation>
              <xs:documentation>
                Z coordinate
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="pitch" type="expression">
            <xs:annotation>
              <xs:documentation>
                Pitch (rotation around x axis)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="yaw" type="expression">
            <xs:annotation>
              <xs:documentation>
                Yaw (rotation around y axis)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="roll" type="expression">
            <xs:annotation>
              <xs:documentation>
                Roll (rotation around Z axis)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="object" type="expression">
            <xs:annotation>
              <xs:documentation>
                Object, used in preference to coordinates if supplied. If no space context is supplied, the object's sector is used, so the searched objects are required to be in the same sector.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="space" type="expression">
            <xs:annotation>
              <xs:documentation>
                Reference space which has to contain both the reference (object or position/rotation) and the searched objects.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="vertical" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The vertical viewing angle (full range from top to bottom)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="horizontal" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The horizontal viewing angle (full range from left to right)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="negate" type="negatefilter" />
          <xs:attribute name="comment" type="comment" />
        </xs:complexType>
      </xs:element>
      <xs:element name="match_buyoffer" type="matchtradeoffer">
        <xs:annotation>
          <xs:documentation>
            Match filter for available buy offers
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="match_selloffer" type="matchtradeoffer">
        <xs:annotation>
          <xs:documentation>
            Match filter for available sell offers
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="match_build" type="matchbuild">
        <xs:annotation>
          <xs:documentation>
            Match filter for build tasks
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="match_products" type="matchwarelist">
        <xs:annotation>
          <xs:documentation>
            Match filter for products of a Container or Production Module. The match is valid if the object produces any of the supplied wares, even if there are no current sell offers.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="match_resources" type="matchwarelist">
        <xs:annotation>
          <xs:documentation>
            Match filter for resources of a Container or Production Module. The match is valid if the object consumes any of the supplied wares, even if there are no current buy offers.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="match_any_cargo" type="matchwarelist">
        <xs:annotation>
          <xs:documentation>
            Match filter for the cargo wares of a container class object (e.g. Ships, Stations)
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="match_any_wares" type="matchwarelist">
        <xs:annotation>
          <xs:documentation>
            Match filter for the non-cargo wares of an object (e.g. Collectable Ware Drops, Asteroids)
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="match_basket_wares" type="matchwarelist">
        <xs:annotation>
          <xs:documentation>
            Match filter for the basket wares of a job ship
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="match_relation_of">
        <xs:annotation>
          <xs:documentation>
            Match by relation filter. Relation of 'faction' or 'object' is checked against filtered object.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="object" type="expression">
            <xs:annotation>
              <xs:documentation>
                Object to reference (takes preference over 'faction')
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="faction" type="factionexprlookup">
            <xs:annotation>
              <xs:documentation>
                Faction to reference ('object' takes preference if provided)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="relation" type="relationlookup" use="required">
            <xs:annotation>
              <xs:documentation>
                Relation range
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="comparison" type="relationcomparison" />
          <xs:attribute name="negate" type="negatefilter" />
          <xs:attribute name="comment" type="comment" />
        </xs:complexType>
      </xs:element>
      <xs:element name="match_relation_to">
        <xs:annotation>
          <xs:documentation>
            Match by relation filter. Relation of filtered object is checked against 'faction' or 'object'.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="object" type="expression">
            <xs:annotation>
              <xs:documentation>
                Object to reference (takes preference over 'faction')
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="faction" type="factionexprlookup">
            <xs:annotation>
              <xs:documentation>
                Faction to reference ('object' takes preference if provided)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="relation" type="relationlookup" use="required">
            <xs:annotation>
              <xs:documentation>
                Relation range
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="comparison" type="relationcomparison" />
          <xs:attribute name="negate" type="negatefilter" />
          <xs:attribute name="comment" type="comment" />
        </xs:complexType>
      </xs:element>
      <xs:element name="match_requires_licence">
        <xs:annotation>
          <xs:documentation>
            Match filter for whether a licence is required to access to an object or area of space.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="requireslicence">
            <xs:annotation>
              <xs:documentation>
                Type of licence (can be faction to match any licence for that faction, licence type to match licence type for any faction, or licence for exact match)
              </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:union memberTypes="expression licencelookup" />
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="negate" type="negatefilter" />
          <xs:attribute name="comment" type="comment" />
        </xs:complexType>
      </xs:element>
      <xs:element name="match_dock">
        <xs:annotation>
          <xs:documentation>
            Match filter for a dock
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="free" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Is dock free?
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="size" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Dock compatibility size
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="storage" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Is the docking bay an internal storage bay? (defaults to false, i.e. internal storage bays are ignored by default)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="building" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Is it required that the dock allows building?
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="trading" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Is it required that the dock allows trading?
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="allowplayeronly" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Allow finding a dock that is exclusive for player-controlled ship? (defaults to false, i.e. player-exclusive docks are ignored by default)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="ventureronly" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Is dock exclusive for venturers? Can be used in combination with ventureplatform attribute. (Defaults to false, i.e. venturer-exclusive docks are ignored by default)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="ventureplatform" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Specific venture platform with which venture dock must be associated (optional, can be null). Only takes effect if ventureronly is set to true.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="hasventureship" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Has an assigned venture ship?
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="negate" type="negatefilter" />
          <xs:attribute name="comment" type="comment" />
        </xs:complexType>
      </xs:element>
      <xs:element name="match_units_stored" type="matchunits">
        <xs:annotation>
          <xs:documentation>
            Match filter for stored units on a Defensible object (including both available and unavailable)
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="match_units_available" type="matchunits">
        <xs:annotation>
          <xs:documentation>
            Match filter for available units on a Defensible object
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="match_units_unavailable" type="matchunits">
        <xs:annotation>
          <xs:documentation>
            Match filter for unavailable units on a Defensible object
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="match_cargo" type="matchwaresorcargo">
        <xs:annotation>
          <xs:documentation>
            Match filter for the cargo of a storage module or container class objects (e.g. Ships, Stations)
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="match_wares" type="matchwaresorcargo">
        <xs:annotation>
          <xs:documentation>
            Match filter for the non-cargo wares of an object (e.g. Collectable Ware Drops, Asteroids)
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="match_loadout" type="matchloadout">
        <xs:annotation>
          <xs:documentation>
            Match filter for loadout installed on defensible class objects (e.g. Ships, Stations)
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="match_weapon_mod" type="matchweaponmod">
        <xs:annotation>
          <xs:documentation>
            Match filter for weapon mods installed on defensible class objects (e.g. Ships, Stations)
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="match_engine_mod" type="matchenginemod">
        <xs:annotation>
          <xs:documentation>
            Match filter for engine mods installed on objects (e.g. Ships, Stations)
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="match_shield_mod" type="matchshieldmod">
        <xs:annotation>
          <xs:documentation>
            Match filter for shield mods installed on defensible class objects (e.g. Ships, Stations)
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="match_ship_mod" type="matchshipmod">
        <xs:annotation>
          <xs:documentation>
            Match filter for ship mods installed on ships
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="match_paint_mod" type="matchpaintmod">
        <xs:annotation>
          <xs:documentation>
            Match filter for paint mods installed on ships
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="match_any_equipment_mod">
        <xs:annotation>
          <xs:documentation>
            Match filter for any equipmentmod installed on defensible class objects
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
  </xs:complexType>

  <xs:complexType name="matchsubfilter">
    <xs:complexContent>
      <xs:extension base="matchbase">
        <xs:attributeGroup ref="findarbitrary" />
        <xs:attribute name="negate" type="negatefilter" />
        <xs:attribute name="comment" type="comment" />
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="matchsubfilterrange">
    <xs:complexContent>
      <xs:extension base="matchbase">
        <xs:attributeGroup ref="findarbitrary"/>
        <xs:attributeGroup ref="range" />
        <xs:attribute name="negate" type="negatefilter" />
        <xs:attribute name="comment" type="comment" />
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="matchtradeoffer">
    <xs:complexContent>
      <xs:extension base="matchtrade">
        <xs:attribute name="negate" type="negatefilter" />
        <xs:attribute name="comment" type="comment" />
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- Trade filter -->
  <xs:complexType name="matchbuyer">
    <xs:annotation>
      <xs:documentation>
        Match filter for the buyer of the trade
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="matchbase">
        <xs:attributeGroup ref="findarbitrary" />
        <xs:attribute name="comment" type="comment" />
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- Trade filter -->
  <xs:complexType name="matchseller">
    <xs:annotation>
      <xs:documentation>
        Match filter for the seller of the trade
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="matchbase">
        <xs:attributeGroup ref="findarbitrary" />
        <xs:attribute name="comment" type="comment" />
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="matchwarelist">
    <xs:attribute name="wares" type="expression" use="required">
      <xs:annotation>
        <xs:documentation>
          List of wares
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="negate" type="negatefilter" />
    <xs:attribute name="comment" type="comment" />
  </xs:complexType>

  <xs:complexType name="matchwaresorcargo">
    <xs:sequence minOccurs="0" maxOccurs="unbounded">
      <xs:element name="ware">
        <xs:complexType>
          <xs:attribute name="ware" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Ware or list of wares
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="exact" type="expression">
            <xs:annotation>
              <xs:documentation>
                Exact number (takes priority over min/max)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="min" type="expression">
            <xs:annotation>
              <xs:documentation>
                Minimum number (ignored if exact is set)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="max" type="expression">
            <xs:annotation>
              <xs:documentation>
                Maximum number (ignored if exact is set)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="negate" type="negatefilter" />
          <xs:attribute name="comment" type="comment" />
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="matchrange">
    <xs:attributeGroup ref="range" />
    <xs:attribute name="negate" type="negatefilter" />
    <xs:attribute name="comment" type="comment" />
  </xs:complexType>

  <xs:complexType name="matchrevealedpercentage">
    <xs:attribute name="secrecylevel" type="expression">
      <xs:annotation>
        <xs:documentation>
          Secrecy level (omit for all)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup ref="range" />
    <xs:attribute name="negate" type="negatefilter" />
    <xs:attribute name="comment" type="comment" />
  </xs:complexType>

  <xs:complexType name="matchunits">
    <xs:attribute name="category" type="unitcategorylookup" use="required">
      <xs:annotation>
        <xs:documentation>
          Unit Category to match
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup ref="range" />
    <xs:attribute name="negate" type="negatefilter" />
    <xs:attribute name="comment" type="comment" />
  </xs:complexType>

  <xs:complexType name="matchtradeoffervalues">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element name="amount" type="range">
        <xs:annotation>
          <xs:documentation>
            Range for the total amount of the trade offer wares
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="minamount" type="range">
        <xs:annotation>
          <xs:documentation>
            Range for the min amount of the trade offer wares
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="totalprice" type="range">
        <xs:annotation>
          <xs:documentation>
            Range for the total price of the trade offer
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="minprice" type="range">
        <xs:annotation>
          <xs:documentation>
            Range for the min price of the trade offer
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
  </xs:complexType>

  <xs:complexType name="matchtrade">
    <xs:all>
      <xs:element name="amount" type="rangefilter" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Filter by the amount in the trade, not including reservations
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="offeramount" minOccurs="0">
        <xs:complexType>
          <xs:annotation>
            <xs:documentation>
              Filter by the amount in the trade in addition to the amount reserved
            </xs:documentation>
          </xs:annotation>
          <xs:complexContent>
            <xs:extension base="rangefilter">
              <xs:attribute name="tradepartner" type="container">
                <xs:annotation>
                  <xs:documentation>
                    (optional) tradepartner that will do the trading. If specified this MUST be the object that does ware reservations.
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="price" type="rangefilter" minOccurs="0" />
      <xs:element name="relativeprice" type="rangefilter" minOccurs="0" />
      <xs:element name="stocklevel" type="rangefilter" minOccurs="0" />
      <xs:element name="totalprice" type="rangefilter" minOccurs="0" />
      <xs:element name="volume" type="rangefilter" minOccurs="0" />
      <xs:element name="totalvolume" type="rangefilter" minOccurs="0" />
      <xs:element name="mintotalvolume" type="rangefilter" minOccurs="0" />
      <xs:element name="match_buyer" type="matchbuyer" minOccurs="0" />
      <xs:element name="match_seller" type="matchseller" minOccurs="0" />
    </xs:all>
    <xs:attribute name="wares" type="ware">
      <xs:annotation>
        <xs:documentation>
          (optional) single ware or list of wares to filter offers for
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="unbundle" type="booleanexpression" use="optional">
      <xs:annotation>
        <xs:documentation>
          Should the ware be unbundled (turn ware into ammo/units) on transfer?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="bundle" type="booleanexpression" use="optional">
      <xs:annotation>
        <xs:documentation>
          Should the ware be bundled (convert ammo/unit -> ware) on transfer?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="matchbuild">
    <xs:all>
      <xs:element name="price" type="rangefilter" minOccurs="0" />
    </xs:all>
    <xs:attribute name="macro" type="macro" />
    <xs:attribute name="faction" type="faction" />
  </xs:complexType>

  <xs:complexType name="matchloadout">
    <xs:attribute name="wares" type="expression" use="optional">
      <xs:annotation>
        <xs:documentation>
          A list of wares or table of ware amounts that the loadout should contain. List may contain repeats if more than one of an item is required.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="macros" type="expression" use="optional">
      <xs:annotation>
        <xs:documentation>
          A list of macros or table of macro amount that the loadout should contain. List may contain repeats if more than one of an item is required.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="matchweaponmod">
    <xs:attribute name="context" type="expression">
      <xs:annotation>
        <xs:documentation>
          Weapon group context on which weapon mod should be installed (grouped weapon mods only, macro path as string)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="group" type="expression">
      <xs:annotation>
        <xs:documentation>
          Weapon group on which weapon mod should be installed (grouped weapon mods only)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="macro" type="expression">
      <xs:annotation>
        <xs:documentation>
          Weapon macro of weapon on which weapon mod should be installed (individual weapon mods only, any if not specified)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ware" type="expression">
      <xs:annotation>
        <xs:documentation>
          Weapon mod ware (from equipmentmods.xml, defines a quality level and primary property of weapon mod, any if not specified)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="matchenginemod">
    <xs:attribute name="ware" type="expression">
      <xs:annotation>
        <xs:documentation>
          Engine mod ware (from equipmentmods.xml, defines a quality level and primary property of engine mod, any if not specified)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="matchshieldmod">
    <xs:attribute name="context" type="expression">
      <xs:annotation>
        <xs:documentation>
          Shield group context on which shield mod should be installed (macro path as string, object's primary shield group if not specified)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="group" type="expression">
      <xs:annotation>
        <xs:documentation>
          Shield group on which shield mod should be installed (object's primary shield group if not specified)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ware" type="expression">
      <xs:annotation>
        <xs:documentation>
          Shield mod ware (from equipmentmods.xml, defines a quality level and primary property of shield mod, any if not specified)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="matchshipmod">
    <xs:attribute name="ware" type="expression">
      <xs:annotation>
        <xs:documentation>
          Ship mod ware (from equipmentmods.xml, defines a quality level and primary property of ship mod, any if not specified)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="matchpaintmod">
    <xs:attribute name="ware" type="expression">
      <xs:annotation>
        <xs:documentation>
          Paint mod ware (from equipmentmods.xml, defines a quality level and primary property of paint mod, any if not specified)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="range">
    <xs:attributeGroup ref="range" />
    <xs:attribute name="comment" type="comment" />
  </xs:complexType>

  <xs:complexType name="selectrandom">
    <xs:group ref="selectrandom" />
    <xs:attributeGroup ref="random" />
    <xs:attribute name="selection" type="selectionlookup" />
    <xs:attribute name="comment" type="comment" />
  </xs:complexType>

  <xs:complexType name="position">
    <xs:annotation>
      <xs:documentation>
        Position relative to a given space or object
      </xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="position" />
    <xs:attribute name="comment" type="comment" />
  </xs:complexType>

  <xs:complexType name="rotation">
    <xs:annotation>
      <xs:documentation>
        Rotation in space
      </xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="rotation" />
    <xs:attribute name="comment" type="comment" />
  </xs:complexType>

  <xs:complexType name="boundingbox">
    <xs:annotation>
      <xs:documentation>
        Bounding box relative to a given space or object
      </xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="boundingbox" />
    <xs:attribute name="comment" type="comment" />
  </xs:complexType>

  <xs:complexType name="safepos">
    <xs:annotation>
      <xs:documentation>
        Safe position relative to a given space or object
      </xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="safepos" />
    <xs:attribute name="comment" type="comment" />
  </xs:complexType>

  <xs:complexType name="createobjectsafepos">
    <xs:annotation>
      <xs:documentation>
        Create the object using a safe position
      </xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="createobjectsafepos" />
    <xs:attribute name="comment" type="comment" />
  </xs:complexType>

  <xs:complexType name="orientation">
    <xs:annotation>
      <xs:documentation>
        Orientation in space
      </xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="orientation" />
    <xs:attribute name="comment" type="comment" />
  </xs:complexType>

  <xs:complexType name="componentoffset">
    <xs:annotation>
      <xs:documentation>
        Component Offset
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="position" type="position" minOccurs="0" maxOccurs="1"/>
    </xs:sequence>
    <xs:attribute name="object" type="object" use="required" />
    <xs:attribute name="comment" type="comment" />
  </xs:complexType>

  <xs:complexType name="rangefilter">
    <xs:attribute name="comment" type="comment" />
    <xs:attribute name="exact" type="expression">
      <xs:annotation>
        <xs:documentation>
          Exact number (takes priority over min/max)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="min" type="expression">
      <xs:annotation>
        <xs:documentation>
          Minimum number (ignored if exact is set)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="max" type="expression">
      <xs:annotation>
        <xs:documentation>
          Maximum number (ignored if exact is set)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="shipdbcategory">
    <xs:attribute name="faction" type="rawfactionexprlookup">
      <xs:annotation>
        <xs:documentation>
          Faction or list of factions
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tags" type="expression">
      <xs:annotation>
        <xs:documentation>
          Specification tag or list of tags
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="size">
      <xs:annotation>
        <xs:documentation>
          Ship size
        </xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="ship_xs" />
          <xs:enumeration value="ship_s" />
          <xs:enumeration value="ship_m" />
          <xs:enumeration value="ship_l" />
          <xs:enumeration value="ship_xl" />
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="comment" type="comment" />
  </xs:complexType>

  <xs:complexType name="shipdbcategoryselect">
    <xs:attribute name="faction" type="factionexprlookup">
      <xs:annotation>
        <xs:documentation>
          Faction or list of factions
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tags" type="expression">
      <xs:annotation>
        <xs:documentation>
          Specification tag or list of tags
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="size" type="shipsizeclasslookup">
      <xs:annotation>
        <xs:documentation>
          Ship size
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="required" type="boolean">
      <xs:annotation>
        <xs:documentation>
          If true then an error message will be produced if no matching ship entry is found (default is true). Note that no ship will be created in either case.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="comment" type="comment" />
  </xs:complexType>

  <xs:complexType name="characterdbcategory">
    <xs:attribute name="faction" type="rawfactionexprlookup">
      <xs:annotation>
        <xs:documentation>
          Faction or list of factions
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tags" type="expression">
      <xs:annotation>
        <xs:documentation>
          Specification tag or list of tags
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="race" type="rawraceexprlookup">
      <xs:annotation>
        <xs:documentation>
          Character race (species)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="comment" type="comment" />
  </xs:complexType>

  <xs:complexType name="characterdbcategoryselect">
    <xs:attribute name="faction" type="factionexprlookup">
      <xs:annotation>
        <xs:documentation>
          Faction or list of factions
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tags" type="expression">
      <xs:annotation>
        <xs:documentation>
          Specification tag or list of tags
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="race" type="raceexprlookup">
      <xs:annotation>
        <xs:documentation>
          Character race or list of races
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="required" type="boolean">
      <xs:annotation>
        <xs:documentation>
          If true then an error message will be produced if no matching character entry is found (default is true). Note that no NPC will be created in either case.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="comment" type="comment" />
  </xs:complexType>

  <xs:complexType name="moduledbcategory">
    <xs:attribute name="faction" type="rawfactionexprlookup">
      <xs:annotation>
        <xs:documentation>
          Faction or list of factions
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="race" type="rawraceexprlookup">
      <xs:annotation>
        <xs:documentation>
          Race
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tags" type="expression">
      <xs:annotation>
        <xs:documentation>
          Specification tag or list of tags
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ware" type="expression">
      <xs:annotation>
        <xs:documentation>
          Production ware
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="comment" type="comment" />
  </xs:complexType>

  <xs:complexType name="moduledbcategoryselect">
    <xs:attribute name="faction" type="factionexprlookup">
      <xs:annotation>
        <xs:documentation>
          Faction or list of factions
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="race" type="raceexprlookup">
      <xs:annotation>
        <xs:documentation>
          Module race
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tags" type="expression">
      <xs:annotation>
        <xs:documentation>
          Specification tag or list of tags
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ware" type="expression">
      <xs:annotation>
        <xs:documentation>
          Production ware
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="required" type="boolean">
      <xs:annotation>
        <xs:documentation>
          If true then an error message will be produced if no matching module entry is found (default is true). Note that no module will be created in either case.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="comment" type="comment" />
  </xs:complexType>

  <xs:complexType name="roomdbcategory">
    <xs:attribute name="race" type="rawraceexprlookup">
      <xs:annotation>
        <xs:documentation>
          Race
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tags" type="expression">
      <xs:annotation>
        <xs:documentation>
          Specification tag or list of tags
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="propdbcategory">
    <xs:sequence>
      <xs:element name="security" minOccurs="0" maxOccurs="1">
        <xs:annotation>
          <xs:documentation>
            Security level (not available from scripts)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="min" type="xs:float" use="optional">
            <xs:annotation>
              <xs:documentation>
                Minimum security level
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="max" type="xs:float" use="optional">
            <xs:annotation>
              <xs:documentation>
                Maximum security level
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="economy" minOccurs="0" maxOccurs="1">
        <xs:annotation>
          <xs:documentation>
            Economy level (not available from scripts)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="min" type="xs:float" use="optional">
            <xs:annotation>
              <xs:documentation>
                Minimum economy level
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="max" type="xs:float" use="optional">
            <xs:annotation>
              <xs:documentation>
                Maximum economy level
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="maintenance" minOccurs="0" maxOccurs="1">
        <xs:annotation>
          <xs:documentation>
            Maintenance level (not available from scripts)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="min" type="xs:float" use="optional">
            <xs:annotation>
              <xs:documentation>
                Minimum maintenance level
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="max" type="xs:float" use="optional">
            <xs:annotation>
              <xs:documentation>
                Maximum maintenance level
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="tags" type="expression" use="optional">
      <xs:annotation>
        <xs:documentation>
          Specification tag or list of tags
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="macro" type="expression" use="optional">
      <xs:annotation>
        <xs:documentation>
          Macro that props can be attached to
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="flags" type="propflagbitmask" use="optional">
      <xs:annotation>
        <xs:documentation>
          Prop flags (not available from scripts)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="stationdbcategory">
    <xs:attribute name="faction" type="rawfactionexprlookup">
      <xs:annotation>
        <xs:documentation>
          Faction or list of factions
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="race" type="rawraceexprlookup">
      <xs:annotation>
        <xs:documentation>
          Race
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tags" type="expression">
      <xs:annotation>
        <xs:documentation>
          Specification tag or list of tags
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ware" type="expression">
      <xs:annotation>
        <xs:documentation>
          Production ware
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="comment" type="comment" />
  </xs:complexType>

  <xs:complexType name="stationdbcategoryselect">
    <xs:attribute name="faction" type="factionexprlookup">
      <xs:annotation>
        <xs:documentation>
          Faction or list of factions
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="race" type="raceexprlookup">
      <xs:annotation>
        <xs:documentation>
          Station race
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tags" type="expression">
      <xs:annotation>
        <xs:documentation>
          Specification tag or list of tags
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ware" type="expression">
      <xs:annotation>
        <xs:documentation>
          Production ware
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="required" type="boolean">
      <xs:annotation>
        <xs:documentation>
          If true then an error message will be produced if no matching station entry is found (default is true). Note that no station will be created in either case.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="comment" type="comment" />
  </xs:complexType>

  <xs:complexType name="event_playerpricemodifier">
    <xs:attributeGroup ref="eventcondition" />
    <xs:attribute name="source" type="expression">
      <xs:annotation>
        <xs:documentation>
          Source of discount/commission, can be an object or a faction
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type">
      <xs:annotation>
        <xs:documentation>
          Required type of discount/commission source
        </xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="object">
            <xs:annotation>
              <xs:documentation>
                Source is an object (ship or station)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="faction">
            <xs:annotation>
              <xs:documentation>
                Source is a faction
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="loadout">
    <xs:attribute name="id" type="namestring" use="required">
      <xs:annotation>
        <xs:documentation>
          Loadout id
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="textdbref" use="optional">
      <xs:annotation>
        <xs:documentation>
          Loadout name
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="icon" type="namestring" use="optional">
      <xs:annotation>
        <xs:documentation>
          Loadout icon name
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="build" type="boolean" use="optional">
      <xs:annotation>
        <xs:documentation>
          Can be used for building?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="job" type="boolean" use="optional">
      <xs:annotation>
        <xs:documentation>
          Can be used by jobs?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="player" type="boolean" use="optional">
      <xs:annotation>
        <xs:documentation>
          Can be used by player?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="generated" type="boolean" use="optional">
      <xs:annotation>
        <xs:documentation>
          Loadout was generated?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="loadoutmacro">
    <xs:attribute name="macro" type="namestring" use="required">
      <xs:annotation>
        <xs:documentation>
          Macro name
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="path" type="namestring" use="optional">
      <xs:annotation>
        <xs:documentation>
          Macro path
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="optional" type="boolean" use="optional">
      <xs:annotation>
        <xs:documentation>
          Optional item?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ammmunition" type="namestring" use="optional">
      <xs:annotation>
        <xs:documentation>
          Ammunition type (missile launchers/turrets only, uses default if ommitted)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="weaponmode" type="extendedweaponmodelookup" use="optional">
      <xs:annotation>
        <xs:documentation>
          Weapon mode (turrets only, uses default if ommitted)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="debug" type="boolean" use="optional">
      <xs:annotation>
        <xs:documentation>
          Debug-only item?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="loadoutgroup">
    <xs:attribute name="macro" type="namestring" use="required">
      <xs:annotation>
        <xs:documentation>
          Macro name
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="path" type="namestring" use="optional">
      <xs:annotation>
        <xs:documentation>
          Macro path
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="group" type="namestring" use="optional">
      <xs:annotation>
        <xs:documentation>
          Connection group
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="exact" type="xs:integer">
      <xs:annotation>
        <xs:documentation>
          Exact number/percentage of slots to fill (takes priority over min/max)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="min" type="xs:integer">
      <xs:annotation>
        <xs:documentation>
          Minimum number/percentage of slots to fill (ignored if exact is set)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="max" type="xs:integer">
      <xs:annotation>
        <xs:documentation>
          Maximum number/percentage of slots to fill (ignored if exact is set)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="percent" type="boolean" use="optional">
      <xs:annotation>
        <xs:documentation>
          Exact/min/max values are percentages?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="optional" type="boolean" use="optional">
      <xs:annotation>
        <xs:documentation>
          Optional item?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ammmunition" type="namestring" use="optional">
      <xs:annotation>
        <xs:documentation>
          Ammunition type (missile launchers/turrets only, uses default if ommitted)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="weaponmode" type="extendedweaponmodelookup" use="optional">
      <xs:annotation>
        <xs:documentation>
          Weapon mode (turrets only, uses default if ommitted)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="loadoutammo">
    <xs:attribute name="macro" type="namestring" use="required">
      <xs:annotation>
        <xs:documentation>
          Macro name
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="exact" type="xs:integer">
      <xs:annotation>
        <xs:documentation>
          Exact number of ammunution units (takes priority over min/max)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="min" type="xs:integer">
      <xs:annotation>
        <xs:documentation>
          Minimum number of ammunution units (ignored if exact is set)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="max" type="xs:integer">
      <xs:annotation>
        <xs:documentation>
          Maximum number of ammunution units (ignored if exact is set)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chance" type="xs:float" use="optional">
      <xs:annotation>
        <xs:documentation>
          Percentage chance of being present
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="optional" type="boolean" use="optional">
      <xs:annotation>
        <xs:documentation>
          Optional item?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="loadoutsoftware">
    <xs:attribute name="ware" type="namestring" use="required">
      <xs:annotation>
        <xs:documentation>
          Ware name
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chance" type="xs:float" use="optional">
      <xs:annotation>
        <xs:documentation>
          Percentage chance of being present
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="loadoutvirtualmacro">
    <xs:attribute name="macro" type="namestring" use="required">
      <xs:annotation>
        <xs:documentation>
          Macro name
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="optional" type="boolean" use="optional">
      <xs:annotation>
        <xs:documentation>
          Optional item?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="loadoutcrew">
    <xs:attribute name="role" type="entityhirablerolelookup" use="required">
      <xs:annotation>
        <xs:documentation>
          Crew role
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="exact" type="xs:integer">
      <xs:annotation>
        <xs:documentation>
          Exact number of crew (takes priority over min/max)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="min" type="xs:integer">
      <xs:annotation>
        <xs:documentation>
          Minimum number of crew (ignored if exact is set)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="max" type="xs:integer">
      <xs:annotation>
        <xs:documentation>
          Maximum number of crew (ignored if exact is set)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chance" type="xs:float" use="optional">
      <xs:annotation>
        <xs:documentation>
          Percentage chance of being present
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="optional" type="boolean" use="optional">
      <xs:annotation>
        <xs:documentation>
          Optional item?
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="terraformingcondition">
    <xs:attribute name="stat" type="expression" use="required">
      <xs:annotation>
        <xs:documentation>
          Stat ID (see terraforming.xml for valid values) or "population"
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="min" type="expression">
      <xs:annotation>
        <xs:documentation>
          The minimum state of the stat. Ignored if minvalue is set. Defaults to no minimum.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="max" type="expression">
      <xs:annotation>
        <xs:documentation>
          The maximum state of the stat. Ignored if maxvalue is set. Defaults to no maximum.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="minvalue" type="expression">
      <xs:annotation>
        <xs:documentation>
          The minimum value of the stat. Defaults to no minimum.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxvalue" type="expression">
      <xs:annotation>
        <xs:documentation>
          The maximum value of the stat. Defaults to no maximum.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="terraformingconditions">
    <xs:annotation>
      <xs:documentation>
        Project conditions
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="condition" type="terraformingcondition" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:complexType>

  <xs:attributeGroup name="terraformingeffectattributes">
    <xs:attribute name="text" type="expression">
      <xs:annotation>
        <xs:documentation>
          Override text (optional if a stat is defined)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stat" type="expression">
      <xs:annotation>
        <xs:documentation>
          Stat ID (see terraforming.xml for valid values) or "population"
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="change" type="expression">
      <xs:annotation>
        <xs:documentation>
          Stat change that will be applied
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="min" type="expression">
      <xs:annotation>
        <xs:documentation>
          The minimum value of the stat after applying the change. Defaults to no minimum. Ignored if stat is "population"
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="max" type="expression">
      <xs:annotation>
        <xs:documentation>
          The maximum value of the stat after applying the change. Defaults to no maximum. Ignored if stat is "population"
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="expression">
      <xs:annotation>
        <xs:documentation>
          Stat value that will be set, used if change if 0. min/max do not apply. Ignored if stat is "population"
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="onfail" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Whether this effect also happens on failure. Defaults to false. Ignored if stat is "population"
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="beneficial" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Whether this effect is beneficial. Defaults to true. Only required if it's not a stat change or a setback, in which case the code determines it.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:complexType name="terraformingeffect">
    <xs:attributeGroup ref="terraformingeffectattributes" />
  </xs:complexType>

  <xs:complexType name="terraformingeffects">
    <xs:sequence>
      <xs:element name="effect" type="terraformingeffect" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="terraformingsideeffect">
    <xs:attributeGroup ref="terraformingeffectattributes" />
    <xs:attribute name="project" type="expression">
      <xs:annotation>
        <xs:documentation>
          ID of the project that blocks progress if this side-effect is triggered
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="setback" type="expression">
      <xs:annotation>
        <xs:documentation>
          Percentage of progress lost on current project if side-effect is triggered
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chance" type="expression" use="required">
      <xs:annotation>
        <xs:documentation>
          The chance in percent of this effect to occur.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="terraformingsideeffects">
    <xs:sequence>
      <xs:element name="sideeffect" type="terraformingsideeffect" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="terraformingrebate">
    <xs:attribute name="waregroup" type="expression" use="required">
      <xs:annotation>
        <xs:documentation>
          The ware group this rebate applies to (see waregroups.xml).
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="expression" use="required">
      <xs:annotation>
        <xs:documentation>
          The rebate amount in percent.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="terraformingrebates">
    <xs:sequence>
      <xs:element name="rebate" type="terraformingrebate" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="terraformingwareamount">
    <xs:attribute name="ware" type="ware" use="required">
      <xs:annotation>
        <xs:documentation>
          Ware ID
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="amount" type="expression">
      <xs:annotation>
        <xs:documentation>
          Amount. Defaults to 1.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="terraformingresources">
    <xs:annotation>
      <xs:documentation>
        Required resources. The amounts will be scaled, using the average prices, to reach the defined total price. If no resource wares are given this is a direct payment instead.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="ware" type="terraformingwareamount" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="price" type="expression" use="required">
      <xs:annotation>
        <xs:documentation>
          The total cost
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="pricescale" type="terraformingpricescalelookup">
      <xs:annotation>
        <xs:documentation>
          Whether and how the price should scale. Defaults to 'absolute'.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="payout" type="expression">
      <xs:annotation>
        <xs:documentation>
          The payout of this project upon successful completion, as a percentage of the price. Defaults to 0.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="minwares" type="expression">
      <xs:annotation>
        <xs:documentation>
          The minimum amount of wares to randomly choose from the list. Defaults to the total amount.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxwares" type="expression">
      <xs:annotation>
        <xs:documentation>
          The maximum amount of wares to randomly choose from the list. Defaults to the total amount.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="terraformingdelivery">
    <xs:attribute name="macro" type="macro" use="required">
      <xs:annotation>
        <xs:documentation>
          Ship macro
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="amount" type="expression" use="required">
      <xs:annotation>
        <xs:documentation>
          Amount
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="buildduration" type="expression">
      <xs:annotation>
        <xs:documentation>
          Build duration override per ship
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="terraformingdeliveries">
    <xs:annotation>
      <xs:documentation>
        Ships to be built for delivery of resources
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="ship" type="terraformingdelivery" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="terraformingremovedprojects">
    <xs:annotation>
      <xs:documentation>
        Projects that will be removed when this one is completed (usually used for mutually exclusive choices)
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="project" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:attribute name="id" type="expression">
            <xs:annotation>
              <xs:documentation>
                ID of the project to remove when this one completes successfully.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="terraformingpredecessors">
    <xs:annotation>
      <xs:documentation>
        The predecessor projects that must be completed before this one can be started. Either id or group must be supplied.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="predecessor" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:attribute name="id" type="expression">
            <xs:annotation>
              <xs:documentation>
                The ID of the predecessor project. Must include the postfix, if there is one.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group" type="expression">
            <xs:annotation>
              <xs:documentation>
                The group ID of the predecessors.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="any" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether only one of the specified projects in this group is required instead of all of them. Defaults to true.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="any" type="booleanexpression">
      <xs:annotation>
        <xs:documentation>
          Whether only one of the specified projects is required instead of all of them. Defaults to false.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="terraformingaction">
    <xs:all>
      <xs:element name="conditions" type="terraformingconditions" minOccurs="0" maxOccurs="1" />
      <xs:element name="effects" type="terraformingeffects" minOccurs="0" maxOccurs="1" />
      <xs:element name="sideeffects" type="terraformingsideeffects" minOccurs="0" maxOccurs="1" />
      <xs:element name="rebates" type="terraformingrebates" minOccurs="0" maxOccurs="1" />
      <xs:element name="resources" type="terraformingresources" minOccurs="0" maxOccurs="1" />
      <xs:element name="deliveries" type="terraformingdeliveries" minOccurs="0" maxOccurs="1" />
      <xs:element name="predecessors" type="terraformingpredecessors" minOccurs="0" maxOccurs="1" />
      <xs:element name="removedprojects" type="terraformingremovedprojects" minOccurs="0" maxOccurs="1" />
    </xs:all>
    <xs:attributeGroup ref="action" />
    <xs:attribute name="cluster" type="cluster" use="required" />
    <xs:attribute name="id" type="expression" use="required">
      <xs:annotation>
        <xs:documentation>
          The ID of the project.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="expression">
      <xs:annotation>
        <xs:documentation>
          The name of this project that is shown to the player (text reference).
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="description" type="expression">
      <xs:annotation>
        <xs:documentation>
          The description of this project that is shown to the player (text reference).
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="duration" type="expression">
      <xs:annotation>
        <xs:documentation>
          The time between all resources being delivered and the project completing.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="repeat" type="expression">
      <xs:annotation>
        <xs:documentation>
          The minimum time between a project completing successfully and it becoming available again. The project is not repeatable if this is not set.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="successchance" type="expression">
      <xs:annotation>
        <xs:documentation>
          The success chance of this project in percent. Defaults to 100.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="price" type="expression">
      <xs:annotation>
        <xs:documentation>
          The price of this project in Credits. Is used to calculate the full ware amounts, using the maximum possible prices, if a ware list is supplied.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="pricescale" type="terraformingpricescalelookup">
      <xs:annotation>
        <xs:documentation>
          The price scaling method. Defaults to 'absolute'.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="starttime" type="expression">
      <xs:annotation>
        <xs:documentation>
          The time this project was started. If supplied, the effects are already assumed to have taken effect. Defaults to "never".
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <!-- ===== Generic groups ==== -->

  <xs:group name="selectrandom">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="select">
          <xs:annotation>
            <xs:documentation>
              Selection element (used if selection attribute present)
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attributeGroup ref="random" />
            <xs:attribute name="weight" type="selectionweight" />
            <xs:attribute name="comment" type="comment" />
          </xs:complexType>
        </xs:element>
      </xs:choice>
    </xs:sequence>
  </xs:group>

  <xs:group name="equipmentmods">
    <xs:annotation>
      <xs:documentation>
        Equipment mods
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="1">
        <xs:sequence>
          <xs:element name="chance" minOccurs="0" maxOccurs="1">
            <xs:annotation>
              <xs:documentation>
                The percentage chance that an equipment mod may be installed on this ship. Also the chance that additional equipment mods may be installed. Given as a float between 0 and 1.
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attributeGroup ref="random" />
            </xs:complexType>
          </xs:element>
        </xs:sequence>
        <xs:sequence>
          <xs:element name="engine" minOccurs="0" maxOccurs="1">
            <xs:annotation>
              <xs:documentation>
                Engine mod specification
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ware" type="expression" use="required">
                <xs:annotation>
                  <xs:documentation>
                    Engine mod ware (from equipmentmods.xml, defines a quality level and primary property of engine mod)
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
            </xs:complexType>
          </xs:element>
          <xs:element name="weapon" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation>
                Weapon mod specification
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ware" type="expression" use="required">
                <xs:annotation>
                  <xs:documentation>
                    Weapon mod ware (from equipmentmods.xml, defines a quality level and primary property of weapon mod)
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="macro" type="expression">
                <xs:annotation>
                  <xs:documentation>
                    Weapon macro of weapon on which weapon mod should be installed
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="context" type="expression">
                <xs:annotation>
                  <xs:documentation>
                    Weapon group context on which weapon mod should be installed (grouped weapon mods only, macro path as string)
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="group" type="expression">
                <xs:annotation>
                  <xs:documentation>
                    Weapon group on which weapon mod should be installed (grouped weapon mods only)
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
            </xs:complexType>
          </xs:element>
          <xs:element name="shield" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation>
                Shield mod specification
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ware" type="expression" use="required">
                <xs:annotation>
                  <xs:documentation>
                    Shield group context on which shield mod should be installed (macro path as string, object itself if not specified)
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="context" type="expression">
                <xs:annotation>
                  <xs:documentation>
                    Shield group context (main ship context if not specified)
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="group" type="expression">
                <xs:annotation>
                  <xs:documentation>
                    Shield group on which shield mod should be installed (context's null group if not specified)
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
            </xs:complexType>
          </xs:element>
          <xs:element name="ship" minOccurs="0" maxOccurs="1">
            <xs:annotation>
              <xs:documentation>
                Ship mod specification
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="ware" type="expression" use="required">
                <xs:annotation>
                  <xs:documentation>
                    Ship mod ware (from equipmentmods.xml, defines a quality level and primary property of ship mod)
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
            </xs:complexType>
          </xs:element>
          <xs:element name="mods" minOccurs="0" maxOccurs="1">
            <xs:annotation>
              <xs:documentation>
                Equipment mod specification list
              </xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:attribute name="list" type="expression" use="required">
                <xs:annotation>
                  <xs:documentation>
                    List containing equipment mod wares
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:choice>
    </xs:sequence>
  </xs:group>

  <xs:group name="createship">
    <xs:sequence>
      <xs:element name="select" type="shipdbcategoryselect" minOccurs="0" maxOccurs="1">
        <xs:annotation>
          <xs:documentation>
            Criteria for selecting a suitable ship from the ShipDB.
            If combined with a static ShipDB reference in the ref attribute, the nodes of the referenced type take precedence.
            &lt;select&gt; cannot be combined with a variable ShipDB reference.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="owner">
          <xs:annotation>
            <xs:documentation>
              Owner faction selection (if missing and a pilot node is present, the pilot's faction will be used)
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:group ref="selectrandom" />
            <xs:attributeGroup ref="random" />
            <xs:attribute name="selection" type="selectionlookup" />
            <xs:attribute name="overridenpc" type="booleanexpression">
              <xs:annotation>
                <xs:documentation>
                  Override the owner faction of the generated NPCs to the owner defined in this node (otherwise the owner may be random based on the character reference)
                </xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="comment" type="comment" />
          </xs:complexType>
        </xs:element>
        <xs:element name="pilot">
          <xs:annotation>
            <xs:documentation>
              Pilot
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:group ref="createnpc" />
            <xs:attributeGroup ref="createnpc" />
            <xs:attribute name="comment" type="comment" />
          </xs:complexType>
        </xs:element>
        <xs:element name="loadout">
          <xs:annotation>
            <xs:documentation>
              The loadout that the ship should be given. Can be defined as a reference to a loadout definition or as a level to which the ship should be outfitted.
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence>
              <xs:element name="level" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                  <xs:documentation>
                    The percentage level to which this ship should be fitted out with randomly generated equipment. Given as a float between 0 and 1. Note that this level is modified by the variation which defaults to the value from parameters unless explicitly specified as well.
                  </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                  <xs:attributeGroup ref="random" />
                </xs:complexType>
              </xs:element>
              <xs:element name="variation" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                  <xs:documentation>
                    The variation in level (ignored if level not supplied). Given as a float between 0 and 1 (uses default from parameters if not supplied).
                  </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                  <xs:attributeGroup ref="random" />
                </xs:complexType>
              </xs:element>
            </xs:sequence>
            <xs:attribute name="ref" type="expression" use="optional">
              <xs:annotation>
                <xs:documentation>
                  A reference to a loadout definition as defined in loadouts.xml
                </xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="loadout" type="expression" use="optional">
              <xs:annotation>
                <xs:documentation>
                  A reference to a loadout created by a script
                </xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element name="equipmentmods">
          <xs:complexType>
            <xs:group ref="equipmentmods" />
          </xs:complexType>
        </xs:element>
        <xs:element name="paint">
          <xs:annotation>
            <xs:documentation>
              Paint mod specification
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="ware" type="expression" use="required">
              <xs:annotation>
                <xs:documentation>
                  Paint mod ware (from paintmods.xml, defines a quality level and visual properties of a paint mod)
                </xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element name="basket">
          <xs:annotation>
            <xs:documentation>
              Default ware basket to select wares to be added from. This basket definition is required when neither basket nor list are defined in a wares element.
              When used in the JobDB or referenced from it, this basket is optional and overrides the job's basket.
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="basket" type="namestring" use="required" />
            <xs:attribute name="comment" type="comment" />
          </xs:complexType>
        </xs:element>
        <xs:element name="ammo">
          <xs:annotation>
            <xs:documentation>
              Ammo the ship is spawned with
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element name="macro">
                <xs:complexType>
                  <xs:choice>
                    <xs:element name="fillpercent">
                      <xs:annotation>
                        <xs:documentation>
                          Fill percentage
                        </xs:documentation>
                      </xs:annotation>
                      <xs:complexType>
                        <xs:attributeGroup ref="random" />
                      </xs:complexType>
                    </xs:element>
                    <xs:element name="fillamount">
                      <xs:annotation>
                        <xs:documentation>
                          Fill amount
                        </xs:documentation>
                      </xs:annotation>
                      <xs:complexType>
                        <xs:attributeGroup ref="random" />
                      </xs:complexType>
                    </xs:element>
                  </xs:choice>
                  <xs:attribute name="ref" type="macroname" />
                  <xs:attributeGroup ref="random" />
                </xs:complexType>
              </xs:element>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name="cargo">
          <xs:annotation>
            <xs:documentation>
              Cargo the ship is spawned with
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element name="wares">
                <xs:complexType>
                  <xs:all>
                    <xs:element name="fillpercent" minOccurs="0" maxOccurs="1">
                      <xs:annotation>
                        <xs:documentation>
                          Maximum cargo space fill percent of the ware(s) added from this ware node. If specified together with fillvalue, the lower amount is used.
                        </xs:documentation>
                      </xs:annotation>
                      <xs:complexType>
                        <xs:attributeGroup ref="random" />
                      </xs:complexType>
                    </xs:element>
                    <xs:element name="fillvalue" minOccurs="0" maxOccurs="1">
                      <xs:annotation>
                        <xs:documentation>
                          Maximum credit value of the ware(s) added from this ware node. If specified together with fillpercent, the lower amount is used.
                        </xs:documentation>
                      </xs:annotation>
                      <xs:complexType>
                        <xs:attributeGroup ref="random" />
                      </xs:complexType>
                    </xs:element>
                  </xs:all>
                  <xs:attribute name="chance" >
                    <xs:annotation>
                      <xs:documentation>
                        Chance that the node will be processed.
                      </xs:documentation>
                    </xs:annotation>
                    <xs:simpleType>
                      <xs:restriction base="xs:float">
                        <xs:minInclusive value="0" />
                        <xs:maxInclusive value="100" />
                      </xs:restriction>
                    </xs:simpleType>
                  </xs:attribute>
                  <xs:attribute name="basket" type="namestring" >
                    <xs:annotation>
                      <xs:documentation>
                        Ware basket to select wares to be added from. Takes priority over wares defined in list attribute, and over any default basket.
                        If no default basket is provided via the &lt;basket&gt; element or via the job definition, either basket or list attribute must be supplied.
                      </xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                  <xs:attribute name="list" type="expression">
                    <xs:annotation>
                      <xs:documentation>
                        List of wares to be chosen from ( script-list syntax using [] !)
                      </xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                  <xs:attribute name="multiple" type="xs:boolean" >
                    <xs:annotation>
                      <xs:documentation>
                        If this is set to true, ALL wares in the basket/list will be added, evenly distributred according to fillpercent/fillvalue, otherwise a single ware will be randomly selected.
                      </xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                  <xs:attribute name="onjobrespawn" type="xs:boolean" >
                    <xs:annotation>
                      <xs:documentation>
                        By default cargo nodes are skipped for ships that are RE-spawned by the Job Engine. If this is set to true, this node will be processed every time this ship is spawned for a job. Wares nodes are always processed for non-job related ship creation.
                      </xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                </xs:complexType>
              </xs:element>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name="inventory">
          <xs:annotation>
            <xs:documentation>
              Inventory the ship is spawned with
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element name="wares">
                <xs:complexType>
                  <xs:all>
                    <xs:element name="fillamount" minOccurs="0" maxOccurs="1">
                      <xs:annotation>
                        <xs:documentation>
                          Fill amount
                        </xs:documentation>
                      </xs:annotation>
                      <xs:complexType>
                        <xs:attributeGroup ref="random" />
                      </xs:complexType>
                    </xs:element>
                    <xs:element name="fillvalue" minOccurs="0" maxOccurs="1">
                      <xs:annotation>
                        <xs:documentation>
                          Fill value
                        </xs:documentation>
                      </xs:annotation>
                      <xs:complexType>
                        <xs:attributeGroup ref="random" />
                      </xs:complexType>
                    </xs:element>
                  </xs:all>
                  <xs:attribute name="chance" >
                    <xs:annotation>
                      <xs:documentation>
                        Chance that the node will be processed.
                      </xs:documentation>
                    </xs:annotation>
                    <xs:simpleType>
                      <xs:restriction base="xs:float">
                        <xs:minInclusive value="0" />
                        <xs:maxInclusive value="100" />
                      </xs:restriction>
                    </xs:simpleType>
                  </xs:attribute>
                  <xs:attribute name="basket" type="namestring" >
                    <xs:annotation>
                      <xs:documentation>
                        Ware basket to select wares to be added from. Takes priority over wares defined in list attribute, and over any default basket.
                        If no default basket is provided via the &lt;basket&gt; element or via the job definition, either basket or list attribute must be supplied.
                      </xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                  <xs:attribute name="list" type="expression">
                    <xs:annotation>
                      <xs:documentation>
                        List of wares to be chosen from ( script-list syntax using [] !)
                      </xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                  <xs:attribute name="multiple" type="xs:boolean" >
                    <xs:annotation>
                      <xs:documentation>
                        If this is set to true, ALL wares in the basket/list will be added, evenly distributred according to fillpercent/fillvalue, otherwise a single ware will be randomly selected.
                      </xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                </xs:complexType>
              </xs:element>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name="drop">
          <xs:annotation>
            <xs:documentation>
              Drop object
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="ref" type="namestring" use="required">
              <xs:annotation>
                <xs:documentation>
                  DropDB reference
                </xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="comment" type="comment" />
          </xs:complexType>
        </xs:element>
        <xs:element name="units">
          <xs:annotation>
            <xs:documentation>
              Drone Units. Currently interferes with loadouts.
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
              <xs:element name="unit">
                <xs:complexType>
                  <xs:attribute name="category" type="unitcategorylookup" use="required" />
                  <xs:attribute name="mk" type="expression" />
                  <xs:attribute name="tags" type="expression" />
                  <xs:attributeGroup ref="random" />
                </xs:complexType>
              </xs:element>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name="people">
          <xs:annotation>
            <xs:documentation>
              People on board the ship (as npc templates)
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:group ref="people"/>
            <xs:attribute name="ref" type="expression">
              <xs:annotation>
                <xs:documentation>
                  PeopleDB reference.
                  Child element &lt;fillpercent&gt; can override the fill percentage of the referenced definition.
                  Child elements &lt;person&gt; are ignored in favour of the referenced definition.
                </xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
      </xs:choice>
    </xs:sequence>
  </xs:group>

  <xs:group name="createnpc">
    <xs:sequence>
      <xs:element name="select" type="characterdbcategoryselect" minOccurs="0" maxOccurs="1">
        <xs:annotation>
          <xs:documentation>
            Criteria for selecting a suitable character from the CharacterDB.
            If combined with a static CharacterDB reference in the ref attribute, the nodes of the referenced type take precedence.
            &lt;select&gt; cannot be combined with a variable CharacterDB reference.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="name" minOccurs="0" maxOccurs="1">
          <xs:annotation>
            <xs:documentation>
              NPC name (random name will be chosen if not supplied)
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="name" type="expression" use="required">
              <xs:annotation>
                <xs:documentation>
                  Name string expression
                </xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element name="owner" type="selectrandom">
          <xs:annotation>
            <xs:documentation>
              Owner faction selection (if the NPC is used as pilot it will override the ship's owner)
            </xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="page">
          <xs:annotation>
            <xs:documentation>
              Voice page ID. Instead of directly supplying a page ID, the tags attribute can be used to specify requirements for the random page selection.
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attributeGroup ref="random" />
            <xs:attribute name="tags" type="expression">
              <xs:annotation>
                <xs:documentation>
                  Either a single tag or a list of tags which are required for the voice page.
                </xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="comment" type="comment" />
          </xs:complexType>
        </xs:element>
        <xs:element name="skills">
          <xs:annotation>
            <xs:documentation>
              Character skills
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
              <xs:element name="skill">
                <xs:annotation>
                  <xs:documentation>
                    Skill (value between 0 and 15, representing steps of 1/3 of a star, up to 5 stars)
                  </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                  <xs:attributeGroup ref="random" />
                  <xs:attribute name="type" type="skilltypelookup" use="required">
                    <xs:annotation>
                      <xs:documentation>
                        Skill type
                      </xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                  <xs:attribute name="comment" type="comment" />
                </xs:complexType>
              </xs:element>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="stock">
          <xs:annotation>
            <xs:documentation>
              Stock definition.
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="ref" type="expression">
              <xs:annotation>
                <xs:documentation>
                  The ID of the stock entry that the character should use.
                </xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="comment" type="comment" />
          </xs:complexType>
        </xs:element>
        <xs:element name="clothing" minOccurs="0" maxOccurs="1">
          <xs:annotation>
            <xs:documentation>
              Clothing mod specification
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="ware" type="expression" use="required">
              <xs:annotation>
                <xs:documentation>
                  Clothing mod ware (from clothingmods.xml, defines a quality level and visual properties of a clothing mod)
                </xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
      </xs:choice>
    </xs:sequence>
  </xs:group>

  <xs:group name="createmodule">
    <xs:sequence>
      <xs:element name="compatibilities" minOccurs="0" maxOccurs="1">
        <xs:annotation>
          <xs:documentation>
            Production compatibilities
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="limits" minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
                  Station module limits (Defaults to 20. Modules in defined base construction plans can exceed the limits)
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attributeGroup ref="moduletypelimits" />
              </xs:complexType>
            </xs:element>
            <xs:element name="production" minOccurs="0" maxOccurs="unbounded">
              <xs:complexType>
                <xs:attribute name="chance" use="required"/>
                <xs:attribute name="ref">
                  <xs:annotation>
                    <xs:documentation>
                      Module reference
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="ware" />
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="select" type="moduledbcategoryselect" minOccurs="0" maxOccurs="1">
        <xs:annotation>
          <xs:documentation>
            Criteria for selecting a suitable module from the ModuleDB.
            If combined with a static ModuleDB reference in the ref attribute, the nodes of the referenced type take precedence.
            &lt;select&gt; cannot be combined with a variable ModuleDB reference.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:group>

  <xs:group name="createstation">
    <xs:sequence>
      <xs:element name="select" type="stationdbcategoryselect" minOccurs="0" maxOccurs="1">
        <xs:annotation>
          <xs:documentation>
            Criteria for selecting a suitable station from the StationDB.
            If combined with a static StationDB reference in the ref attribute, the nodes of the referenced type take precedence.
            &lt;select&gt; cannot be combined with a variable StationDB reference.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="name" minOccurs="0" maxOccurs="1">
          <xs:annotation>
            <xs:documentation>
              Station name (default name will be used if not supplied)
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="name" type="expression" use="required">
              <xs:annotation>
                <xs:documentation>
                  Name string expression
                </xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element name="owner" type="selectrandom" minOccurs="0" maxOccurs="1">
          <xs:annotation>
            <xs:documentation>
              Owner faction selection
            </xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="loadout">
          <xs:annotation>
            <xs:documentation>
              The loadout that the ship should be given. Can be defined as a reference to a loadout definition or as a level to which the ship should be outfitted.
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence>
              <xs:element name="level" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                  <xs:documentation>
                    The percentage level to which this ship should be fitted out with randomly generated equipment. Given as a float between 0 and 1.
                  </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                  <xs:attributeGroup ref="random" />
                </xs:complexType>
              </xs:element>
              <xs:element name="variation" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                  <xs:documentation>
                    The variation in level (ignored if level not supplied). Given as a float between 0 and 1 (uses default from parameters if not supplied).
                  </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                  <xs:attributeGroup ref="random" />
                </xs:complexType>
              </xs:element>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:choice>
    </xs:sequence>
  </xs:group>

  <xs:group name="createobject">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="name" minOccurs="0" maxOccurs="1">
          <xs:annotation>
            <xs:documentation>
              Station name (default name will be used if not supplied)
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="name" type="expression" use="required">
              <xs:annotation>
                <xs:documentation>
                  Name string expression
                </xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element name="owner" type="selectrandom" minOccurs="0" maxOccurs="1">
          <xs:annotation>
            <xs:documentation>
              Owner faction selection
            </xs:documentation>
          </xs:annotation>
        </xs:element>
      </xs:choice>
    </xs:sequence>
  </xs:group>

  <xs:group name="people">
    <xs:sequence>
      <xs:element name="fillpercent" minOccurs="0" maxOccurs="1">
        <xs:annotation>
          <xs:documentation>
            Fill percentage
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="random" />
        </xs:complexType>
      </xs:element>
      <xs:element name="person" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>
            Person
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:group ref="createnpc" />
          <xs:attributeGroup ref="createnpc" />
          <xs:attribute name="role" type="entityrolelookup" use="required" />
          <xs:attribute name="comment" type="comment" />
          <xs:attribute name="weight" type="expression">
            <xs:annotation>
              <xs:documentation>
                Weight of this role selection
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>

  <xs:group name="loadoutelements">
    <xs:annotation>
      <xs:documentation>
        Loadout elements cannot contain script expressions
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="macros" minOccurs="0" maxOccurs="1">
        <xs:annotation>
          <xs:documentation>
            Macro elements
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="engine" type="loadoutmacro" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>
                  Engines
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="weapon" type="loadoutmacro" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>
                  Weapons
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="shield" type="loadoutmacro" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>
                  Shields (ungrouped)
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="turret" type="loadoutmacro" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>
                  Turrets (ungrouped)
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="groups" minOccurs="0" maxOccurs="1">
        <xs:annotation>
          <xs:documentation>
            Group elements
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="shields" type="loadoutgroup" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>
                  Shield groups
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="turrets" type="loadoutgroup" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>
                  Turret groups
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="ammunition" minOccurs="0" maxOccurs="1">
        <xs:annotation>
          <xs:documentation>
            Ammunition elements
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="ammunition" type="loadoutammo" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>
                  Ammunition
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="unit" type="loadoutammo" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>
                  Units (drones)
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="software" minOccurs="0" maxOccurs="1">
        <xs:annotation>
          <xs:documentation>
            Software elements
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="software" type="loadoutsoftware" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>
                  Software
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="values" minOccurs="0" maxOccurs="1">
        <xs:annotation>
          <xs:documentation>
            Value elements (currently unused)
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="virtualmacros" minOccurs="0" maxOccurs="1">
        <xs:annotation>
          <xs:documentation>
            Virtual macro elements
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="thruster" type="loadoutvirtualmacro" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>
                  Thrusters
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="crew" minOccurs="0" maxOccurs="1">
        <xs:annotation>
          <xs:documentation>
            Crew elements (only used when applying player-created loadouts or when people data is not supplied)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="crew" type="loadoutcrew" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>
                  Crew
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
          <xs:attribute name="experienced" type="boolean" use="optional">
            <xs:annotation>
              <xs:documentation>
                Allow a chance for experienced crew with wider skill range (default is false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>

  <xs:group name="constructionsequenceelements">
    <xs:annotation>
      <xs:documentation>
        Construction sequence elements cannot contain script expressions
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="entry" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>
            Sequence entry
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="predecessor" minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
                  Entry in sequence to which this entry is connected
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attribute name="index" type="xs:integer" use="required">
                  <xs:annotation>
                    <xs:documentation>
                      Predecessor entry index
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="connection" type="namestring" use="required">
                  <xs:annotation>
                    <xs:documentation>
                      Connection on predecessor module to which this module is connected
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
              </xs:complexType>
            </xs:element>
            <xs:element name="offset" minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
                  Offset for this entry
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="position" type="position" minOccurs="0" maxOccurs="unbounded">
                    <xs:annotation>
                      <xs:documentation>
                        Position of entry
                      </xs:documentation>
                    </xs:annotation>
                  </xs:element>
                  <xs:element name="rotation" type="rotation" minOccurs="0" maxOccurs="unbounded">
                    <xs:annotation>
                      <xs:documentation>
                        Rotation of entry
                      </xs:documentation>
                    </xs:annotation>
                  </xs:element>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name="upgrades" minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
                  Upgrades (loadout) for this entry
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:group ref="loadoutelements">
                    <xs:annotation>
                      <xs:documentation>
                        Loadout definition
                      </xs:documentation>
                    </xs:annotation>
                  </xs:group>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attribute name="index" type="xs:integer" use="required">
            <xs:annotation>
              <xs:documentation>
                Entry index
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="macro" type="namestring" use="required">
            <xs:annotation>
              <xs:documentation>
                Macro name for this module
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="connection" type="namestring">
            <xs:annotation>
              <xs:documentation>
                Connection on this module by which the module is connected to its predecessor
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="fixed" type="xs:boolean">
            <xs:annotation>
              <xs:documentation>
                Entry is fixed and cannot be changed once the station is built
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>

  <xs:group name="voicedata">
    <xs:choice>
      <xs:element name="text">
        <xs:annotation>
          <xs:documentation>
            Add a TextDB line to the texts to be spoken. Cannot be combined with attributes 'page' and 'line' in parent element.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="page" type="pagewithdefault" />
          <xs:attribute name="line" type="line" use="required" />
          <xs:attribute name="delay" type="speakdelay" />
          <xs:attribute name="comment" type="comment" />
        </xs:complexType>
      </xs:element>
      <xs:element name="name">
        <xs:annotation>
          <xs:documentation>
            Adds the name of a value to the texts to be spoken. Requires that a name has been defined in the correct format. Cannot be combined with attributes 'page' and 'line' in parent element.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="value" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                A component, object, macro, faction, race, or ware
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="delay" type="speakdelay" />
          <xs:attribute name="comment" type="comment" />
        </xs:complexType>
      </xs:element>
      <xs:element name="description">
        <xs:annotation>
          <xs:documentation>
            Adds the description of a value to the texts to be spoken. Requires that a description has been defined in the correct format. Cannot be combined with attributes 'page' and 'line' in parent element.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="value" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                A component, object, macro, faction, race, or ware
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="delay" type="speakdelay" />
          <xs:attribute name="comment" type="comment" />
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>

  <!-- ===== Common conditions ===== -->

  <xs:group name="commonconditions_event">
    <xs:choice>

      <xs:element name="event_repair_requested">
        <xs:annotation>
          <xs:documentation>
            Event for when repair of a component has been requested (object = the object containing the damaged component - e.g. a ship or station, param = the damaged component, param2 = whether to make the damaged component a priority for repair)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_ui_triggered">
        <xs:annotation>
          <xs:documentation>
            Event for when a UI control is triggered (param = screen ID, param2 = control ID, param3 = screen parameters)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="screen" type="expression">
            <xs:annotation>
              <xs:documentation>
                Screen ID
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="control" type="expression">
            <xs:annotation>
              <xs:documentation>
                Control ID
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_unit_destroyed">
        <xs:annotation>
          <xs:documentation>
            Event for when a unit has been destroyed (object = the object owning the unit, param = the unit's category, param2 = the unit's mk)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="category" type="unitcategorylookup">
            <xs:annotation>
              <xs:documentation>
                The destroyed unit's category
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="mk" type="expression" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_unit_started_building">
        <xs:annotation>
          <xs:documentation>
            Event for when a unit has started building/welding (object = the object on which the unit operates, param = the unit's mk)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="mk" type="expression" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_unit_stopped_building">
        <xs:annotation>
          <xs:documentation>
            Event for when a unit has stopped building/welding (object = the object on which the unit operates, param = the unit's mk)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="mk" type="expression" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_unit_started_repairing">
        <xs:annotation>
          <xs:documentation>
            Event for when a unit has started repairing/welding (object = the object on which the unit operates, param = the unit's mk)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="mk" type="expression" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_unit_stopped_repairing">
        <xs:annotation>
          <xs:documentation>
            Event for when a unit has stopped repairing/welding (object = the object on which the unit operates, param = the unit's mk)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="mk" type="expression" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_boarding_operation_created">
        <xs:annotation>
          <xs:documentation>
            Event for when a boarding operation has been created (param = boarding operation id)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_boarding_operation_started">
        <xs:annotation>
          <xs:documentation>
            Event for when a boarding operation has been started (param = boarding operation id)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="operation" type="expression">
            <xs:annotation>
              <xs:documentation>
                Operation ID
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_boarding_operation_removed">
        <xs:annotation>
          <xs:documentation>
            Event for when a boarding operation has been removed (param = boarding operation id)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="operation" type="expression">
            <xs:annotation>
              <xs:documentation>
                Operation ID
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_boarding_phase_changed">
        <xs:annotation>
          <xs:documentation>
            Event for when a boarding operation has had its phase changed (param = boarding operation id, param2 = new boardingphase, param3 = old boardingphase)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="operation" type="expression">
            <xs:annotation>
              <xs:documentation>
                Operation ID
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="phase" type="boardingphaselookup" />
          <xs:attribute name="previous" type="boardingphaselookup" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_boarding_support_failed">
        <xs:annotation>
          <xs:documentation>
            Event for when a boarding support mission was NOT successful (object = boarding commander)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_boarding_support_succeeded">
        <xs:annotation>
          <xs:documentation>
            Event for when a boarding support mission was successful (object = boarding commander)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_boost_charging_aborted">
        <xs:annotation>
          <xs:documentation>
            Event for when an object aborts charging boost (object = boosting object)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_boost_charging_started">
        <xs:annotation>
          <xs:documentation>
            Event for when an object starts charging boost (object = boosting object)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_boost_started">
        <xs:annotation>
          <xs:documentation>
            Event for when an object starts boosting (object = boosting object)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_boost_stopped">
        <xs:annotation>
          <xs:documentation>
            Event for when an object stops boosting (object = boosting object)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_build_started">
        <xs:annotation>
          <xs:documentation>
            Event for when a build related to the object begins (object = buildprocessor/buildmodule/buildingobject/buildingobjectcommander/buildobject, param = buildprocessor, param2 = constructionsequence, param3 = buildtask)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="buildprocessor" type="buildprocessor" />
          <xs:attribute name="build" type="build"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_build_finished">
        <xs:annotation>
          <xs:documentation>
            Event for when a build related to the object finishes (object = buildprocessor/buildmodule/buildingobject/buildingobjectcommander/buildobject, param = buildprocessor, param2 = unused, param3 = buildtask)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="buildprocessor" type="buildprocessor" />
          <xs:attribute name="build" type="build"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_build_finished_components">
        <xs:annotation>
          <xs:documentation>
            Event for when a build related to the object partially finishes construction. List of completed components is provided. (object = buildprocessor/buildmodule/buildingobject/buildingobjectcommander/buildobject, param = buildprocessor, param2 = list, param3 = buildtask)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="buildprocessor" type="buildprocessor" />
          <xs:attribute name="build" type="build"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_build_cancelled">
        <xs:annotation>
          <xs:documentation>
            Event for when a build related to the object is cancelled (object = buildprocessor/buildmodule/buildingobject/buildingobjectcommander/buildobject, param = buildprocessor, param2 = constructionsequence, param3 = buildtask)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="buildprocessor" type="buildprocessor" />
          <xs:attribute name="build" type="build"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_build_added">
        <xs:annotation>
          <xs:documentation>
            Event for when a build task is added (object = building object, param = build task)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_built_ship">
        <xs:annotation>
          <xs:documentation>
            Event for when a ship is constructed to operational state (object = buildingobject, param = ship, param2 = buildtask)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="ship" type="ship" />
          <xs:attribute name="build" type="build"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_built_station">
        <xs:annotation>
          <xs:documentation>
            Event for when a station is constructed to operational state (object = buildingobject, param = station, param2 = buildtask)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="ship" type="ship" />
          <xs:attribute name="build" type="build"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_build_storage_moved">
        <xs:annotation>
          <xs:documentation>
            Event for when a build storage has been moved (object = build storage or the base station)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_build_loadout_applied">
        <xs:annotation>
          <xs:documentation>
            Event for when a build related to the object has applied a loadout to the build component. List of added components is provided. (object = buildprocessor/buildmodule/buildingobject/buildingobjectcommander/buildobject, param = buildprocessor, param2 = new components, param3 = buildtask)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="buildprocessor" type="buildprocessor" />
          <xs:attribute name="build" type="build"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_control_entity_added">
        <xs:annotation>
          <xs:documentation>
            Event for when a control entity is set on a controllable (object = controllable or entity, param = entity)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="entity" type="entity"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_control_entity_removed">
        <xs:annotation>
          <xs:documentation>
            Event for when a control entity is removed from a controllable (object = controllable or entity, param = entity, param2 = kill method)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="entity" type="entity"/>
          <xs:attribute name="method" type="killmethodlookup" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_conversation_finished">
        <xs:annotation>
          <xs:documentation>
            Event for when a conversation is finished (object = actor (entity or list containing context and template), param = outcome, param2 = outcome parameter)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="actor" type="genericactor" />
          <xs:attribute name="outcome" type="expression">
            <xs:annotation>
              <xs:documentation>
                Conversation outcome (the name of the last section chosen by the player, or the conversation name in case of a non-interactive conversation)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="outcomeparam" type="expression">
            <xs:annotation>
              <xs:documentation>
                The outcome parameter (the last choice parameter as provided by &lt;add_player_choice&gt;, &lt;add_player_choice_sub&gt;, or a menu selection),
                or the conversation parameter in case of a non-interactive conversation (as provided by &lt;start_conversation&gt;)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_conversation_next_section">
        <xs:annotation>
          <xs:documentation>
            Event for when the next section in a conversation is triggered (object = actor (entity or list containing context and template), param = section name, param2 = choice parameter)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="actor" type="genericactor" />
          <xs:attribute name="section" type="section" />
          <xs:attribute name="sectionprefix" type="namestring">
            <xs:annotation>
              <xs:documentation>
                Prefix of conversation section name that has to be matched
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="choiceparam" type="expression">
            <xs:annotation>
              <xs:documentation>
                The parameter associated with the player choice, as provided by &lt;add_player_choice&gt;, &lt;add_player_choice_sub&gt;, or a menu selection
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_conversation_returned_to_section">
        <xs:annotation>
          <xs:documentation>
            Event for when a sub-conversation returns to the previous section (object = actor (entity or list containing context and template), param = section name, param2 = base parameter, param3 = return parameter)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="actor" type="genericactor" />
          <xs:attribute name="section" type="section" />
          <xs:attribute name="sectionprefix" type="namestring">
            <xs:annotation>
              <xs:documentation>
                Prefix of conversation section name that has to be matched
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="baseparam" type="expression">
            <xs:annotation>
              <xs:documentation>
                The value provided by this previous section when it started the sub-conversation (baseparam of &lt;add_player_choice_sub&gt;, &lt;add_player_choice_subconv&gt;, or of the menu selection).
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="returnparam" type="expression">
            <xs:annotation>
              <xs:documentation>
                The value provided by the player choice that returned to this previous section (returnparam of &lt;add_player_choice_return&gt; or of the menu selection).
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_conversation_started">
        <xs:annotation>
          <xs:documentation>
            Event for when a conversation is started (object = actor (entity or list containing context and template), param = conversation name, param2 = conversation parameter)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="actor" type="genericactor" />
          <xs:attribute name="conversation" type="conversation" />
          <xs:attribute name="convprefix" type="namestring">
            <xs:annotation>
              <xs:documentation>
                Prefix of conversation name that has to be matched
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="convparam" type="expression">
            <xs:annotation>
              <xs:documentation>
                The parameter associated with the conversation, as provided by &lt;start_conversation&gt;
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_warning">
        <xs:annotation>
          <xs:documentation>
            Event for when the player shuold be warned, e.g. on station explosion (param = component, param2 = text line)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="component" type="expression">
            <xs:annotation>
              <xs:documentation>
                Component that is the reason for the warning
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="line" type="expression">
            <xs:annotation>
              <xs:documentation>
                Text line
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_cutscene_camera_created">
        <xs:annotation>
          <xs:documentation>
            Event for when the camera of a cutscene is created (param = cutscene key string, param2 = cutscene ID)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="cutscenekeyorid" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_cutscene_signal">
        <xs:annotation>
          <xs:documentation>
            Event for when a cutscene sends a signal (param = cutscene key string)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="name" type="expression">
            <xs:annotation>
              <xs:documentation>
                Signal ID name
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_cutscene_started">
        <xs:annotation>
          <xs:documentation>
            Event for when a cutscene starts (param = cutscene key string, param2 = cutscene ID)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="cutscenekeyorid" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_cutscene_ready">
        <xs:annotation>
          <xs:documentation>
            Event for when a cutscene has been started and loading of required assets for playing the cutscene, e.g. an NPC body, is completed (param = cutscene key string, param2 = cutscene ID)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="cutscenekeyorid" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_cutscene_stopped">
        <xs:annotation>
          <xs:documentation>
            Event for when a cutscene ends (param = cutscene key string, param2 = cutscene ID)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="cutscenekeyorid" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_long_range_scan_ping">
        <xs:annotation>
          <xs:documentation>
            Event for when an object is pinged by a long range scan. (object = scanned object, param = true iff the result was 'identified')
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="identified" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Was the result 'identified'?
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_long_range_scan_sent">
        <xs:annotation>
          <xs:documentation>
            Event for when an object sends out a long range scan wave. (object = scanning object or player)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_character_animation_started">
        <xs:annotation>
          <xs:documentation>
            Event for when a character starts an animation. (object = player/npc, param = animation ID)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="id" type="expression">
            <xs:annotation>
              <xs:documentation>
                Animation ID
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_character_animation_finished">
        <xs:annotation>
          <xs:documentation>
            Event for when a character finishes an animation. (object = player/npc, param = animation ID)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="id" type="expression">
            <xs:annotation>
              <xs:documentation>
                Animation ID
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_npc_walk_finished">
        <xs:annotation>
          <xs:documentation>
            Event for when a npc finishes their walk. (object = npc)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_npc_slots_validated">
        <xs:annotation>
          <xs:documentation>
            Event for when npc slots are validated in an interior which could have blocked slots (object = interior or object of interior, param = interior, param2 = was this a recalculation of an already validated interior?)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="interior" type="object" />
          <xs:attribute name="recalculation" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Was this validation a recalculation of a previously validated interior?
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_lock_acquired">
        <xs:annotation>
          <xs:documentation>
            Event for when a target lock is acquired (requires attribute attacker and/or target) (object = attacker if supplied, otherwise target object, param = the other object, param2 = locking weapon, param3 = target component)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="attacker" type="lockattackerrequired" />
          <xs:attribute name="target" type="locktargetrequired" />
          <xs:attribute name="weapon" type="weapon" />
          <xs:attribute name="component" type="locktargetcomponent" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_lock_initiated">
        <xs:annotation>
          <xs:documentation>
            Event for when a target lock attempt is initiated (requires attribute attacker and/or target) (object = attacker if supplied, otherwise target object, param = the other object, param2 = locking weapon, param3 = target component)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="attacker" type="lockattackerrequired" />
          <xs:attribute name="target" type="locktargetrequired" />
          <xs:attribute name="weapon" type="weapon" />
          <xs:attribute name="component" type="locktargetcomponent" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_lock_lost">
        <xs:annotation>
          <xs:documentation>
            Event for when a target lock is lost (requires attribute attacker and/or target) (object = attacker if supplied, otherwise target object, param = the other object, param2 = locking weapon, param3 = target component)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="attacker" type="lockattackerrequired" />
          <xs:attribute name="target" type="locktargetrequired" />
          <xs:attribute name="weapon" type="weapon" />
          <xs:attribute name="component" type="locktargetcomponent" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_masstraffic_ship_removed">
        <xs:annotation>
          <xs:documentation>
            Event for when a mass traffic ship is removed from a zone. If zone is provided then it is the event object (object = zone, param = mass traffic ship), otherwise object or group must be provided (object = mass traffic ship)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="zone" type="zone" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_illegal_activity_detected">
        <xs:annotation>
          <xs:documentation>
            Event for when an object has been caught doing an illegal activity (see &lt;report_illegal_activity&gt;), like hacking or certain types of scanning (param = caught object, param2 = victim of the activity [optional])
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="object" type="expression">
            <xs:annotation>
              <xs:documentation>
                The object doing the illegal activity (attribute must be present if victim not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="victim" type="expression">
            <xs:annotation>
              <xs:documentation>
                The victim of the activity (attribute must be present if object not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_approaching_waypoint">
        <xs:annotation>
          <xs:documentation>
            Event for when a target waypoint is approached (but not necessarily yet reached) by a flying object (object = approaching object, param = remaining time)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_arrived_at_waypoint">
        <xs:annotation>
          <xs:documentation>
            Event for when a flying object arrives at a target waypoint (object = arriving object)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_gravidar_has_scanned">
        <xs:annotation>
          <xs:documentation>
            Event fired when the gravidar of an object has performed a scan (object = object of gravidar)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_attacked">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object being attacked (object = attacked object, param = attacker, param2 = kill method, param3 = attacked component)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="attacker" type="attacker" />
          <xs:attribute name="method" type="killmethodlookup" />
          <xs:attribute name="component" type="attackedcomponent" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_attacked_object">
        <xs:annotation>
          <xs:documentation>
            Event for when the specified object attacks an object (object = attacker, param = attacked object, param2 = kill method, param3 = [attacked component, weapon])
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="attacked" type="attackedobject" />
          <xs:attribute name="method" type="killmethodlookup" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_shield_damaged">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object's shield being damaged (object = event source, param = damaged component, param2 = new shield value, param3 = damage)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="damaged" type="damagedcomponent" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_hull_damaged">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object's hull being damaged - includes hulls of children (object = event source, param = damaged component, param2 = new hull value, param3 = damage)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="damaged" type="damagedcomponent" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_hull_repaired">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object's hull being repaired - includes hulls of children (object = event source, param = repaired component, param2 = new hull value, param3 = repaired value)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="repaired" type="repairedcomponent" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_hull_above_function_threshold">
        <xs:annotation>
          <xs:documentation>
            Event for the specified components's hull climbing above the function threshold, rendering the object functional again - includes hulls of children (object = parent object, param = affected component)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="repaired" type="repairedcomponent" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_hull_below_function_threshold">
        <xs:annotation>
          <xs:documentation>
            Event for the specified components's hull falling below the function threshold, rendering the object non-functional - includes hulls of children (object = parent object, param = affected component)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="damaged" type="damagedcomponent" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_abandoned">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object being abandoned by its NPCs (object = abandoned object)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_changed_attention">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object changing attention level (object = attention changing object, param = new attention level, param2 = previous attention level)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="attention" type="attentionexprlookup">
            <xs:annotation>
              <xs:documentation>
                New attention level
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="previous" type="attentionexprlookup">
            <xs:annotation>
              <xs:documentation>
                Previous attention level
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_changed_cluster">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object changing cluster (object = cluster changing object, param = new cluster, param2 = previous cluster)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="cluster" type="cluster" />
          <xs:attribute name="previous" type="cluster" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_changed_object">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object changing object (object = object changing object, param = new object, param2 = previous object)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="newobject" type="object" />
          <xs:attribute name="previous" type="object" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_changed_owner">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object changing owner (object = owner changing object, param = new owner faction, param2 = previous owner faction)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="owner" type="faction" />
          <xs:attribute name="previous" type="faction" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_changed_sector">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object changing sector (object = sector changing object, param = new sector, param2 = previous sector)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="sector" type="sector" />
          <xs:attribute name="previous" type="sector" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_changed_true_owner">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object changing true owner (object = owner changing object, param = new true owner faction, param2 = previous true owner faction)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="owner" type="faction" />
          <xs:attribute name="previous" type="faction" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_changed_room">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object changing room (object = room changing object, param = new room, param2 = previous room)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="room" type="room" />
          <xs:attribute name="previous" type="room" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_changed_zone">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object changing zone (object = zone changing object, param = new zone, param2 = previous zone)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="zone" type="zone" />
          <xs:attribute name="previous" type="zone" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_changed_state">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object changing state (object = state changing object, param = new state, param2 = previous state)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="state" type="componentstateexprlookup" />
          <xs:attribute name="previous" type="componentstateexprlookup" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_defencedronemode_changed">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object changing drone modes for its defence drones (object = object that launches drones, param = new drone mode)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="defencedronemode" type="dronemodeexprlookup" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_miningdronemode_changed">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object changing drone modes for its mining drones (object = object that launches drones, param = new drone mode)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="miningdronemode" type="dronemodeexprlookup" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_transportdronemode_changed">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object changing drone modes for its transport drones (object = object where drones are based, param = new drone mode)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="transportdronemode" type="dronemodeexprlookup" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_defencedrones_armed">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object authorizing defence drone use (object = object that launches drones)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_defencedrones_disarmed">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object unauthorizing defence drone use (object = object that launches drones)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_miningdrones_armed">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object authorizing mining drone use (object = object that launches drones)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_miningdrones_disarmed">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object unauthorizing mining drone use (object = object that launches drones)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_relation_range_changed">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object changing relation range (object = the object changing relation, param = faction with which relation has changed)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="faction" type="faction" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_transportdrones_armed">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object authorizing transport drone use (object = object that launches drones)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_transportdrones_disarmed">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object unauthorizing transport drone use (object = object that launches drones)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_contained_object_changed_owner">
        <xs:annotation>
          <xs:documentation>
            Event for any object within the specified space changing owner (object = space or container which contains the object, param = object changing ownership, param2 = new owner faction, param3 = previous owner faction)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="space" type="expression">
            <xs:annotation>
              <xs:documentation>
                Space which contains the object (i.e. zone, sector or cluster), or direct container context (ship or station)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group" type="groupeventsource" />
          <xs:attribute name="check" type="checkeventsource" />
          <xs:attribute name="owner" type="faction" />
          <xs:attribute name="previous" type="faction" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_contained_object_changed_true_owner">
        <xs:annotation>
          <xs:documentation>
            Event for any object within the specified space changing true owner (object = space or container which contains the object, param = object changing ownership, param2 = new true owner faction, param3 = previous true owner faction)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="space" type="expression">
            <xs:annotation>
              <xs:documentation>
                Space which contains the object (i.e. zone, sector or cluster), or direct container context (ship or station)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group" type="groupeventsource" />
          <xs:attribute name="check" type="checkeventsource" />
          <xs:attribute name="owner" type="faction" />
          <xs:attribute name="previous" type="faction" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_contained_entity_changed_owner">
        <xs:annotation>
          <xs:documentation>
            Event for any entity within the specified space changing owner (object = space or container which contains the entity, param = entity changing ownership, param2 = new owner faction, param3 = previous owner faction)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="space" type="expression">
            <xs:annotation>
              <xs:documentation>
                Space which is contains the entity (i.e. zone, sector or cluster), or direct container context (ship or station)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group" type="groupeventsource" />
          <xs:attribute name="check" type="checkeventsource" />
          <xs:attribute name="owner" type="faction" />
          <xs:attribute name="previous" type="faction" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_contained_entity_changed_true_owner">
        <xs:annotation>
          <xs:documentation>
            Event for any entity within the specified space changing true owner (object = space or container which contains the entity, param = entity changing ownership, param2 = new true owner faction, param3 = previous true owner faction)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="space" type="expression">
            <xs:annotation>
              <xs:documentation>
                Space which is contains the entity (i.e. zone, sector or cluster), or direct container context (ship or station)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group" type="groupeventsource" />
          <xs:attribute name="check" type="checkeventsource" />
          <xs:attribute name="owner" type="faction" />
          <xs:attribute name="previous" type="faction" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_contained_object_relation_range_changed">
        <xs:annotation>
          <xs:documentation>
            Event for any object within the specified space changing relation range (object = space or container which contains the object, param = object changing relation, param2 = faction with which relation has changed)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="space" type="expression">
            <xs:annotation>
              <xs:documentation>
                Space which contains the object (i.e. zone, sector or cluster)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group" type="groupeventsource" />
          <xs:attribute name="check" type="checkeventsource" />
          <xs:attribute name="faction" type="faction" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_claimed">
        <xs:annotation>
          <xs:documentation>
            Event for when an object is claimed or a NPC claims an object (requires attribute claimed and/or pilot) (do not use with player.entity) (object = claimed if supplied, otherwise pilot, param = the other object)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="claimed" type="claimedrequired" />
          <xs:attribute name="pilot" type="claimerrequired" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_collected_ammo">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object collecting ammo (object = collecting object, param = weapon macro, param2 = amount)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="macro" type="macro" />
          <xs:attribute name="amount" type="expression">
            <xs:annotation>
              <xs:documentation>
                Ammo amount
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_collected_powerup">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object collecting a powerup (object = collecting object)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_collected_resource">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object collecting a resource (object = collecting object, param = ware, param2 = amount)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="ware" type="ware" />
          <xs:attribute name="amount" type="expression">
            <xs:annotation>
              <xs:documentation>
                Ware amount
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_region_asteroid_mined">
        <xs:annotation>
          <xs:documentation>
            Event for when a region related asteroid has been mined in the specified sector, usually on destruction (object = sector containing the region, param = mined asteroid, param2 = mining object)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="sector" type="expression">
            <xs:annotation>
              <xs:documentation>
                Sector (required if group attribute not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group" type="groupeventsource" />
          <xs:attribute name="check" type="checkeventsource" />
          <xs:attribute name="asteroid" type="object">
            <xs:annotation>
              <xs:documentation>
                The mined asteroid
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="miner" type="object" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_sector_resource_depleted">
        <xs:annotation>
          <xs:documentation>
            Event for a resource in sector being depleted by a certain amount (object = sector, param = resource ware, param2 = depletion amount, param3 = [sector position, killed object, was depleted by player owned])
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="sector" type="expression">
            <xs:annotation>
              <xs:documentation>
                Sector (required if group attribute not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group" type="groupeventsource" />
          <xs:attribute name="check" type="checkeventsource" />
          <xs:attribute name="ware" type="ware" />
          <xs:attribute name="amount" type="expression">
            <xs:annotation>
              <xs:documentation>
                Ware amount
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_collected_ware">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object collecting a ware drop (object = collecting object, param = ware, param2 = amount, param3 = collected object)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="ware" type="ware" />
          <xs:attribute name="amount" type="expression">
            <xs:annotation>
              <xs:documentation>
                Ware amount
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="collected" type="object" >
            <xs:annotation>
              <xs:documentation>
                The collected object
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_collided">
        <xs:annotation>
          <xs:documentation>
            Event for when the specified object collides (object = colliding object, param = other colliding object)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="otherobject" type="object" >
            <xs:annotation>
              <xs:documentation>
                The other object involved in the collision
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_construction_sequence_created">
        <xs:annotation>
          <xs:documentation>
            Event for when the construction sequence for a station has been created, e.g. requested via &lt;create_construction_sequence&gt; (object = station, param = constructionsequence if successful, param2 = true if successful)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="success" type="booleanexpression" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_triggered">
        <xs:annotation>
          <xs:documentation>
            Event for when an object is triggered (object = trigger object, param = triggerer)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="triggerer" type="object" >
            <xs:annotation>
              <xs:documentation>
                The triggering object
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_commander_set">
        <xs:annotation>
          <xs:documentation>
            Event for when a subordinate receives a new commander (object = subordinate, param = new commander, param2 = previous commander, param3 = new assignment)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="commander" type="object" />
          <xs:attribute name="previous" type="expression">
            <xs:annotation>
              <xs:documentation>
                Previous commander (can be null)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="assignment" type="assignment" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_changed_assignment">
        <xs:annotation>
          <xs:documentation>
            Event for when a subordinate changes assignments without changing commander (object = source player/entity/subordinate/commander, param = subordinate, param2 = previous assignment, param3 = new assignment)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="subordinate" type="object" />
          <xs:attribute name="previous" type="assignmentexprlookup">
            <xs:annotation>
              <xs:documentation>
                Previous assignment
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="assignment" type="assignment" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_changed_subordinategroup">
        <xs:annotation>
          <xs:documentation>
            Event for when a subordinate changes subordinate groups (object = subordinate/commander, param = subordinate, param2 = previous group, param3 = new group)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="subordinate" type="object" />
          <xs:attribute name="previous" type="expression">
            <xs:annotation>
              <xs:documentation>
                Previous subordinate group
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="subordinategroupid" type="expression">
            <xs:annotation>
              <xs:documentation>
                New subordinate group
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_activated_weapon">
        <xs:annotation>
          <xs:documentation>
            Event for when a Controllable object activates a weapon (object = Controllable, param = Weapon, param2 = ammo type (null if unlimited), param3 = ammo amount (not set if unlimited))
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="weapon" type="weapon" />
          <xs:attribute name="ammo" type="expression">
            <xs:annotation>
              <xs:documentation>
                Ammo type macro
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="amount" type="expression">
            <xs:annotation>
              <xs:documentation>
                Ammo amount
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_deactivated_weapon">
        <xs:annotation>
          <xs:documentation>
            Event for when a Controllable object activates a weapon (object = Controllable, param = Weapon)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="weapon" type="weapon" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_activated_weapongroup">
        <xs:annotation>
          <xs:documentation>
            Event for when a Controllable object activates a weapon group (object = Controllable, param = weapongroup index, param2 = true for primary, false for secondary group)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="weapongroup" type="expression" />
          <xs:attribute name="primary" type="booleanexpression" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_deactivated_weapongroup">
        <xs:annotation>
          <xs:documentation>
            Event for when a Controllable object deactivates a weapon group (object = Controllable, param = weapongroup index, param2 = true for primary, false for secondary group)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="weapongroup" type="expression" />
          <xs:attribute name="primary" type="booleanexpression" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_destroyed">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object being destroyed (object = destroyed object, param = killer, param2 = kill method, param3 = was parent killed)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="killer" type="killer" />
          <xs:attribute name="method" type="killmethodlookup" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_docked">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object docking (object = docking object, param = dock object, param2 = zone)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="dock" type="container" />
          <xs:attribute name="zone" type="zone" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_docking_started">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object starting to dock (object = docking object, param = dock, param2 = zone)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="dock" type="container" />
          <xs:attribute name="zone" type="zone" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_docked_at">
        <xs:annotation>
          <xs:documentation>
            Event for an object docking at the specified container (object = container object, param = docking object, param2 = new context, param3 = old context)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="container" type="expression">
            <xs:annotation>
              <xs:documentation>
                Container object (station or ship, required if group attribute not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group" type="groupeventsource" />
          <xs:attribute name="check" type="checkeventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_started_to_dock_at">
        <xs:annotation>
          <xs:documentation>
            Event for an object starting to dock at the specified container (object = container object, param = docking object, param2 = new context, param3 = old context)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="container" type="expression">
            <xs:annotation>
              <xs:documentation>
                Container object (station or ship, required if group attribute not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group" type="groupeventsource" />
          <xs:attribute name="check" type="checkeventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_dock_assigned">
        <xs:annotation>
          <xs:documentation>
            If object is a ship: Event for the specified object getting a free docking bay assigned for docking (object = docking ship)
            If object is a docking bay: Event for the specified object getting a ship assigned to it (object = assigned docking bay)
            If object is the player entity: Event for the player's ship context getting a free docking bay assigned (object = player)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_dock_assigned_at">
        <xs:annotation>
          <xs:documentation>
            Event for a ship being assigned to a dock of the specified container (object = container object, param = dock, param2 = assigned ship)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_dock_unassigned">
        <xs:annotation>
          <xs:documentation>
            If object is a ship: Event for the specified object getting the dock unassigned for a docking bay (object = ship getting dock unassigned)
            If object is a docking bay: Event for the specified object getting a ship unassigned from it (object = unassigned docking bay)
            If object is the player entity: Event for the player's ship context getting the dock unassigned (object = player)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_dock_unassigned_from">
        <xs:annotation>
          <xs:documentation>
            Event for an unassigned dock of an object from the specified container (object = container object, param = dock unassigned object)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="container" type="expression">
            <xs:annotation>
              <xs:documentation>
                Container object (station or ship, required if group attribute not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group" type="groupeventsource" />
          <xs:attribute name="check" type="checkeventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_docking_denied">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object being denied docking (object = docking object, param = object that docking was requested at)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_docking_impossible">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object being incapable of docking (object = docking object, param = object that docking was requested at)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_dock_too_far">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object being too far from the docking target (object = docking object, param = object that docking was requested at)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_docking_queued">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object being put into the queue for a free docking bay (object = docking object)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_docking_aborted">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object having aborted a docking process (object = docking object, param = previously assigned docking bay)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_undocking_cleared">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object being cleared to undock (object = docked object)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_moved_into_internal_storage">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object having been moved into internal storage (object = stored object)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_retrieved_from_internal_storage">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object having been retrieved from internal storage (object = retrieved object)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_removed_from_formation">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object having been removed from a formation (object = removed object)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_formation_update_succeeded">
        <xs:annotation>
          <xs:documentation>
            Event for when a formation action for the specified object has been successfully performed (object = formation wingman and/or leader, depending on the formation action)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_formation_update_failed">
        <xs:annotation>
          <xs:documentation>
            Event for when a formation action for the specified object has failed to perform (object = formation wingman and/or leader, depending on the formation action)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_dropped_objects">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object dropping objects (object = dropping object, param = list of dropped objects)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_drops_found">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object finding drops on its Gravidar scanner (object = scanning object, param = list of drops found)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_enemy_found">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object finding an enemy on its Gravidar scanner (object = scanning object, param = enemy)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="enemy" type="container" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_entered_anomaly">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object entering an anomaly (object = entering object, param = entry anomaly, param2 = exit anomaly)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="entry" type="object" />
          <xs:attribute name="exit" type="object" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_venture_mission_started">
        <xs:annotation>
          <xs:documentation>
            Event for a venture mission being started (param = raw mission name)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="id" type="expression">
            <xs:annotation>
              <xs:documentation>
                Raw name of the venture
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_venture_mission_completed">
        <xs:annotation>
          <xs:documentation>
            Event for a venture mission being completed (param = venture detail list: [mission name, mission type, raw mission name, was mission successful], param2 = list of ships involved, param3 = duration)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_venture_ship_added">
        <xs:annotation>
          <xs:documentation>
            Event for when a venture ship is added to the universe or an existing ship becomes one (param = ship)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_venture_ship_removed">
        <xs:annotation>
          <xs:documentation>
            Event for when a venture ship is removed from the universe or an existing ship is no longer one (param = ship)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_entered_gate">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object entering a gate (object = entering object, param = entry gate, param2 = exit gate)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="entry" type="object" />
          <xs:attribute name="exit" type="object" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_entered_live_view">
        <xs:annotation>
          <xs:documentation>
            Event for when the object becomes visible on the gravidar of any player-owned object (object = entering object)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_left_live_view">
        <xs:annotation>
          <xs:documentation>
            Event for when the object is no longer visible on the gravidar of any player-owned object (object = leaving object)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_alert">
        <xs:annotation>
          <xs:documentation>
            Event for when a player alert is triggered (object = location (sector), param = alert message, param2 = sound id, param3 = object list)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="location" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Location (sector) in which the alert was raised
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_alert_level_changed">
        <xs:annotation>
          <xs:documentation>
            Event for when the alert level of an object changes (object = object changing the alert level, param = new alert level string, param2 = old alert level string)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="level">
            <xs:annotation>
              <xs:documentation>
                Alert level string
              </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:union memberTypes="expression">
                <xs:simpleType>
                  <xs:restriction base="expression">
                    <xs:enumeration value="'green'" />
                    <xs:enumeration value="'yellow'" />
                    <xs:enumeration value="'red'" />
                  </xs:restriction>
                </xs:simpleType>
              </xs:union>
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="previous">
            <xs:annotation>
              <xs:documentation>
                Previous alert level string
              </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:union memberTypes="expression">
                <xs:simpleType>
                  <xs:restriction base="expression">
                    <xs:enumeration value="'green'" />
                    <xs:enumeration value="'yellow'" />
                    <xs:enumeration value="'red'" />
                  </xs:restriction>
                </xs:simpleType>
              </xs:union>
            </xs:simpleType>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_traffic_level_changed">
        <xs:annotation>
          <xs:documentation>
            Event for when the traffic level of an object changes (object = object changing the traffic level, param = new traffic level string, param2 = old traffic level string)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="level">
            <xs:annotation>
              <xs:documentation>
                Traffic level string
              </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:union memberTypes="expression">
                <xs:simpleType>
                  <xs:restriction base="expression">
                    <xs:enumeration value="'normal'" />
                    <xs:enumeration value="'heavy'" />
                    <xs:enumeration value="'gridlock'" />
                  </xs:restriction>
                </xs:simpleType>
              </xs:union>
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="previous">
            <xs:annotation>
              <xs:documentation>
                Previous traffic level string
              </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:union memberTypes="expression">
                <xs:simpleType>
                  <xs:restriction base="expression">
                    <xs:enumeration value="'normal'" />
                    <xs:enumeration value="'heavy'" />
                    <xs:enumeration value="'gridlock'" />
                  </xs:restriction>
                </xs:simpleType>
              </xs:union>
            </xs:simpleType>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_incoming_missile">
        <xs:annotation>
          <xs:documentation>
            Event for when a missile is launched at the specified object (object = target object, param = target component, param2 = missile, param3 = missile source)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="target" type="targetcomponent" />
          <xs:attribute name="source" type="source" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_killed_object">
        <xs:annotation>
          <xs:documentation>
            Event for when the specified object kills an object/component (object = killer, param = killed object/component, param2 = kill method)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="killed" type="killedobject" />
          <xs:attribute name="method" type="killmethodlookup" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_launched_missile">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object launching a missile (object = missile launching object, param = target component, param2 = missile)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="target" type="targetcomponent" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_money_updated">
        <xs:annotation>
          <xs:documentation>
            Event for when the objects' money gets updated (object = container of the account, param = oldamount, param2 = newamount)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="oldamount" type="expression" />
          <xs:attribute name="newamount" type="expression" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_order_ready">
        <xs:annotation>
          <xs:documentation>
            Event for when an AI order in an object's order queue gets enabled (entering the ready state), when the default order gets enabled,
            or when there is a new current order that should be started, even if already enabled before (object = the object receiving the order, param = order)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="order" type="order" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_order_cancelled">
        <xs:annotation>
          <xs:documentation>
            Event for when the a running AI order is cancelled (object = the order's owner object, param = order, param2 = true iff the order is not in the critical state and is cancelled immediately).
            NOTE: If param2 is true then the order (event.param) was already cancelled and was either reset or does not exist any more.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="order" type="order" />
          <xs:attribute name="immediate" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Is the order cancelled immediately? This is true except for orders in the critical state.
                Orders in the critical state can handle cancel requests by listening to this event with immediate=&quot;false&quot;.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_order_finished">
        <xs:annotation>
          <xs:documentation>
            Event for when the running AI order is finished (object = the order's owner object, param = order).
            Note that it is possible that the order no longer exists.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="order" type="order" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_order_param_edited">
        <xs:annotation>
          <xs:documentation>
            Event for when a parameter of a running AI order in the critical state is edited (object = the order's owner object, param = order, param2 = order param name, param3 = order param value)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="order" type="order" />
          <xs:attribute name="name" type="expression">
            <xs:annotation>
              <xs:documentation>
                Order param name string
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="value" type="expression">
            <xs:annotation>
              <xs:documentation>
                New order param value
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_order_syncpoint_released">
        <xs:annotation>
          <xs:documentation>
            Event for when the sync point of an infinite AI order in an object's order queue gets released, indicating that the order should finish (object = the order's owner object, param = order)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="order" type="order" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_picked_up">
        <xs:annotation>
          <xs:documentation>
            Event for when the specified object is picked up by another object (object = pickup, param = collector)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="collector" type="object" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_picked_up_object">
        <xs:annotation>
          <xs:documentation>
            Event for when the specified object picks up another object (object = collector, param = pickup)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="pickup" type="object" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_signalled">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object being signalled (object = signalled object, param = custom, usually to specify type of signal, param2 = custom, param3 = custom)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="param" type="expression" />
          <xs:attribute name="param2" type="expression" />
          <xs:attribute name="param3" type="expression" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_subordinate_added">
        <xs:annotation>
          <xs:documentation>
            Event for when a new subordinate is added to a commander (object = new commander, param = subordinate, param2 = new assignment)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="subordinate" type="object" />
          <xs:attribute name="assignment" type="assignment" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_subordinate_promoted">
        <xs:annotation>
          <xs:documentation>
            Event for when a new subordinate is promoted in place of the old commander (object = old commander, param = promoted subordinate)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="subordinate" type="object" />
          <xs:attribute name="previous" type="expression">
            <xs:annotation>
              <xs:documentation>
                Previous commander
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_subordinate_removed">
        <xs:annotation>
          <xs:documentation>
            Event for when a subordinate is removed from a commander (object = old commander, param = subordinate, param2 = old commander)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="subordinate" type="object" />
          <xs:attribute name="previous" type="expression">
            <xs:annotation>
              <xs:documentation>
                Previous commander
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_target_invalid">
        <xs:annotation>
          <xs:documentation>
            Event for when an object's target is invalid, e.g. went through a jump gate, does not exist any more etc. (object = object with an invalid target, param = invalid target, param2 = true iff the target is actually not reachable)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="target" type="expression">
            <xs:annotation>
              <xs:documentation>
                Invalid target
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="unreachable" type="expression">
            <xs:annotation>
              <xs:documentation>
                Is the target unreachable?
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_undocked">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object undocking (object = undocking object, param = dock, param2 = zone)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="dock" type="container" />
          <xs:attribute name="zone" type="zone" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_undocking_started">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object starting to undock (object = undocking object, param = dock, param2 = zone)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="dock" type="container" />
          <xs:attribute name="zone" type="zone" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_undocked_from">
        <xs:annotation>
          <xs:documentation>
            Event for an object undocking from the specified container (object = container object, param = undocking object, param2 = new context, param3 = old context)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="container" type="expression">
            <xs:annotation>
              <xs:documentation>
                Container object (station or ship, required if group attribute not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group" type="groupeventsource" />
          <xs:attribute name="check" type="checkeventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_started_to_undock_from">
        <xs:annotation>
          <xs:documentation>
            Event for an object starting to undock from the specified container (object = container object, param = undocking object, param2 = new context, param3 = old context)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="container" type="expression">
            <xs:annotation>
              <xs:documentation>
                Container object (station or ship, required if group attribute not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group" type="groupeventsource" />
          <xs:attribute name="check" type="checkeventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_god_created_station">
        <xs:annotation>
          <xs:documentation>
            Event for god creating a station (object = containing space, param = station)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="space" type="expression">
            <xs:annotation>
              <xs:documentation>
                Space which contains the created station
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group" type="groupeventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_god_created_factory">
        <xs:annotation>
          <xs:documentation>
            Event for god creating a base factory with the modules to be constructed (object = containing space, param = station, param2 = list of module macros, param3 = base construction sequence)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="space" type="expression">
            <xs:annotation>
              <xs:documentation>
                Space which contains the created factory
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group" type="groupeventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_god_created_object">
        <xs:annotation>
          <xs:documentation>
            Event for god creating an object (object = containing space, param = object)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="space" type="expression">
            <xs:annotation>
              <xs:documentation>
                Space which contains the created object
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group" type="groupeventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_weaponmode_changed">
        <xs:annotation>
          <xs:documentation>
            Event for the specified object changing a weapon mode (object = object changing the weapon mode, param = weapon, param2 = new weapon mode)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="weapon" type="weapon">
            <xs:annotation>
              <xs:documentation>
                Weapon for which the mode will be changed (optional)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="weaponmode" type="extendedweaponmodelookup">
            <xs:annotation>
              <xs:documentation>
                New weapon mode in which the weapon will be changed (optional)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_entered">
        <xs:annotation>
          <xs:documentation>
            Event on an object or a space, e.g. zone, for when any object enters it or is created in it (object = entered space/container, param = entering object, param2 = new context of entering object, param3 = old context of entering object).
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="space" type="expression">
            <xs:annotation>
              <xs:documentation>
                Space which is entered (i.e. zone, sector or cluster), or direct container context which is entered (ship or station)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group" type="groupeventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_left">
        <xs:annotation>
          <xs:documentation>
            Event on an object or a space, e.g. zone, for when any object leaves it or is removed (object = left space/container, param = leaving object, param2 = new context of leaving object, param3 = old context of leaving object).
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="space" type="expression">
            <xs:annotation>
              <xs:documentation>
                Space which is left (i.e. zone, sector or cluster), or direct container context which is left (ship or station)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group" type="groupeventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_entity_entered">
        <xs:annotation>
          <xs:documentation>
            Event on an object or a space, e.g. zone, for when any entity enters it or is created in it (object = entered space/room/container, param = entering entity, param2 = new context of entering entity, param3 = old context of entering entity).
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="space" type="expression">
            <xs:annotation>
              <xs:documentation>
                Space or room which is entered (i.e. room, zone, sector or cluster), or direct container context which is entered (ship or station)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group" type="groupeventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_entity_left">
        <xs:annotation>
          <xs:documentation>
            Event on an object or a space, e.g. zone, for when any entity leaves it or is removed (object = left space/room/container, param = leaving entity, param2 = new context of leaving entity, param3 = old context of leaving entity).
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="space" type="expression">
            <xs:annotation>
              <xs:documentation>
                Space or room which is left (i.e. room, zone, sector or cluster), or direct container context which is left (ship or station)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group" type="groupeventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_bomb_attached">
        <xs:annotation>
          <xs:documentation>
            Event is raised when a bomb has been successfully attached to a target - if you want to listen to it being detached, use event_object_killed with killmethod.detached (object = target that the bomb is attached to, param = bomb that was attached)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="bomb" type="object" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_attacked_object">
        <xs:annotation>
          <xs:documentation>
            Event for when the player attacks an object from their currently controlled object (param = attacked object, param2 = kill method, param3 = [attacked component, weapon])
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="attacked" type="attackedobject" />
          <xs:attribute name="method" type="killmethodlookup" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_boost_charging_aborted">
        <xs:annotation>
          <xs:documentation>
            Event for when the player aborts charging boost
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_boost_charging_started">
        <xs:annotation>
          <xs:documentation>
            Event for when the player starts charging boost
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_boost_started">
        <xs:annotation>
          <xs:documentation>
            Event for when the player starts boosting
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_boost_stopped">
        <xs:annotation>
          <xs:documentation>
            Event for when the player stops boosting
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_build_plot_changed">
        <xs:annotation>
          <xs:documentation>
            Event for when a player-owned station's build plot is resized or repositioned (param = station, param2 = old build plot max, param3 = old build plot center)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="station" type="expression">
            <xs:annotation>
              <xs:documentation>
                Station for which build plot changed
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_paid_build_plot_changed">
        <xs:annotation>
          <xs:documentation>
            Event for when a player-owned station's paid build plot is resized or repositioned (param = station, param2 = old paid build plot size)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="station" type="expression">
            <xs:annotation>
              <xs:documentation>
                Station for which build plot changed
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_build_started">
        <xs:annotation>
          <xs:documentation>
            Event for when a player-owned build starts (param = buildprocessor, param2 = constructionsequence, param3 = buildtask)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="buildprocessor" type="buildprocessor" />
          <xs:attribute name="build" type="build"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_build_finished">
        <xs:annotation>
          <xs:documentation>
            Event for when a player-owned build finishes (param = buildprocessor, param2 = unused, param3 = buildtask)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="buildprocessor" type="buildprocessor" />
          <xs:attribute name="build" type="build"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_build_finished_components">
        <xs:annotation>
          <xs:documentation>
            Event for when a player-owned build partially finishes. List of completed components is provided. (param = buildprocessor, param2 = list of completed components, param3 = buildtask)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="buildprocessor" type="buildprocessor" />
          <xs:attribute name="build" type="build"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_build_cancelled">
        <xs:annotation>
          <xs:documentation>
            Event for when a player-owned build is cancelled (param = buildprocessor, param2 = constructionsequence, param3 = buildtask)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="buildprocessor" type="buildprocessor" />
          <xs:attribute name="build" type="build"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_built_ship">
        <xs:annotation>
          <xs:documentation>
            Event for when a player-owned ship is constructed to operational state (param = ship, param2 = buildtask)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_built_station">
        <xs:annotation>
          <xs:documentation>
            Event for when a player-owned station is constructed to operational state (param = station, param2 = buildtask)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_build_loadout_applied">
        <xs:annotation>
          <xs:documentation>
            Event for when a player-owned build has applied a loadout to the build component. List of added components is provided. (param = buildprocessor, param2 = new components, param3 = buildtask)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="buildprocessor" type="buildprocessor" />
          <xs:attribute name="build" type="build"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_production_started">
        <xs:annotation>
          <xs:documentation>
            Event for when a player-owned productionmodule has started production of a ware (param = productionmodule, param2 = product ware, param3 = whether this is a research project) (see also event_player_production_finished)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="productionmodule" type="productionmodule" use="optional" />
          <xs:attribute name="ware" type="ware" use="optional" />
          <xs:attribute name="research" type="booleanexpression" use="optional" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_production_finished">
        <xs:annotation>
          <xs:documentation>
            Event for when a player-owned productionmodule has finished production of a ware (param = productionmodule, param2 = product ware, param3 = whether this was a research project) (see also event_player_production_started)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="productionmodule" type="productionmodule" use="optional" />
          <xs:attribute name="ware" type="ware" use="optional" />
          <xs:attribute name="research" type="booleanexpression" use="optional" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_production_cancelled">
        <xs:annotation>
          <xs:documentation>
            Event for when a player-owned productionmodule has cancelled its production queue (param = productionmodule, param2 = whether a research project was cancelled, param3 = list of cancelled product wares)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="productionmodule" type="productionmodule" use="optional" />
          <xs:attribute name="research" type="booleanexpression" use="optional" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_changed_activity">
        <xs:annotation>
          <xs:documentation>
            Event for when the player changes activity (param = new activity, param2 = old activity)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="activity" type="activityexprlookup" />
          <xs:attribute name="oldactivity" type="activityexprlookup" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_changed_target">
        <xs:annotation>
          <xs:documentation>
            Event for when the player changes target (param = new target. null if player deselects target.)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="target" type="object" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_interaction">
        <xs:annotation>
          <xs:documentation>
            Event for when a player responds to an interactive notification (param = interaction param, param2 = secondary interaction param)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="param" type="expression">
            <xs:annotation>
              <xs:documentation>
                Interaction parameter
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="param2" type="expression">
            <xs:annotation>
              <xs:documentation>
                Secondary interaction parameter
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_teleport_successful">
        <xs:annotation>
          <xs:documentation>
            Event for when the player successfully teleports. (param = new room, param2 = old room, param3 = is shortcut instead of real teleport)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="room" type="room" />
          <xs:attribute name="previous" type="room" />
          <xs:attribute name="shortcut" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Is this a shortcut instead of a real teleport?
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_teleport_failed">
        <xs:annotation>
          <xs:documentation>
            Event for when the player failed to teleport. (param = destination room, param2 = is shortcut instead of real teleport)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="destination" type="room" />
          <xs:attribute name="shortcut" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Is this a shortcut instead of a real teleport?
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_ejected">
        <xs:annotation>
          <xs:documentation>
            Player was emergency ejected from ship.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_owned_attacked">
        <xs:annotation>
          <xs:documentation>
            Event for when a player owned object is attacked (object = attacked object, param = attacker, param2 = kill method, param3 = attacked component)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="attacker" type="attacker" />
          <xs:attribute name="method" type="killmethodlookup" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_owned_attacked_object">
        <xs:annotation>
          <xs:documentation>
            Event for when a player owned object, including the player, attacks another object (param = attacker, param2 = attacked object, param3 = kill method)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="attacker" type="attacker" />
          <xs:attribute name="attacked" type="attackedobject" />
          <xs:attribute name="method" type="killmethodlookup" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_owned_claimed_object">
        <xs:annotation>
          <xs:documentation>
            Event for when the player faction claims an object (param = claimed object, param2 = pilot)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="claimed" type="object" />
          <xs:attribute name="pilot" type="entity" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_ship_hit">
        <xs:annotation>
          <xs:documentation>
            Event for when the player controlled ship or ship context is hit by a projectile (param = attacked object, param2 = attacker, param3 = projectile)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="attacked" type="attackedobject" />
          <xs:attribute name="attacker" type="attacker" />
          <xs:attribute name="projectile" type="object" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_collected_ammo">
        <xs:annotation>
          <xs:documentation>
            Event for when the player collects ammo (param = weapon macro, param2 = amount)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="macro" type="macro" />
          <xs:attribute name="amount" type="expression">
            <xs:annotation>
              <xs:documentation>
                Ammo amount
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_crafted_ammo">
        <xs:annotation>
          <xs:documentation>
            Event for when the player crafts ammo from inventory wares (param = weapon macro, param2 = amount)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="macro" type="macro" />
          <xs:attribute name="amount" type="expression">
            <xs:annotation>
              <xs:documentation>
                Ammo amount
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_collected_powerup">
        <xs:annotation>
          <xs:documentation>
            Event for when the player collects a powerup
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_collected_ware">
        <xs:annotation>
          <xs:documentation>
            Event for when the player collects a ware drop (param = ware, param2 = amount, param3 = collected object)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="ware" type="ware" />
          <xs:attribute name="amount" type="expression">
            <xs:annotation>
              <xs:documentation>
                Ware amount
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="collected" type="object" >
            <xs:annotation>
              <xs:documentation>
                The collected object
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_commission_added" type="event_playerpricemodifier">
        <xs:annotation>
          <xs:documentation>
            Event for when a commission for the player is added (object = source object or source faction, param = display name, param2 = commission amount, param3 = end time)
          </xs:documentation>
        </xs:annotation>
      </xs:element>

      <xs:element name="event_player_discount_added" type="event_playerpricemodifier">
        <xs:annotation>
          <xs:documentation>
            Event for when a discount for the player is added (object = source object or source faction, param = display name, param2 = discount amount, param3 = end time)
          </xs:documentation>
        </xs:annotation>
      </xs:element>

      <xs:element name="event_player_activated_weapon">
        <xs:annotation>
          <xs:documentation>
            Event for when the player ship activates a weapon (param = Weapon, param2 = ammo type (null if unlimited), param3 = ammo amount (not set if unlimited))
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="weapon" type="weapon" />
          <xs:attribute name="ammo" type="expression">
            <xs:annotation>
              <xs:documentation>
                Ammo type macro
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="amount" type="expression">
            <xs:annotation>
              <xs:documentation>
                Ammo amount
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_deactivated_weapon">
        <xs:annotation>
          <xs:documentation>
            Event for when the player ship deactivates a weapon (param = Weapon)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="weapon" type="weapon" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_activated_weapongroup">
        <xs:annotation>
          <xs:documentation>
            Event for when the player ship activates a weapon group (param = weapongroup index, param2 = true for primary, false for secondary group)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="weapongroup" type="expression" />
          <xs:attribute name="primary" type="booleanexpression" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_deactivated_weapongroup">
        <xs:annotation>
          <xs:documentation>
            Event for when the player ship deactivates a weapon group (param = weapongroup index, param2 = true for primary, false for secondary group)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="weapongroup" type="expression" />
          <xs:attribute name="primary" type="booleanexpression" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_created">
        <xs:annotation>
          <xs:documentation>
            Event for when the player is created (no parameters)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_discovered_object">
        <xs:annotation>
          <xs:documentation>
            Event for when an object (station module, station, ship, ...) is discovered or scanned by the player and added to the scan memory (param = object, param2 = scan level)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="object" type="object" />
          <xs:attribute name="level" type="expression">
            <xs:annotation>
              <xs:documentation>
                Scan level (0 if object was discovered, positive if object was actively scanned)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_detected_object">
        <xs:annotation>
          <xs:documentation>
            Event for when an object is detected by the player and added to the long range scan memory (param = object)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="object" type="object" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_discovered_mission_offer">
        <xs:annotation>
          <xs:documentation>
            Event for when a mission offer is discovered by the player and added to the mission offer memory (param = mission offer cue)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="cue" type="expression">
            <xs:annotation>
              <xs:documentation>
                Mission offer MD cue
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_hacked_object">
        <xs:annotation>
          <xs:documentation>
            Event for when an object is hacked by the player (param = hacked, param2 = hacker, param3 = control panel type)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_incoming_missile">
        <xs:annotation>
          <xs:documentation>
            Event for when a missile is launched at the player (param = target component, param2 = missile, param3 = missile source)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="target" type="targetcomponent" />
          <xs:attribute name="source" type="source" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_killed_object">
        <xs:annotation>
          <xs:documentation>
            Event for when the player kills an object from their currently controlled object (param = killed object, param2 = kill method)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="killed" type="killedobject" />
          <xs:attribute name="method" type="killmethodlookup" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_launched_missile">
        <xs:annotation>
          <xs:documentation>
            Event for when the player launches a missile (param = target component, param2 = missile)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="target" type="targetcomponent" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_licence_added">
        <xs:annotation>
          <xs:documentation>
            Event for when the player is granted a licence for another faction (param = licenceref, use .type or .faction)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="faction" type="faction" />
          <xs:attribute name="licence" type="licencelookup" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_licence_lost">
        <xs:annotation>
          <xs:documentation>
            Event for when the player has lost a licence for another faction (param = licenceref, use .type or .faction)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="faction" type="faction" />
          <xs:attribute name="licence" type="licencelookup" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_money_updated">
        <xs:annotation>
          <xs:documentation>
            Event for when the player money gets updated (param = oldamount, param2 = newamount)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="oldamount" type="expression" />
          <xs:attribute name="newamount" type="expression" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_owned_collected_resource">
        <xs:annotation>
          <xs:documentation>
            Event for when a player owned object has collected a resource (object = collecting object, param = ware, param2 = amount)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="ware" type="ware" />
          <xs:attribute name="amount" type="expression">
            <xs:annotation>
              <xs:documentation>
                Ware amount
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_owned_destroyed">
        <xs:annotation>
          <xs:documentation>
            Event for when a player owned object was killed (param = killed object, param2 = killer object, param3 = kill method)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="killed" type="killedobject" />
          <xs:attribute name="killer" type="killer" />
          <xs:attribute name="method" type="killmethodlookup" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_owned_killed_object">
        <xs:annotation>
          <xs:documentation>
            Event for when a player owned object, including player, kills an object (param = killer object, param2 = killed object, param3 = kill method)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="killer" type="killer" />
          <xs:attribute name="killed" type="killedobject" />
          <xs:attribute name="method" type="killmethodlookup" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_owned_money_updated">
        <xs:annotation>
          <xs:documentation>
            Event for when a player-owned object's money gets updated (object = account holder, param = oldamount, param2 = newamount)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="oldamount" type="expression" />
          <xs:attribute name="newamount" type="expression" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_opened_crate">
        <xs:annotation>
          <xs:documentation>
            Event for when the player opens a crate and claims all its content (param = crate)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="crate" type="crate" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_out_of_ammo">
        <xs:annotation>
          <xs:documentation>
            Event for when the player's current weapon runs out of ammo (param = weapon macro, param2 = ranout of ammo due to the shot)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="macro" type="macro" />
          <xs:attribute name="ranout" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                When true, then we fired and ran out of ammo, otherwise we didn't have ammo in the first place.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_relation_changed">
        <xs:annotation>
          <xs:documentation>
            Event for when a faction or an object's control entity changes the relation towards the player (object = entity or null, param = faction or null, param2 = [new relation, old relation], param3 = relationchangereason).
            NOTE: On permanent faction changes, object is null. On relation boosts, object is non-null, and param is either null (silent boost) or faction.player (non-silent boost).
            See &lt;set_relation_boost&gt; and &lt;add_relation_boost&gt;.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="faction" type="faction" />
          <xs:attribute name="reason" type="relationchangereasonlookup">
            <xs:annotation>
              <xs:documentation>
                The reason for relationship change
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_started_control">
        <xs:annotation>
          <xs:documentation>
            Event for when the player starts control
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_stopped_control">
        <xs:annotation>
          <xs:documentation>
            Event for when the player stops control
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_subordinate_added">
        <xs:annotation>
          <xs:documentation>
            Event for when the player adds a new subordinate to squad (param = subordinate, param2 = new assignment)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="subordinate" type="object" />
          <xs:attribute name="assignment" type="assignment" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_subordinate_promoted">
        <xs:annotation>
          <xs:documentation>
            Event for when a subordinate of the player's current ship is promoted in place of the old commander (param = old commander, param2 = promoted subordinate)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="subordinate" type="object" />
          <xs:attribute name="previous" type="expression">
            <xs:annotation>
              <xs:documentation>
                Previous commander
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_subordinate_removed">
        <xs:annotation>
          <xs:documentation>
            Event for when the player removes a subordinate from squad (param = subordinate, param2 = old commander)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="subordinate" type="object" />
          <xs:attribute name="previous" type="expression">
            <xs:annotation>
              <xs:documentation>
                Previous commander
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_trade_discovered">
        <xs:annotation>
          <xs:documentation>
            Event for when a trade is discovered by the player and added to the trade memory (param = tradeoffer)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="trade" type="tradeoffer" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_trade_cancelled">
        <xs:annotation>
          <xs:documentation>
            Event for when a player trade is cancelled (param = tradeoffer)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchtradeoffervalues">
              <xs:attributeGroup ref="eventcondition" />
              <xs:attribute name="buyer" type="buyer" />
              <xs:attribute name="seller" type="seller" />
              <xs:attribute name="tradeoffer" type="eventtradeoffer" />
              <xs:attribute name="ware" type="ware" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_trade_completed">
        <xs:annotation>
          <xs:documentation>
            Event for when the player completes a trade (param = tradeoffer)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchtradeoffervalues">
              <xs:attributeGroup ref="eventcondition" />
              <xs:attribute name="buyer" type="buyer" />
              <xs:attribute name="seller" type="seller" />
              <xs:attribute name="tradeoffer" type="eventtradeoffer" />
              <xs:attribute name="ware" type="ware" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_trade_started">
        <xs:annotation>
          <xs:documentation>
            Event for when the player starts a trade (param = tradeoffer)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchtradeoffervalues">
              <xs:attributeGroup ref="eventcondition" />
              <xs:attribute name="buyer" type="buyer" />
              <xs:attribute name="seller" type="seller" />
              <xs:attribute name="tradeoffer" type="eventtradeoffer" />
              <xs:attribute name="ware" type="ware" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_lost_volatile_wares">
        <xs:annotation>
          <xs:documentation>
            Event for when volatile wares in the player's inventory self-destruct (param = table of lost volatile wares with corresponding amounts)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_travelmode_charge_started">
        <xs:annotation>
          <xs:documentation>
            Event is raised when the player ship travel mode begins charging (param = time when the mode is fully charged)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_travelmode_charge_aborted">
        <xs:annotation>
          <xs:documentation>
            Event is raised when the player ship travel mode aborts an ongoing charging process
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_travelmode_started">
        <xs:annotation>
          <xs:documentation>
            Event is raised when the player ship travel mode is done charging
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_travelmode_stopped">
        <xs:annotation>
          <xs:documentation>
            Event is raised when the player ship travel mode has stopped
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_signal_unlock_started">
        <xs:annotation>
          <xs:documentation>
            Event is raised when the player begins unlocking a signal leak (param = signal leak being unlocked)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="signal" type="signalleak" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_signal_unlock_failed">
        <xs:annotation>
          <xs:documentation>
            Event is raised when the player fails to unlock a signal leak (param = signal leak being unlocked)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="signal" type="signalleak" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_signal_unlock_finished">
        <xs:annotation>
          <xs:documentation>
            Event is raised when the player has successfully unlock a signal leak (param = signal leak being unlocked, param2 = object that the signal leak was attached to)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="signal" type="signalleak" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_signal_unlock_impossible">
        <xs:annotation>
          <xs:documentation>
            Event is raised when the player is not currently able to unlock a signal leak (param = signal leak being unlocked)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="signal" type="signalleak" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_repaired_signal_leak">
        <xs:annotation>
          <xs:documentation>
            Event is raised when the player has repaired a signal leak (param = signal leak that was repaired, param2 = object that the signal leak was attached to)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="signal" type="signalleak" />
          <xs:attribute name="parent" type="signalleak" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_repaired_object">
        <xs:annotation>
          <xs:documentation>
            Event is raised when the player has repaired an object (param = destructible that was repaired (can be the object), param2 = object that the destructible was attached to)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="destructible" type="destructible" />
          <xs:attribute name="object" type="object" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_unlocked_platform_trigger">
        <xs:annotation>
          <xs:documentation>
            Event is raised when the player has successfully unlocked a platform trigger (e.g. a button, panel, door) that required wares to be consumed in order to activate (param = trigger component, param2 = trigger group tag)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="component" type="object" />
          <xs:attribute name="group" type="expression" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_activated_platform_trigger">
        <xs:annotation>
          <xs:documentation>
            Event is raised when the player has manually activated a platform trigger (e.g. a button or panel) (param = trigger component, param2 = trigger group tag)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="component" type="object" />
          <xs:attribute name="group" type="expression" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_deactivated_platform_trigger">
        <xs:annotation>
          <xs:documentation>
            Event is raised when the player has manually deactivated a platform trigger (e.g. a button or panel) (param = trigger component, param2 = trigger group tag)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="component" type="object" />
          <xs:attribute name="group" type="expression" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_bomb_attached">
        <xs:annotation>
          <xs:documentation>
            Event is raised when the player or a player-owned object has successfully attached a bomb (param = bomb that was attached)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="bomb" type="object" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_blueprint_added">
        <xs:annotation>
          <xs:documentation>
            Event is raised when the player has unlocked a blueprint (param = blueprint's module macro, param2 = blueprint's ware)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="macro" type="macro" />
          <xs:attribute name="ware" type="ware" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_created_signal_leaks">
        <xs:annotation>
          <xs:documentation>
            Event is raised when the player has created signal leaks (param = list of signal leaks)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_entered_anomaly">
        <xs:annotation>
          <xs:documentation>
            Event for the player entering an anomaly (param = entry anomaly, param2 = exit anomaly)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="entry" type="object" />
          <xs:attribute name="exit" type="object" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_entered_gate">
        <xs:annotation>
          <xs:documentation>
            Event for the player entering a gate (param = entry gate, param2 = exit gate)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="entry" type="object" />
          <xs:attribute name="exit" type="object" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_activated_cockpit_view">
        <xs:annotation>
          <xs:documentation>
            Event for the player setting the camera to cockpit view (also triggered if the camera was already in this view)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_activated_external_view">
        <xs:annotation>
          <xs:documentation>
            Event for the player setting the camera to external view (also triggered if the camera was already in this view)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_activated_external_target_view">
        <xs:annotation>
          <xs:documentation>
            Event for the player setting the camera to external target view (also triggered if the camera was already in this view)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_activated_floating_view">
        <xs:annotation>
          <xs:documentation>
            Event for the player setting the camera to floating view (also triggered if the camera was already in this view)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_toggled_hud">
        <xs:annotation>
          <xs:documentation>
            Event for the player toggling HUD rendering
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_toggled_cockpit">
        <xs:annotation>
          <xs:documentation>
            Event for the player toggling cockpit rendering
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_cycled_active_weapon_ammo">
        <xs:annotation>
          <xs:documentation>
            Event for the player cycling the ammunition of active weapons
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_fired_empty_weapon_group">
        <xs:annotation>
          <xs:documentation>
            Event for the player attempting to fire a weapon group that has no active weapons in it (param = true if it's a primary, false if it's a secondary weapon group)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="primary" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Event filter for whether the weapon group being fired was a primary (true) or secondary (false) one
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_player_assigned_hired_actor">
        <xs:annotation>
          <xs:documentation>
            Event for when the player assigns an actor (entity or template) to a control post or a role (param = actor (entity or list containing context and template), param2 = target object, param3 = post or role).
            NOTE: The actual assignment happens as a result of this event.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="actor" type="genericactor" />
          <xs:attribute name="target" type="targetobject" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_autopilot_target_set">
        <xs:annotation>
          <xs:documentation>
            Event for when the player has engaged the autopilot (param = target, param2 = next target on the way to target which may be identical to target)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="target" type="object" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_game_loaded">
        <xs:annotation>
          <xs:documentation>
            Event for when the game has completed loading a savegame (param = gameversion, param2 = build number, param3 = original gameversion of savegame)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="version">
            <xs:annotation>
              <xs:documentation>
                Game version number of the loaded save, multiplied by 100. e.g. 251 for version 2.51
              </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:restriction base="xs:integer">
                <xs:minInclusive value="1" />
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="build">
            <xs:annotation>
              <xs:documentation>
                Build number of the loaded save, e.g. 187332
              </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:restriction base="xs:integer">
                <xs:minInclusive value="1" />
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="originalversion">
            <xs:annotation>
              <xs:documentation>
                Game version number this save was started with, multiplied by 100. e.g. 125 for version 1.25
              </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:restriction base="xs:integer">
                <xs:minInclusive value="1" />
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_game_saved">
        <xs:annotation>
          <xs:documentation>
            Event for when the game has completed saving a savegame (param = success)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="success" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Event filter for whether saving was successful
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_game_started">
        <xs:annotation>
          <xs:documentation>
            Event for when a new game has been started and the universe populated (param = list of selected gamestart options)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_scan_aborted">
        <xs:annotation>
          <xs:documentation>
            Event for when a (deep)scan is aborted (requires attribute scanner and/or scanned) (object = scanner if supplied, otherwise scanned, param = the other object, param2 = true iff object is scanner)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="scanned" type="scannedrequired" />
          <xs:attribute name="scanner" type="scannerrequired" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_scan_finished">
        <xs:annotation>
          <xs:documentation>
            Event for when a (deep)scan is finished (requires attribute scanner and/or scanned) (object = scanner if supplied, otherwise scanned, param = the other object, param2 = true iff object is scanner)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="scanned" type="scannedrequired" />
          <xs:attribute name="scanner" type="scannerrequired" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_scan_started">
        <xs:annotation>
          <xs:documentation>
            Event for when a (deep)scan is started (requires attribute scanner and/or scanned) (object = scanner if supplied, otherwise scanned, param = the other object, param2 = true iff object is scanner)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="scanned" type="scannedrequired" />
          <xs:attribute name="scanner" type="scannerrequired" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_hacked">
        <xs:annotation>
          <xs:documentation>
            Event for when an object is hacked (requires attribute hacker and/or hacked) (object = hacker if supplied, otherwise hacked, param = the other object, param2 = true iff object is hacker)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="hacked" type="hackedrequired" />
          <xs:attribute name="hacker" type="hackerrequired" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_observation_started">
        <xs:annotation>
          <xs:documentation>
            Event for when an object starts an observation (requires attribute observer and/or observed) (object = observer or observed, param = observer, param2 = observed, param3 = range length)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="observed" type="observedrequired" />
          <xs:attribute name="observer" type="observerrequired" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_observation_stopped">
        <xs:annotation>
          <xs:documentation>
            Event for when an observation is stopped (requires attribute observer and/or observed) (object = observer or observed, param = observer, param2 = observed)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="observed" type="observedrequired" />
          <xs:attribute name="observer" type="observerrequired" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_attack_started">
        <xs:annotation>
          <xs:documentation>
            Event for when an object signals it will attack a target (requires attribute attacker and/or target) (object = attacker or target, param = attacker, param2 = target)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="attacker" type="attackerrequired" />
          <xs:attribute name="target" type="attackedrequired" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_attack_stopped">
        <xs:annotation>
          <xs:documentation>
            Event for when an object signals it will stop an attack (requires attribute attacker and/or target) (object = attacker or target, param = attacker, param2 = target)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="attacker" type="attackerrequired" />
          <xs:attribute name="target" type="attackedrequired" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_speak_finished">
        <xs:annotation>
          <xs:documentation>
            Event for when an actor has finished speaking (object = actor, param = page, param2 = line, param3 = interrupted - 0 if fully finished, 1 if interrupted, 2 if not even started).
            NOTE: The page and line parameters match the text entry that was passed to the speak system before resolving any text references. The event is fired even if the speak fails due to
            priority being too low or if it is interrupted. In case of a sequence of multiple text entries, page and line match the first provided page/line pair, not the last one.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="actor" type="actor" />
          <xs:attribute name="page" type="page" />
          <xs:attribute name="line" type="line" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_speak_line_finished">
        <xs:annotation>
          <xs:documentation>
            Event for when an actor has finished speaking a single text line, possibly a part of a speech with multiple lines (object = actor, param = page, param2 = line).
            NOTE: Unlike &lt;event_speak_finished&gt;, this event requires the actor to be specified, and the parameters page and line match the exact spoken text entry after the resolution of text references.
            WARNING: The event is not fired if the speech cannot start or if it gets interrupted before the end of the line. Combine with &lt;event_speak_finished&gt; in a &lt;check_any&gt; block to handle those cases as well.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="actor" type="actor" use="required" />
          <xs:attribute name="check" type="checkeventsource" />
          <xs:attribute name="page" type="page" />
          <xs:attribute name="line" type="line" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_trade_cancelled">
        <xs:annotation>
          <xs:documentation>
            Event for when a trade is cancelled, (object = either buyer or seller - see following documentation, param = tradeoffer) (If tradeoffer is provided, listened object = tradeoffer owner) : (otherwise buyer and/or seller must be provided, listened object = seller if supplied, otherwise buyer)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchtradeoffervalues">
              <xs:attributeGroup ref="eventcondition" />
              <xs:attribute name="buyer" type="buyer" />
              <xs:attribute name="seller" type="seller" />
              <xs:attribute name="tradeoffer" type="eventtradeoffer" />
              <xs:attribute name="ware" type="ware" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_trade_completed">
        <xs:annotation>
          <xs:documentation>
            Event for when a trade is completed (object = either buyer or seller - see following documentation, param = tradeoffer, param2 = tradeorder) (If tradeoffer is provided, listened object = tradeoffer owner) : (otherwise buyer and/or seller must be provided, listened object = seller if supplied, otherwise buyer)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchtradeoffervalues">
              <xs:attributeGroup ref="eventcondition" />
              <xs:attribute name="buyer" type="buyer" />
              <xs:attribute name="seller" type="seller" />
              <xs:attribute name="tradeoffer" type="eventtradeoffer" />
              <xs:attribute name="ware" type="ware" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_trade_started">
        <xs:annotation>
          <xs:documentation>
            Event for when a trade is started (object = either buyer or seller - see following documentation, param = tradeoffer, param2 = tradeorder) (If tradeoffer is provided, listened object = tradeoffer owner) : (otherwise buyer and/or seller must be provided, listened object = seller if supplied, otherwise buyer)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchtradeoffervalues">
              <xs:attributeGroup ref="eventcondition" />
              <xs:attribute name="buyer" type="buyer" />
              <xs:attribute name="seller" type="seller" />
              <xs:attribute name="tradeoffer" type="eventtradeoffer" />
              <xs:attribute name="ware" type="ware" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_detached_from_masstraffic">
        <xs:annotation>
          <xs:documentation>
            Event for when an object has been detached from all mass traffic networks that restrict its movement (object = detached object)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_masstraffic_network_removed">
        <xs:annotation>
          <xs:documentation>
            Event for when a mass traffic network has been removed (object = the zone that owned the network, param = the removed network's ID)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="zone" type="zone" use="required" />
          <xs:attribute name="network" type="masstraffic" />
          <xs:attribute name="check" type="checkeventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_weapon_fired">
        <xs:annotation>
          <xs:documentation>
            Event for the specified weapon firing (object = the weapon, param = fired bullet/missile/bomb)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_weapon_overheated">
        <xs:annotation>
          <xs:documentation>
            Event for the specified weapon overheating (object = the weapon)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_launched_countermeasure">
        <xs:annotation>
          <xs:documentation>
            Event for an object launching a countermeasure (object = the launching defensible, param = launched countermeasure)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_launched_mine">
        <xs:annotation>
          <xs:documentation>
            Event for an object launching a mine (object = the launching defensible, param = launched mine)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_launched_lasertower">
        <xs:annotation>
          <xs:documentation>
            Event for an object launching a lasertower (object = the launching defensible, param = launched lasertower)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_lasertower_launched">
        <xs:annotation>
          <xs:documentation>
            Event for lasertower being launched (object = the space which the laser tower was launched in, param = the launching defensible, param2 = launched lasertower)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="space" type="expression">
            <xs:annotation>
              <xs:documentation>
                Space which the lasertower was launched in
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group" type="groupeventsource" />
          <xs:attribute name="launcher" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                The object which launched the lasertower
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_mine_launched">
        <xs:annotation>
          <xs:documentation>
            Event for mine being launched (object = the space which the mine was launched in, param = the launching defensible, param2 = launched mine)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="space" type="expression">
            <xs:annotation>
              <xs:documentation>
                Space which the mine was launched in
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group" type="groupeventsource" />
          <xs:attribute name="launcher" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                The object which launched the mine
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_launched_navbeacon">
        <xs:annotation>
          <xs:documentation>
            Event for an object launching a navigation beacon (object = the launching defensible, param = launched navigation beacon)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_navbeacon_launched">
        <xs:annotation>
          <xs:documentation>
            Event for navbeacon being launched (object = the space which the navbeacon was launched in, param = the launching defensible, param2 = launched navbeacon)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="space" type="expression">
            <xs:annotation>
              <xs:documentation>
                Space which the navbeacon was launched in
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group" type="groupeventsource" />
          <xs:attribute name="launcher" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                The object which launched the navbeacon
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_launched_satellite">
        <xs:annotation>
          <xs:documentation>
            Event for an object launching a satellite (object = the launching defensible, param = launched satellite)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_satellite_launched">
        <xs:annotation>
          <xs:documentation>
            Event for satellite being launched (object = the space which the satellite was launched in, param = the launching defensible, param2 = launched satellite)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="space" type="expression">
            <xs:annotation>
              <xs:documentation>
                Space which the satellite was launched in
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group" type="groupeventsource" />
          <xs:attribute name="launcher" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                The object which launched the satellite
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_launched_resourceprobe">
        <xs:annotation>
          <xs:documentation>
            Event for an object launching a resourceprobe (object = the launching defensible, param = launched resourceprobe)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_resourceprobe_launched">
        <xs:annotation>
          <xs:documentation>
            Event for resourceprobe being launched (object = the space which the resource probe was launched in, param = the launching defensible, param2 = launched resourceprobe)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="space" type="expression">
            <xs:annotation>
              <xs:documentation>
                Space which the resourceprobe was launched in
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group" type="groupeventsource" />
          <xs:attribute name="launcher" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                The object which launched the resourceprobe
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_launched_distressdrone">
        <xs:annotation>
          <xs:documentation>
            Event for an object launching a distress drone (object = the launching defensible, param = launched distress drone)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_distressdrone_launched">
        <xs:annotation>
          <xs:documentation>
            Event for a distress drone being launched (object = the space which the distress drone was launched in, param = the launching distress drone, param2 = launched distress drone)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="space" type="expression">
            <xs:annotation>
              <xs:documentation>
                Space which the distress drone was launched in
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group" type="groupeventsource" />
          <xs:attribute name="launcher" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                The object which launched the distress drone
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_inventory_added">
        <xs:annotation>
          <xs:documentation>
            Event for when inventory wares were added to entity (object = entity, param = table of wares with corresponding amounts)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_inventory_removed">
        <xs:annotation>
          <xs:documentation>
            Event for when inventory wares were removed from entity (object = entity, param = table of wares with corresponding amounts)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_supplies_added">
        <xs:annotation>
          <xs:documentation>
            Event for when supply wares were added to container object (object = container, param = table of wares with corresponding amounts)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_supplies_removed">
        <xs:annotation>
          <xs:documentation>
            Event for when supply wares were removed from container object (object = container, param = table of wares with corresponding amounts)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_supply_orders_added">
        <xs:annotation>
          <xs:documentation>
            Event for when supply orders(as wares) were added to container object (object = container, param = table of wares with corresponding amounts)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_supply_orders_removed">
        <xs:annotation>
          <xs:documentation>
            Event for when supply orders(as wares) were removed from container object (object = container, param = table of wares with corresponding amounts)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_production_started">
        <xs:annotation>
          <xs:documentation>
            Event for when an object has started production of a ware (object = container or productionmodule, param = productionmodule, param2 = product ware, param3 = whether this is a research project) (see also event_object_production_finished)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="productionmodule" type="productionmodule" use="optional" />
          <xs:attribute name="ware" type="ware" use="optional" />
          <xs:attribute name="research" type="booleanexpression" use="optional" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_production_finished">
        <xs:annotation>
          <xs:documentation>
            Event for when an object has finished production of a ware (object = container or productionmodule, param = productionmodule, param2 = product ware, param3 = whether this was a research project) (see also event_object_production_started)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="productionmodule" type="productionmodule" use="optional" />
          <xs:attribute name="ware" type="ware" use="optional" />
          <xs:attribute name="research" type="booleanexpression" use="optional" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_production_cancelled">
        <xs:annotation>
          <xs:documentation>
            Event for when an object has cancelled its production queue (object = container or productionmodule, param = productionmodule, param2 = whether a research project was cancelled, param3 = list of cancelled product wares)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="productionmodule" type="productionmodule" use="optional" />
          <xs:attribute name="research" type="booleanexpression" use="optional" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_props_generated">
        <xs:annotation>
          <xs:documentation>
            Event for when an object has had props generated (object = the populated component or its container, param = component which was populated)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="component" type="object" use="optional" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_props_despawning">
        <xs:annotation>
          <xs:documentation>
            Event for when an object has props about to be despawned (object = the populated component or its container, param = component which was populated)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="component" type="object" use="optional" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_object_interiors_despawning">
        <xs:annotation>
          <xs:documentation>
            Event for when an object has interiors about to be despawned (object = the populated controllable)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_area_discovered">
        <xs:annotation>
          <xs:documentation>
            Event for when a player-owned object has discovered a previously undiscovered area (param = sector, param2 = center position of discovered hex in sector)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="sector" type="sector" use="optional" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_universe_generated">
        <xs:annotation>
          <xs:documentation>
            Event for when the universe generation process has been completed (all stations have been built) at game start or when loading a savegame.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_job_ship_activated">
        <xs:annotation>
          <xs:documentation>
            Event for when a job ship has been activated in the galaxy, either spawned directly in space or when being finished at a shipyard (param = jobship)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_faction_relation_changed">
        <xs:annotation>
          <xs:documentation>
            Event for when a faction changes the relation towards another faction (param = faction, param2 = other faction, param3 = [new relation, old relation, relationchangereason]}.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="faction" type="faction" />
          <xs:attribute name="otherfaction" type="faction" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_faction_relation_range_changed">
        <xs:annotation>
          <xs:documentation>
            Event for faction changing relation range with another faction (param = faction, param2 = other faction)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="faction" type="faction" />
          <xs:attribute name="otherfaction" type="faction" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_faction_activated">
        <xs:annotation>
          <xs:documentation>
            Event for when a faction is activated (param = faction)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="faction" type="faction" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_faction_deactivated">
        <xs:annotation>
          <xs:documentation>
            Event for when a faction is deactivated (param = faction)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="faction" type="faction" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_faction_police_changed">
        <xs:annotation>
          <xs:documentation>
            Event for when a faction's police faction has been changed (param = faction, param2 = new police faction, param3 = old police faction)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="faction" type="faction" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_faction_headquarters_changed">
        <xs:annotation>
          <xs:documentation>
            Event for when a faction headquarters has been changed (param = faction, param2 = new faction headquarters station, param3 = old faction headquarters station)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attribute name="faction" type="faction" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_lockbox_opened">
        <xs:annotation>
          <xs:documentation>
            Event for when a lockbox has been opened (object = opened lockbox)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="objecteventsource" />
        </xs:complexType>
      </xs:element>

      <xs:element name="event_terraforming_project_available">
        <xs:annotation>
          <xs:documentation>
            Event for when a repeatable terraforming project has become available again (object = cluster in which terraforming is taking place, param = project ID)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="clustereventsource" />
          <xs:attribute name="project" type="expression">
            <xs:annotation>
              <xs:documentation>
                ID of the project that has become available
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_terraforming_project_started_production">
        <xs:annotation>
          <xs:documentation>
            Event for when a terraforming project has started production - not triggered if the project has no deliveries (object = cluster in which terraforming is taking place, param = project ID)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="clustereventsource" />
          <xs:attribute name="project" type="expression">
            <xs:annotation>
              <xs:documentation>
                ID of the project that started production
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_terraforming_project_started">
        <xs:annotation>
          <xs:documentation>
            Event for when a terraforming project has started after finishing production - also triggered if the project has no duration and succeeds or fails immediately (object = cluster in which terraforming is taking place, param = project ID)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="clustereventsource" />
          <xs:attribute name="project" type="expression">
            <xs:annotation>
              <xs:documentation>
                ID of the project that has started
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_terraforming_project_completed">
        <xs:annotation>
          <xs:documentation>
            Event for when a terraforming project has been completed (object = cluster in which terraforming is taking place, param = project ID)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="clustereventsource" />
          <xs:attribute name="project" type="expression">
            <xs:annotation>
              <xs:documentation>
                ID of the project that has completed
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_terraforming_project_succeeded">
        <xs:annotation>
          <xs:documentation>
            Event for when a terraforming project has been completed successfully (object = cluster in which terraforming is taking place, param = project ID, param2 = [were there positive side-effects?, were there negative side-effects?], param3 = payout in Credits)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="clustereventsource" />
          <xs:attribute name="project" type="expression">
            <xs:annotation>
              <xs:documentation>
                ID of the project that has succeeded
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_terraforming_project_failed">
        <xs:annotation>
          <xs:documentation>
            Event for when a terraforming project has been completed unsuccessfully (object = cluster in which terraforming is taking place, param = project ID, param2 = [were there positive side-effects?, were there negative side-effects?])
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="clustereventsource" />
          <xs:attribute name="project" type="expression">
            <xs:annotation>
              <xs:documentation>
                ID of the project that has failed
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_terraforming_event_started">
        <xs:annotation>
          <xs:documentation>
            Event for when a terraforming event has started (object = cluster in which terraforming is taking place, param = project ID)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="clustereventsource" />
          <xs:attribute name="project" type="expression">
            <xs:annotation>
              <xs:documentation>
                ID of the project that has started
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_terraforming_event_completed">
        <xs:annotation>
          <xs:documentation>
            Event for when a terraforming event has been completed (object = cluster in which terraforming is taking place, param = project ID)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="clustereventsource" />
          <xs:attribute name="project" type="expression">
            <xs:annotation>
              <xs:documentation>
                ID of the project that has completed
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_terraforming_stat_added">
        <xs:annotation>
          <xs:documentation>
            Event for when a terraforming stat has been added to the list of relevant stats (object = cluster in which terraforming is taking place, param = stat ID)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="clustereventsource" />
          <xs:attribute name="stat" type="expression">
            <xs:annotation>
              <xs:documentation>
                ID of the stat that was added
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_terraforming_stat_removed">
        <xs:annotation>
          <xs:documentation>
            Event for when a terraforming stat has been removed from the list of relevant stats (object = cluster in which terraforming is taking place, param = stat ID)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="clustereventsource" />
          <xs:attribute name="stat" type="expression">
            <xs:annotation>
              <xs:documentation>
                ID of the stat that was removed
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_terraforming_stat_changed">
        <xs:annotation>
          <xs:documentation>
            Event for when a terraforming stat has changed (object = cluster in which terraforming is taking place, param = stat ID)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="clustereventsource" />
          <xs:attribute name="stat" type="expression">
            <xs:annotation>
              <xs:documentation>
                ID of the stat that was changed
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="event_terraforming_habitability_changed">
        <xs:annotation>
          <xs:documentation>
            Event for when a terraforming world's habitability has changed (object = cluster in which terraforming is taking place)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="eventcondition" />
          <xs:attributeGroup ref="clustereventsource" />
          <xs:attribute name="stat" type="expression">
            <xs:annotation>
              <xs:documentation>
                ID of the stat that was changed
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

    </xs:choice>
  </xs:group>

  <xs:group name="commonconditions_nonevent">
    <xs:choice>
      <xs:element name="check_value">
        <xs:annotation>
          <xs:documentation>
            Value is in specified range (both value and range can use expressions)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="noneventcondition" />
          <xs:attribute name="value" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Value to match (checked for non-zero if no comparison range or list is specified)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attributeGroup ref="range" />
        </xs:complexType>
      </xs:element>

      <xs:element name="check_age">
        <xs:annotation>
          <xs:documentation>
            Game age value is in specified range (both value and range can use time expressions)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="noneventcondition" />
          <xs:attributeGroup ref="range">
            <xs:annotation>
              <xs:documentation>
                Time value range
              </xs:documentation>
            </xs:annotation>
          </xs:attributeGroup>
        </xs:complexType>
      </xs:element>

      <xs:element name="check_object">
        <xs:annotation>
          <xs:documentation>
            Check an object against filters
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="noneventcondition" />
              <xs:attributeGroup ref="findarbitrary" />
              <!-- <xs:attribute name="space" type="space" /> -->
              <xs:attribute name="object" type="expression" use="required"/>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="check_weapon_active">
        <xs:annotation>
          <xs:documentation>
            Check whether the weapon is currently active
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="noneventcondition" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="macro" type="macro" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="check_weapon_installed">
        <xs:annotation>
          <xs:documentation>
            Check whether the weapon is installed/available
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="noneventcondition" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="macro" type="macro" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="check_production_allowed">
        <xs:annotation>
          <xs:documentation>
            Check if a production for a specified ware is allowed to be added to an object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="noneventcondition" />
          <xs:attribute name="object" type="object" />
          <xs:attribute name="ware" type="expression" />
        </xs:complexType>
      </xs:element>

      <xs:element name="count_clusters">
        <xs:annotation>
          <xs:documentation>
            Count matching clusters and check if count is in specified range
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="noneventcondition" />
              <xs:attributeGroup ref="findcluster" />
              <!-- space attribute supported but does not make sense here -->
              <!-- <xs:attribute name="space" type="space" /> -->
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attribute name="append" type="findappend" />
              <xs:attributeGroup ref="range">
                <xs:annotation>
                  <xs:documentation>
                    Number of clusters
                  </xs:documentation>
                </xs:annotation>
              </xs:attributeGroup>
              <xs:attributeGroup ref="sortresultwithlimit" />
              <xs:attribute name="result" type="countresult" />
              <xs:attribute name="groupname" type="groupname" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="count_gates">
        <xs:annotation>
          <xs:documentation>
            Count matching gates
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="noneventcondition" />
              <xs:attributeGroup ref="find" />
              <xs:attribute name="space" type="space" use="required" />
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attribute name="append" type="findappend" />
              <xs:attributeGroup ref="range">
                <xs:annotation>
                  <xs:documentation>
                    Number of gates
                  </xs:documentation>
                </xs:annotation>
              </xs:attributeGroup>
              <xs:attributeGroup ref="sortresultwithlimit" />
              <xs:attribute name="result" type="countresult" />
              <xs:attribute name="groupname" type="groupname" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="count_rooms">
        <xs:annotation>
          <xs:documentation>
            Count matching rooms
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="noneventcondition" />
              <xs:attributeGroup ref="findroom" />
              <xs:attribute name="object" type="object" use="required" />
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attribute name="append" type="findappend" />
              <xs:attributeGroup ref="range">
                <xs:annotation>
                  <xs:documentation>
                    Number of rooms
                  </xs:documentation>
                </xs:annotation>
              </xs:attributeGroup>
              <xs:attributeGroup ref="sortresultwithlimit" />
              <xs:attribute name="result" type="countresult" />
              <xs:attribute name="groupname" type="groupname" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="count_dockingbays">
        <xs:annotation>
          <xs:documentation>
            Count matching dockingbays
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="noneventcondition" />
              <xs:attributeGroup ref="find" />
              <xs:attribute name="object" type="object" use="required" />
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attribute name="append" type="findappend" />
              <xs:attributeGroup ref="range">
                <xs:annotation>
                  <xs:documentation>
                    Number of dockingbays
                  </xs:documentation>
                </xs:annotation>
              </xs:attributeGroup>
              <xs:attributeGroup ref="sortresultwithlimit" />
              <xs:attribute name="result" type="countresult" />
              <xs:attribute name="groupname" type="groupname" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="count_gravidar_contacts">
        <xs:annotation>
          <xs:documentation>
            Count matching contacts found via a gravidar
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="noneventcondition" />
              <xs:attributeGroup ref="findobject" />
              <xs:attribute name="object" type="expression" use="required">
                <xs:annotation>
                  <xs:documentation>
                    Scanning object
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attribute name="append" type="findappend" />
              <xs:attributeGroup ref="range">
                <xs:annotation>
                  <xs:documentation>
                    Number of objects
                  </xs:documentation>
                </xs:annotation>
              </xs:attributeGroup>
              <xs:attributeGroup ref="sortresultwithlimit" />
              <xs:attribute name="result" type="countresult" />
              <xs:attribute name="groupname" type="groupname" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="count_object_components">
        <xs:annotation>
          <xs:documentation>
            Count matching components contained in an object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="noneventcondition" />
              <xs:attributeGroup ref="findarbitrary" />
              <xs:attribute name="object" type="expression" use="required">
                <xs:annotation>
                  <xs:documentation>
                    Parent object for component search
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attribute name="append" type="findappend" />
              <xs:attribute name="recursive" type="findrecursive" />
              <xs:attribute name="includeobjects" type="findincludeobjects" />
              <xs:attributeGroup ref="range">
                <xs:annotation>
                  <xs:documentation>
                    Number of components
                  </xs:documentation>
                </xs:annotation>
              </xs:attributeGroup>
              <xs:attributeGroup ref="sortresultwithlimit" />
              <xs:attribute name="result" type="countresult" />
              <xs:attribute name="groupname" type="groupname" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="count_objects">
        <xs:annotation>
          <xs:documentation>
            Count matching objects
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="noneventcondition" />
              <xs:attributeGroup ref="findobject" />
              <xs:attribute name="space" type="space" use="required" />
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attribute name="append" type="findappend" />
              <xs:attribute name="recursive" type="findrecursive" />
              <xs:attributeGroup ref="range">
                <xs:annotation>
                  <xs:documentation>
                    Number of objects
                  </xs:documentation>
                </xs:annotation>
              </xs:attributeGroup>
              <xs:attributeGroup ref="sortresultwithlimit" />
              <xs:attribute name="result" type="countresult" />
              <xs:attribute name="groupname" type="groupname" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="count_sectors">
        <xs:annotation>
          <xs:documentation>
            Count matching sectors
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="noneventcondition" />
              <xs:attributeGroup ref="findsector" />
              <xs:attribute name="space" type="space" />
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attribute name="append" type="findappend" />
              <xs:attributeGroup ref="range">
                <xs:annotation>
                  <xs:documentation>
                    Number of sectors
                  </xs:documentation>
                </xs:annotation>
              </xs:attributeGroup>
              <xs:attributeGroup ref="sortresultwithlimit" />
              <xs:attribute name="result" type="countresult" />
              <xs:attribute name="groupname" type="groupname" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="count_ships">
        <xs:annotation>
          <xs:documentation>
            Count matching ships
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="noneventcondition" />
              <xs:attributeGroup ref="findship" />
              <xs:attribute name="space" type="space" use="required" />
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attribute name="append" type="findappend" />
              <xs:attribute name="recursive" type="findrecursive" />
              <xs:attributeGroup ref="range">
                <xs:annotation>
                  <xs:documentation>
                    Number of ships
                  </xs:documentation>
                </xs:annotation>
              </xs:attributeGroup>
              <xs:attributeGroup ref="sortresultwithlimit" />
              <xs:attribute name="result" type="countresult" />
              <xs:attribute name="groupname" type="groupname" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="count_stations">
        <xs:annotation>
          <xs:documentation>
            Count matching stations
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="noneventcondition" />
              <xs:attributeGroup ref="findstation" />
              <xs:attribute name="space" type="space" use="required" />
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attribute name="append" type="findappend" />
              <xs:attributeGroup ref="range">
                <xs:annotation>
                  <xs:documentation>
                    Number of stations
                  </xs:documentation>
                </xs:annotation>
              </xs:attributeGroup>
              <xs:attributeGroup ref="sortresultwithlimit" />
              <xs:attribute name="result" type="countresult" />
              <xs:attribute name="groupname" type="groupname" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="count_highways">
        <xs:annotation>
          <xs:documentation>
            Count matching highways
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="noneventcondition" />
              <xs:attributeGroup ref="find" />
              <xs:attribute name="space" type="space" />
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attribute name="append" type="findappend" />
              <xs:attributeGroup ref="range">
                <xs:annotation>
                  <xs:documentation>
                    Number of highways
                  </xs:documentation>
                </xs:annotation>
              </xs:attributeGroup>
              <xs:attributeGroup ref="sortresultwithlimit" />
              <xs:attribute name="result" type="countresult" />
              <xs:attribute name="groupname" type="groupname" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="count_zones">
        <xs:annotation>
          <xs:documentation>
            Count matching zones - excludes highways
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="noneventcondition" />
              <xs:attributeGroup ref="findzone" />
              <xs:attribute name="space" type="space" />
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attribute name="append" type="findappend" />
              <xs:attributeGroup ref="range">
                <xs:annotation>
                  <xs:documentation>
                    Number of zones
                  </xs:documentation>
                </xs:annotation>
              </xs:attributeGroup>
              <xs:attributeGroup ref="sortresultwithlimit" />
              <xs:attribute name="result" type="countresult" />
              <xs:attribute name="groupname" type="groupname" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="debug_text">
        <xs:annotation>
          <xs:documentation>
            Output debug text (dummy condition that is always met, so it can be used like an action)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="noneventcondition" />
          <xs:attribute name="text" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Text
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="debugchance" type="expression">
            <xs:annotation>
              <xs:documentation>
                Percentage chance of the debug text being displayed (used this instead of the condition chance, so that the condition does not fail)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="source" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Include the source of this debug_text (defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="filter">
            <xs:annotation>
              <xs:documentation>
                Debug output filter (optional, default is scripts)
              </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="error" />
                <xs:enumeration value="general" />
                <xs:enumeration value="scripts" />
                <xs:enumeration value="scripts_verbose" />
                <xs:enumeration value="economy_verbose" />
                <xs:enumeration value="combat" />
                <xs:enumeration value="savegame" />
                <xs:enumeration value="none" />
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="match_object">
        <xs:annotation>
          <xs:documentation>
            check that the object matches the criteria
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="noneventcondition" />
              <xs:attributeGroup ref="findobject" />
              <xs:attribute name="object" type="object" use="required" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="match_any_object">
        <xs:annotation>
          <xs:documentation>
            check that an object in the group matches the criteria
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="noneventcondition" />
              <xs:attributeGroup ref="findobject" />
              <xs:attribute name="group" type="group" use="required" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="match_all_objects">
        <xs:annotation>
          <xs:documentation>
            check that all objects in the group match the criteria (empty group returns true)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="noneventcondition" />
              <xs:attributeGroup ref="findobject" />
              <xs:attribute name="group" type="group" use="required" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_value">
        <xs:annotation>
          <xs:documentation>
            Remove a variable (dummy condition that is always met, so it can be used like an action)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="noneventcondition" />
          <xs:attribute name="name" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_value">
        <xs:annotation>
          <xs:documentation>
            Set a variable value (dummy condition that is always met, so it can be used like an action)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="noneventcondition" />
          <xs:attribute name="name" type="lvaluename" use="required" />
          <xs:attribute name="operation" type="setoperationlookup" />
          <xs:attributeGroup ref="random"/>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>

  <!-- ===== Common actions ===== -->

  <xs:group name="commonactions">
    <xs:choice>

      <!--
      <xs:element name="template">
        <xs:annotation>
          <xs:documentation>
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>
      -->

      <xs:element name="abort_scan">
        <xs:annotation>
          <xs:documentation>
            Abort the current player scan
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="abort_scripts">
        <xs:annotation>
          <xs:documentation>
            Abort all running AI scripts on an entity.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="entity" type="entity" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_alert_level">
        <xs:annotation>
          <xs:documentation>
            Set alert level
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="level" type="alertlevellookup" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="activate_landinggears">
        <xs:annotation>
          <xs:documentation>
            Activate the ship's landing gears
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="container" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="deactivate_landinggears">
        <xs:annotation>
          <xs:documentation>
            Deactivate the ship's landing gears
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="container" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="animate_chair">
        <xs:annotation>
          <xs:documentation>
            Animate a chair to suit the using NPC
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="slot" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The NPC slot related to the chair
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="actor" type="actor" use="optional">
            <xs:annotation>
              <xs:documentation>
                The NPC using or set to use the chair
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="chairtrigger" use="optional">
            <xs:annotation>
              <xs:documentation>
                Activation state for the chair (defaults to 'invalid')
              </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="activate_chair">
                  <xs:annotation>
                    <xs:documentation>
                      Have the chair animate to its active position
                    </xs:documentation>
                  </xs:annotation>
                </xs:enumeration>
                <xs:enumeration value="deactivate_chair">
                  <xs:annotation>
                    <xs:documentation>
                      Have the chair animation to its inactive position
                    </xs:documentation>
                  </xs:annotation>
                </xs:enumeration>
                <xs:enumeration value="invalid">
                  <xs:annotation>
                    <xs:documentation>
                      Have the chair remain in its current activation state
                    </xs:documentation>
                  </xs:annotation>
                </xs:enumeration>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="delay" type="expression">
            <xs:annotation>
              <xs:documentation>
                (optional) delay the animation by the specified amount of time
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="trigger_animation">
        <xs:annotation>
          <xs:documentation>
            Trigger an animation
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The component to trigger the animation on
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="tags" type="expression">
            <xs:annotation>
              <xs:documentation>
                The tag list to find specific parts to trigger the animation on (if neither this nor a group is supplied, the animation is triggered on the entire component)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group" type="expression">
            <xs:annotation>
              <xs:documentation>
                The group ID (which may be a string or a tag) used to find specific parts to trigger the animation on (if neither this nor tags are supplied, the animation is triggered on the entire component; has no effect if tags are also specified)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="trigger" type="animationtriggerlookup" use="required">
            <xs:annotation>
              <xs:documentation>
                The animation trigger
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="delay" type="expression">
            <xs:annotation>
              <xs:documentation>
                (optional) delay the animation by the specified amount of time
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="immediate" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Set to true if the new animation should start immediately instead of being queued.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="activate_weapongroup">
        <xs:annotation>
          <xs:documentation>
            Activate weapon group
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="weapongroup" type="expression" use="required" />
          <xs:attribute name="primary" type="booleanexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                Set to true if it's a primary, false if it's a secondary group
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="reset_weapongroups">
        <xs:annotation>
          <xs:documentation>
            Resets weapon groups of the specified object, setting lasers to the first primary weapon group and missile launchers to the first secondary weapon group.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="add_weapon_to_weapongroup">
        <xs:annotation>
          <xs:documentation>
            Adds a weapon to the specified weapon group.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="weapon" type="weapon" use="required" />
          <xs:attribute name="weapongroup" type="expression" use="required" />
          <xs:attribute name="primary" type="booleanexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                Set to true if it's a primary, false if it's a secondary group.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_weapon_from_weapongroup">
        <xs:annotation>
          <xs:documentation>
            Removes a weapon from the specified weapon group.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="weapon" type="weapon" use="required" />
          <xs:attribute name="weapongroup" type="expression" use="required" />
          <xs:attribute name="primary" type="booleanexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                Set to true if it's a primary, false if it's a secondary group.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_weapon_from_all_weapongroups">
        <xs:annotation>
          <xs:documentation>
            Removes a weapon from all weapon groups.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="weapon" type="weapon" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="add_actor_to_room">
        <xs:annotation>
          <xs:documentation>
            Add NPC actor to a room. This action fails if the actor could not be connected to that room.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="position" type="position" minOccurs="0" maxOccurs="1" />
            <xs:element name="rotation" type="rotation" minOccurs="0" maxOccurs="1" />
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="actor" type="actor" use="required" />
          <xs:attribute name="object" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Room (or object with valid 'position') in which to place the actor (Not to be combined with 'slot')
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="slot" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                The slot to place the actor (Takes precedence over 'room')
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="setroomslot" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Set the roomslot of the actor to the provided slot if it is a valid NPC slot (defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="triggeranimation" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Trigger the default animations for this room slot on the actor (defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="chairtrigger" use="optional">
            <xs:annotation>
              <xs:documentation>
                Activation state for the chair if the slot is a chair slot (defaults to 'activate_chair'. Using 'invalid' will keep the chair in it current activation state)
              </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="activate_chair">
                  <xs:annotation>
                    <xs:documentation>
                      Have the chair animate to its active position
                    </xs:documentation>
                  </xs:annotation>
                </xs:enumeration>
                <xs:enumeration value="deactivate_chair">
                  <xs:annotation>
                    <xs:documentation>
                      Have the chair animation to its inactive position
                    </xs:documentation>
                  </xs:annotation>
                </xs:enumeration>
                <xs:enumeration value="invalid">
                  <xs:annotation>
                    <xs:documentation>
                      Have the chair remain in its current activation state
                    </xs:documentation>
                  </xs:annotation>
                </xs:enumeration>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="result" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Whether the actor was successfully added
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="add_ammo">
        <xs:annotation>
          <xs:documentation>
            Add ammo to a defensible object (see also &lt;remove_ammo&gt; and &lt;deplete_ammo&gt;) NOTE: when used with unit macros storage limits are ignored! Use &lt;add_units&gt; instead!
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="macro" type="macro" use="required" />
          <xs:attribute name="amount" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Amount to be added (can be negative)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_ammo">
        <xs:annotation>
          <xs:documentation>
            Removes ammo from a defensible object (see also &lt;add_ammo&gt; and &lt;deplete_ammo&gt;)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="macro" type="macro" use="required" />
          <xs:attribute name="amount" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Amount to be removed (can be negative)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="deplete_ammo">
        <xs:annotation>
          <xs:documentation>
            Depletes ammo of a defensible object (see also &lt;add_ammo&gt; and &lt;remove_ammo&gt;). If macro is not supplied then ammo will be removed from all weapons.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="macro" type="macro" />
        </xs:complexType>
      </xs:element>

      <xs:element name="evaluate_ammo_storage">
        <xs:annotation>
          <xs:documentation>
            Evaluates the ammo storage of the given object. Returns lists containing amounts, wares and macros for the used ammo types. Indices of the lists are in sync. Also returns total ammo capacity from launchers (excludes base object ammo capacity)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="type" type="ammotypelookup" use="required" />
          <xs:attribute name="amounts" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Result list of max amounts for the ware/macro types (see other result lists, indices match)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="macros" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Result list of macro names for the ammo types (see other result lists, indices match)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="wares" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Result list of wares for the ammo types (see other result lists, indices match)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="capacity" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Resulting total ammo capacity for this type provided by launchers (excludes ammo capacity of base object)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="evaluate_habitation_storage">
        <xs:annotation>
          <xs:documentation>
            Evaluates the habitation storage needed to store workforce resources for the specified amount of workers and time. Returns cargo volume of required container storage.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="race" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The race that the workforce resources are for.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="time" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                The time for which to calculate the resource needs. (defaults to the production time of the workunit ware, typically 1h)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="workforce" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                The number of workers the resource needs are calculated for. (defaults to the product amount of the workunit ware, typically 300)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="busy" type="boolean" use="optional">
            <xs:annotation>
              <xs:documentation>
                Whether the workunit_busy ware should be used to calculate necessary resources (workunit_idle applies when station production is dormant and uses considerably fewer resources) (defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="includesecondary" type="boolean" use="optional">
            <xs:annotation>
              <xs:documentation>
                Whether secondary workforce resources(not required to maintain workforce, but increase efficiency if present) should be considered. (defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                Resulting volume of container storage required.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="evaluate_unit_storage">
        <xs:annotation>
          <xs:documentation>
            Evaluates the default unit storage of the given object. Returns lists containing unit categories, mks, macros and amounts. Indices of the lists are in sync.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="level" type="expression">
            <xs:annotation>
              <xs:documentation>
                The percentage level to which this object should be fitted out with randomly generated units. Given as a float between 0 and 1. (special value: -1 means stick to whatever was last set with &lt;set_loadout_level /&gt;
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="amounts" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Result list of amounts for the unit types (see other result lists, indices match)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="categories" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Result list of unit categories the unit types (see other result lists, indices match)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="macros" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Result list of macro names for the unit types (see other result lists, indices match)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="mks" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Result list of mks for the unit types to be used together with the respective category (see other result lists, indices match)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="evaluate_deployable_storage">
        <xs:annotation>
          <xs:documentation>
            Evaluates the default deployable storage of the given object. Returns lists containing deployable categories, mks, macros and amounts. Indices of the lists are in sync.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="level" type="expression">
            <xs:annotation>
              <xs:documentation>
                The percentage level to which this object should be fitted out with randomly generated deployables. Given as a float between 0 and 1. (special value: -1 means stick to whatever was last set with &lt;set_loadout_level /&gt;
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="amounts" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Result list of amounts for the deployable types (see other result lists, indices match)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="categories" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Result list of deployable categories the deployable types (see other result lists, indices match)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="macros" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Result list of macro names for the deployable types (see other result lists, indices match)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="mks" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Result list of mks for the deployable types to be used together with the respective category (see other result lists, indices match)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="evaluate_missile_storage">
        <xs:annotation>
          <xs:documentation>
            Evaluates the default missile storage of the given object. Returns lists containing missile macros and amounts. Indices of the lists are in sync.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="level" type="expression">
            <xs:annotation>
              <xs:documentation>
                The percentage level to which this object should be fitted out with randomly generated units. Given as a float between 0 and 1. (special value: -1 means stick to whatever was last set with &lt;set_loadout_level /&gt;
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="amounts" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Result list of amounts for the missile types (see other result lists, indices match)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="macros" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Result list of macro names for the missile types (see other result lists, indices match)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="add_cargo">
        <xs:annotation>
          <xs:documentation>
            Add cargo to an object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="ware" type="ware" use="required" />
          <xs:attributeGroup ref="random" />
          <xs:attributeGroup ref="action" />
          <xs:attribute name="result" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                The resulting amount that was successfully added
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_cargo">
        <xs:annotation>
          <xs:documentation>
            Remove cargo from an object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="ware" type="ware" use="required" />
          <xs:attributeGroup ref="random" />
          <xs:attributeGroup ref="action" />
          <xs:attribute name="result" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                The resulting amount that was successfully removed
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="add_wares">
        <xs:annotation>
          <xs:documentation>
            Add wares to a container
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="object" type="container" use="required" />
          <xs:attribute name="ware" type="ware" use="required" />
          <xs:attributeGroup ref="random" />
          <xs:attributeGroup ref="action" />
          <xs:attribute name="result" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Whether everything was added successfully
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="add_commission">
        <xs:annotation>
          <xs:documentation>
            Add price commission for target faction to object/faction(=target gets bonus pay for sales), if object and faction are specified, object takes precedence!
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="faction" type="faction" />
          <xs:attribute name="object" type="object" />
          <xs:attribute name="target" type="faction" use="required" />
          <xs:attribute name="amount" type="pricemodifieramount" use="required" />
          <xs:attribute name="name" type="expression">
            <xs:annotation>
              <xs:documentation>
                Name of commission, only required if target is faction.player
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="time" type="expression" >
            <xs:annotation>
              <xs:documentation>
                How long this commission lasts. Will last forever if omitted!
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="add_player_commission">
        <xs:annotation>
          <xs:documentation>
            Add price commission for player faction to object/faction(=target gets bonus pay for sales), if object and faction are specified, object takes precedence!
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="faction" type="faction" />
          <xs:attribute name="object" type="object" />
          <xs:attribute name="amount" type="pricemodifieramount" use="required" />
          <xs:attribute name="id" type="expression" >
            <xs:annotation>
              <xs:documentation>
                Identifier string for the discount
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="name" type="expression">
            <xs:annotation>
              <xs:documentation>
                Name of commission, only required if target is faction.player
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="time" type="expression" >
            <xs:annotation>
              <xs:documentation>
                How long this commission lasts. Will last forever if omitted!
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_commission">
        <xs:annotation>
          <xs:documentation>
            Remove price commission for target faction from object/faction, if object and faction are specified, object takes precedence!
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="faction" type="faction" />
          <xs:attribute name="object" type="object" />
          <xs:attribute name="target" type="faction" use="required" />
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_player_commission">
        <xs:annotation>
          <xs:documentation>
            Remove price commission for player faction from object/faction, if object and faction are specified, object takes precedence!
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="faction" type="faction" />
          <xs:attribute name="object" type="object" />
          <xs:attribute name="id" type="expression" >
            <xs:annotation>
              <xs:documentation>
                Identifier string for the discount
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="add_default_production_wares">
        <xs:annotation>
          <xs:documentation>
            Add default wares to a ship or station based on its productions and buildmodules
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="lowerlimit" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Minimum percentage of storage filled
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="upperlimit" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Maximum percentage of storage filled
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="extremechance" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Chance per ware that an extreme (0 or max) value will be added (ignoring the lower/upper limits) (optional)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="add_skill">
        <xs:annotation>
          <xs:documentation>
            Add skill value to either 'entity' or a npctemplate on 'object'
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="entity" type="entity" use="optional" />
          <xs:attribute name="object" type="object" use="optional" />
          <xs:attribute name="template" type="expression" use="optional" />
          <xs:attribute name="type" type="skilltype" use="required" />
          <xs:attributeGroup ref="random" />
        </xs:complexType>
      </xs:element>

      <xs:element name="add_supplies">
        <xs:annotation>
          <xs:documentation>
            Add supplies to an object. NOTE: if the supplies are not needed to fulfill any current supply orders an attempt will be made to transfer them to storage, respecting stock limits!
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="ware" type="ware" use="required" />
          <xs:attributeGroup ref="random" />
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_supplies">
        <xs:annotation>
          <xs:documentation>
            Remove supplies from an object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="ware" type="ware" use="required" />
          <xs:attributeGroup ref="random" />
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="add_supply_order">
        <xs:annotation>
          <xs:documentation>
            Add supply orders to an object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="ware" type="ware" use="required" />
          <xs:attributeGroup ref="random" />
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_supply_order">
        <xs:annotation>
          <xs:documentation>
            Remove supply order from an object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="ware" type="ware" use="required" />
          <xs:attributeGroup ref="random" />
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="add_tradeware">
        <xs:annotation>
          <xs:documentation>
            Add trade ware (use only on trading stations)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="ware" type="ware" use="required" />
          <xs:attribute name="allowbuy" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Allow buying this tradeware (optional, defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="allowsell" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Allow selling this tradeware (optional, defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="lockavgprice" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Lock price to average price of ware, otherwise price is calculated based on storage amounts (optional, defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_tradeware">
        <xs:annotation>
          <xs:documentation>
            Remove trade ware (-> trading stations)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="ware" type="ware" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="generate_shortage_reports">
        <xs:annotation>
          <xs:documentation>
            Generate reports of wares which are either in short supply, insufficient or overflowing
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="type" use="required">
            <xs:simpleType>
              <xs:union memberTypes="expression">
                <xs:simpleType>
                  <xs:restriction base="xs:string">
                    <xs:enumeration value="class.buildmodule">
                      <xs:annotation>
                        <xs:documentation>
                          Reports related to build modules
                        </xs:documentation>
                      </xs:annotation>
                    </xs:enumeration>
                    <xs:enumeration value="class.habitation">
                      <xs:annotation>
                        <xs:documentation>
                          Reports related to habitation modules and workforce
                        </xs:documentation>
                      </xs:annotation>
                    </xs:enumeration>
                    <xs:enumeration value="class.production">
                      <xs:annotation>
                        <xs:documentation>
                          Reports related to production modules
                        </xs:documentation>
                      </xs:annotation>
                    </xs:enumeration>
                  </xs:restriction>
                </xs:simpleType>
              </xs:union>
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="log" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Enable debug logging of the reports (debug, optional, defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="insufficient" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Resulting insufficient ware report table (ware is the key and the value is the amount of time this ware has been insufficient)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="shortage" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Resulting shortage ware report table (ware is the key and the value is the amount of time this ware has been in short supply)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="overflow" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Resulting overflow ware report table (ware is the key and the value is the amount of time this product has been at max capacity)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="add_research">
        <xs:annotation>
          <xs:documentation>
            Add research for the player
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="ware" type="ware" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_research">
        <xs:annotation>
          <xs:documentation>
            Remove completed research from the player
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="ware" type="ware" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="add_discount">
        <xs:annotation>
          <xs:documentation>
            Add price discount for target faction to object/faction(=target gets stuff cheaper), if object and faction are specified, object takes precedence!
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="faction" type="faction" />
          <xs:attribute name="object" type="object" />
          <xs:attribute name="target" type="faction" use="required" />
          <xs:attribute name="amount" type="pricemodifieramount" use="required" />
          <xs:attribute name="name" type="expression">
            <xs:annotation>
              <xs:documentation>
                Name of discount, only required if target is faction.player
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="time" type="expression" >
            <xs:annotation>
              <xs:documentation>
                How long this discount lasts. Will last forever if omitted!
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="add_player_discount">
        <xs:annotation>
          <xs:documentation>
            Add price discount for player faction to object/faction(=target gets stuff cheaper), if object and faction are specified, object takes precedence!
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="faction" type="faction" />
          <xs:attribute name="object" type="object" />
          <xs:attribute name="amount" type="pricemodifieramount" use="required" />
          <xs:attribute name="id" type="expression" >
            <xs:annotation>
              <xs:documentation>
                Identifier string for the discount
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="name" type="expression" use="required" >
            <xs:annotation>
              <xs:documentation>
                Name of discount, only required if target is faction.player
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="time" type="expression" >
            <xs:annotation>
              <xs:documentation>
                How long this discount lasts. Will last forever if 0 or omitted!
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_discount">
        <xs:annotation>
          <xs:documentation>
            Remove price discount for target faction from object/faction, if object and faction are specified, object takes precedence!
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="faction" type="faction" />
          <xs:attribute name="object" type="object" />
          <xs:attribute name="target" type="faction" use="required" />
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_player_discount">
        <xs:annotation>
          <xs:documentation>
            Remove price discount for player faction from object/faction, if object and faction are specified, object takes precedence!
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="faction" type="faction" />
          <xs:attribute name="object" type="object" />
          <xs:attribute name="id" type="expression" >
            <xs:annotation>
              <xs:documentation>
                Identifier string for the discount
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="add_watchdog_units_to_masstraffic">
        <xs:annotation>
          <xs:documentation>
            Add watchdogs units of a station to its zone's masstraffic
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="get_next_bonus_unlocktime">
        <xs:annotation>
          <xs:documentation>
            Query the earliest time at which this unlock may be triggered again.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="result" type="lvaluename" use="required" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="bonus" type="expression" use="required"/>
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_next_bonus_unlocktime">
        <xs:annotation>
          <xs:documentation>
            Set the earliest time at which this unlock may be triggered again.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="bonus" type="expression" use="required"/>
          <xs:attribute name="time" type="expression" use="required" />
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="add_conversation_view">
        <xs:annotation>
          <xs:documentation>
            Add a dummy conversation action (&lt;add_npc_line&gt; without NPC voice) to trigger the conversation manager. Legacy, used only to prevent a small delay if a conversation ends without voice (e.g. when cancelled).
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="add_faction_relation">
        <xs:annotation>
          <xs:documentation>
            Add global faction relation
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="faction" type="faction" use="required" />
          <xs:attribute name="otherfaction" type="faction" use="required" />
          <xs:attribute name="value" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Relation boost value
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="reason" type="relationchangereasonlookup" use="required">
            <xs:annotation>
              <xs:documentation>
                The reason for relationship change
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="get_factions_by_relation">
        <xs:annotation>
          <xs:documentation>
            Get factions by matching relation (object or faction attribute required)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="expression">
            <xs:annotation>
              <xs:documentation>
                Object to reference (takes preference over 'faction')
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="faction" type="factionexprlookup">
            <xs:annotation>
              <xs:documentation>
                Faction to reference ('object' takes preference if provided)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="relation" type="relationlookup" use="required" />
          <xs:attribute name="result" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="get_factions_by_tag">
        <xs:annotation>
          <xs:documentation>
            Get factions by matching tag (tag required)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="tag" type="expression" use="required" />
          <xs:attribute name="result" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_faction_identity">
        <xs:annotation>
          <xs:documentation>
            Set a faction's identity (any combination of name, shortname, description and icon) to new values
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="faction" type="faction" use="required"/>
          <xs:attribute name="name" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                New faction name (use format '{page,line}' as string for full localisation support, including support for saving and loading with a different language)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="shortname" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                New faction short name (use format '{page,line}' as string for full localisation support, including support for saving and loading with a different language)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="prefixname" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                New faction prefix name (use format '{page,line}' as string for full localisation support, including support for saving and loading with a different language)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="description" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                New faction description (use format '{page,line}' as string for full localisation support, including support for saving and loading with a different language)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="icon" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                New faction icon
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="image" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                New faction logo image
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="personal" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                New faction logo image is in personal folder? (default is false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_faction_mood">
        <xs:annotation>
          <xs:documentation>
            Set a faction's mood to a certain level
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="faction" type="factionexprlookup" use="required" />
          <xs:attribute name="type" type="moodtypelookup" use="required" />
          <xs:attribute name="level" type="moodlevellookup" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="reset_faction_mood">
        <xs:annotation>
          <xs:documentation>
            Reset a faction's mood to its default level
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="faction" type="factionexprlookup" use="required" />
          <xs:attribute name="type" type="moodtypelookup" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_faction_active">
        <xs:annotation>
          <xs:documentation>
            Set a faction to active/inactive.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="faction" type="factionexprlookup" use="required">
            <xs:annotation>
              <xs:documentation>
                Faction to set active/inactive
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="active" type="booleanexpression" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_faction_known">
        <xs:annotation>
          <xs:documentation>
            Set a faction to known/unknown to the player. Does not add encyclopedia entry for faction - see documentation for add_encyclopedia_entry.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="faction" type="factionexprlookup" use="required">
            <xs:annotation>
              <xs:documentation>
                Faction to set known/unknown
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="known" type="booleanexpression" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_faction_police">
        <xs:annotation>
          <xs:documentation>
            Set a faction's police faction to the specified faction. Will fail if the police faction is not a police faction.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="faction" type="factionexprlookup" use="required" />
          <xs:attribute name="policefaction" type="factionexprlookup" use="optional">
            <xs:annotation>
              <xs:documentation>
                Police faction (defaults to self for police factions or none for non-police factions if not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_faction_headquarters">
        <xs:annotation>
          <xs:documentation>
            Set a faction's headquarters to the specified station. Will fail if the station's owner is not the correct faction.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="faction" type="factionexprlookup" use="required" />
          <xs:attribute name="station" type="station" use="required" />
          <xs:attribute name="headquarters" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Is the faction headquarters?
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_known">
        <xs:annotation>
          <xs:documentation>
            Set a component to known/unknown to the player. Does not add encyclopedia entry for component (except for spaces) - see documentation for add_encyclopedia_entry.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Component to set known/unknown
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="known" type="booleanexpression" use="required" />
          <xs:attribute name="updatesnapshot" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Stations only. Update the snapshot of the station's current configuration for use in the map?
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_loot_magnet">
        <xs:annotation>
          <xs:documentation>
            (De)Activates the loot magnet of the playership
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="active" type="booleanexpression" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="add_inventory">
        <xs:annotation>
          <xs:documentation>
            Add inventory to an entity (entity defaults to player, amount defaults to 1)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="entity" type="entity" />
          <xs:attribute name="ware" type="ware" use="required" />
          <xs:attributeGroup ref="random" />
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_inventory">
        <xs:annotation>
          <xs:documentation>
            Remove inventory from an entity (entity defaults to player, amount defaults to 1)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="entity" type="entity" />
          <xs:attribute name="ware" type="ware" use="required" />
          <xs:attributeGroup ref="random" />
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="add_licence">
        <xs:annotation>
          <xs:documentation>
            Add licence to a faction (defaults to player faction)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="faction" type="faction" />
          <xs:attribute name="licence" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Licence to add (takes precedence over 'licencefaction' and 'type' pair)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="licencefaction" type="faction" use="optional">
            <xs:annotation>
              <xs:documentation>
                The licence issuing faction. Ignored if 'licence' is provided
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="type" type="licencelookup" use="optional">
            <xs:annotation>
              <xs:documentation>
                Type of licence. Ignored if 'licence' is provided
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_licence">
        <xs:annotation>
          <xs:documentation>
            Remove licence from a faction (defaults to player faction)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="faction" type="faction" />
          <xs:attribute name="licence" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Licence to remove (takes precedence over 'licencefaction' and 'type' pair)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="licencefaction" type="faction" use="optional">
            <xs:annotation>
              <xs:documentation>
                The licence issuing faction. Ignored if 'licence' is provided
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="type" type="licencelookup" use="optional">
            <xs:annotation>
              <xs:documentation>
                Type of licence. Ignored if 'licence' is provided
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="add_npc_line">
        <xs:annotation>
          <xs:documentation>
            Add an NPC voice line to the conversation
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:group ref="voicedata" minOccurs="0" maxOccurs="unbounded" />
          <xs:attributeGroup ref="action" />
          <xs:attribute name="speaker">
            <xs:annotation>
              <xs:documentation>
                Speaker (optional, an entity or a list of [controllable_context, npc_template], defaults to the conversation actor if not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="page" type="pagewithdefault" />
          <xs:attribute name="line" type="lineorlist" />
          <xs:attribute name="delay" type="speakdelay" />
          <xs:attribute name="lookat" type="expression">
            <xs:annotation>
              <xs:documentation>
                Look in the direction of the specified component
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="recipient" type="expression">
            <xs:annotation>
              <xs:documentation>
                Recipient of the line, i.e. the character being spoken to (optional). Pass an NPC if this is a background speech between two NPCs. Default is the player (if omitted or null).
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="topic" type="expression">
            <xs:annotation>
              <xs:documentation>
                Topic of the line, i.e. the character being spoken about (optional). Pass an NPC or the player if the person being spoken about may have a grammatical effect on the sentence.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="hidechoices" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Hide the player's conversation choices until after the NPC line has been spoken? Default is false (don't hide).
                This has no effect if the choices were already visible before the start of this line.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="check" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Check for errors resolving an object name or description? Default is true
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="add_player_choice">
        <xs:annotation>
          <xs:documentation>
            Add a player choice text to the conversation. When chosen, &lt;event_conversation_next_section&gt; will be triggered but the conversation stack will not be changed.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="playerchoice" />
          <xs:attribute name="section" type="namestring" use="required">
            <xs:annotation>
              <xs:documentation>
                Name of next conversation section
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="choiceparam" type="expression">
            <xs:annotation>
              <xs:documentation>
                Optional parameter that is passed to &lt;event_conversation_next_section&gt;. Can be of any data type.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="add_player_choice_sub">
        <xs:annotation>
          <xs:documentation>
            Add a player choice text to the conversation. When chosen, &lt;event_conversation_next_section&gt; will be triggered,
            and a sub-conversation will be started which can return to this section (see &lt;add_player_choice_return&gt;).
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="playerchoice" />
          <xs:attribute name="section" type="namestring" use="required">
            <xs:annotation>
              <xs:documentation>
                Name of next conversation section
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="choiceparam" type="expression">
            <xs:annotation>
              <xs:documentation>
                Optional parameter that is passed to &lt;event_conversation_next_section&gt;. Can be of any data type.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="baseparam" type="expression">
            <xs:annotation>
              <xs:documentation>
                Optional parameter that is evaluated immediately, but stored until the sub-conversation returns
                and &lt;event_conversation_returned_to_section&gt; is triggered. Can be of any data type.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="add_player_choice_subconv">
        <xs:annotation>
          <xs:documentation>
            Add a player choice text to the conversation. When chosen, &lt;event_conversation_started&gt; will be triggered,
            and a sub-conversation with a different actor will be started which will return to this section when it ends (unless the player aborts the conversation as a whole).
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="playerchoice" />
          <xs:attribute name="conversation" type="conversation" use="required">
            <xs:annotation>
              <xs:documentation>
                Name of next conversation section
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attributeGroup ref="conversationactor" />
          <xs:attribute name="convparam" type="expression">
            <xs:annotation>
              <xs:documentation>
                Optional parameter that is passed to &lt;event_conversation_started&gt;. Can be of any data type.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="baseparam" type="expression">
            <xs:annotation>
              <xs:documentation>
                Optional parameter that is evaluated immediately, but stored until the sub-conversation returns
                and &lt;event_conversation_returned_to_section&gt; is triggered. Can be of any data type.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="add_player_choice_return">
        <xs:annotation>
          <xs:documentation>
            Add a player choice text to the conversation. When chosen, the current sub-conversation will return to the previous section that
            started it (see &lt;add_player_choice_sub&gt; and &lt;add_player_choice_subconv&gt;), and &lt;event_conversation_returned_to_section&gt; will be triggered.
            This action also defines the behaviour of the "Back" button.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="playerchoice" />
          <xs:attribute name="returnparam" type="expression">
            <xs:annotation>
              <xs:documentation>
                Optional parameter that is passed to &lt;event_conversation_returned_to_section&gt;. Can be of any data type.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_conversation_return_section">
        <xs:annotation>
          <xs:documentation>
            Set the section to which the conversation returns when the player selects an &lt;add_player_choice_return&gt; option without any sub-section active. The default return section is &quot;g_finish&quot;.
            This action can be performed only once per conversation and only if no sub-section is already active.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="section" type="namestring" use="required">
            <xs:annotation>
              <xs:documentation>
                Name of conversation section to return to
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="baseparam" type="expression">
            <xs:annotation>
              <xs:documentation>
                Optional value that is passed as param2 to &lt;event_conversation_returned_to_section&gt;.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="add_relation_boost">
        <xs:annotation>
          <xs:documentation>
            Add relation boost (otherobject or faction attribute required)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="objectrelationboost" />
          <xs:attribute name="value" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Relation boost value
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="reason" type="relationchangereasonlookup">
            <xs:annotation>
              <xs:documentation>
                The reason for relationship change
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="add_to_group">
        <xs:annotation>
          <xs:documentation>
            Add an object or a list/group of objects to a group (the group is created if it does not exist yet)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="groupname" type="groupname" use="required" />
          <xs:attribute name="object" type="expression">
            <xs:annotation>
              <xs:documentation>
                Object to add to the group (cannot be used with attributes list or group)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="list" type="expression">
            <xs:annotation>
              <xs:documentation>
                List of objects to add to the group (cannot be used with attributes object or group)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group" type="expression">
            <xs:annotation>
              <xs:documentation>
                Group of objects to add to the group (cannot be used with attributes object or list)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="check" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Produce an error message if an inserted object or list element is not an existing object? (default is true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="add_tolerance_boost">
        <xs:annotation>
          <xs:documentation>
            Add tolerance boost (otherobject or faction attribute required)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="objectboost" />
          <xs:attribute name="value" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Tolerance boost value
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="aim_turret">
        <xs:annotation>
          <xs:documentation>
            Aim turret at target
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="turret" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Turret
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="target" type="targetcomponent" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="add_units">
        <xs:annotation>
          <xs:documentation>
            Add units to an object (either 'macro' is to be provided or both 'category' and 'mk')
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="category" type="unitcategorylookup" />
          <xs:attribute name="mk" type="expression" />
          <xs:attribute name="tags" type="expression" />
          <xs:attribute name="macro" type="expression" />
          <xs:attribute name="faction" type="factionexprlookup">
            <xs:annotation>
              <xs:documentation>
                The faction that made the units - defaults to the owner of the object if not provided
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="unavailable" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Add the unit as currently unavailable (default = false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attributeGroup ref="random" />
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_units">
        <xs:annotation>
          <xs:documentation>
            Remove units from an object (either 'macro' is to be provided or both 'category' and 'mk')
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="category" type="unitcategorylookup" />
          <xs:attribute name="mk" type="expression" />
          <xs:attribute name="tags" type="expression" />
          <xs:attribute name="macro" type="expression" />
          <xs:attribute name="unavailable" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Remove the unit from currently unavailable units (default = false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attributeGroup ref="random" />
        </xs:complexType>
      </xs:element>

      <xs:element name="request_units">
        <xs:annotation>
          <xs:documentation>
            Request units from an object and make them unavailable (either 'macro' is to be provided or both 'category' and 'mk')
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="category" type="unitcategorylookup" />
          <xs:attribute name="mk" type="expression" />
          <xs:attribute name="tags" type="expression" />
          <xs:attribute name="macro" type="expression" />
          <xs:attributeGroup ref="random" />
        </xs:complexType>
      </xs:element>

      <xs:element name="return_units">
        <xs:annotation>
          <xs:documentation>
            Return units from an object and make them available
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="macro" type="expression" use="required"/>
          <xs:attributeGroup ref="random" />
        </xs:complexType>
      </xs:element>

      <xs:element name="allow_conversation_escape">
        <xs:annotation>
          <xs:documentation>
            Allows or disallows escaping from the current conversation section (e.g. with Esc). Only the current section is affected, default is allow.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="enabled" type="boolean" use="required">
            <xs:annotation>
              <xs:documentation>
                Should Escape be possible in current conversation section?
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="append_list_elements">
        <xs:annotation>
          <xs:documentation>
            Append elements from another list at the end of a list
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="name" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                List to which the other list's elements will be appended
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="other" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                List whose elements will be appended
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="append_to_list">
        <xs:annotation>
          <xs:documentation>
            Append an element at the end of a list
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="name" type="list" use="required" />
          <xs:attributeGroup ref="random">
            <xs:annotation>
              <xs:documentation>
                Value to be appended to the list
              </xs:documentation>
            </xs:annotation>
          </xs:attributeGroup>
        </xs:complexType>
      </xs:element>

      <xs:element name="apply_construction_sequence">
        <xs:annotation>
          <xs:documentation>
            Appends a construction plan to a station that already exists. The construction plan for the station can be empty.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="station" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The station to which the construction sequence should be attached. This station must already be connected to the gamegraph, otherwise use create_station action.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="sequence" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                A construction sequence or construction plan ID
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="remove" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Remove any existing module that is not part of the provided sequence (defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="get_suitable_storage_modules">
        <xs:annotation>
          <xs:documentation>
            Evaluate needed storage modules based on production requirements
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="production" type="expression">
            <xs:annotation>
              <xs:documentation>
                Macro or list of macros of production modules used to evaluate needed storage
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="storage" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Macro or list of macros of storage modules already present
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="macros" type="expression">
            <xs:annotation>
              <xs:documentation>
                List of storage module macros which can be selected
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Result list of storage module macros
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="apply_attackstrength">
        <xs:annotation>
          <xs:documentation>
            Apply damage from an attack to target, returns if target was killed
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="result" minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
                  Result of attack including which component was hit.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attribute name="killed" type="lvalueexpression">
                  <xs:annotation>
                    <xs:documentation>
                      True if the object or module has been destroyed.
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="module" type="lvalueexpression">
                  <xs:annotation>
                    <xs:documentation>
                      The module that has been attacked (if one exists). Will match the passed-in module, provided it was a valid module of the object. NOTE: the returned module can already be destroyed!
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="surfaceelement" type="lvalueexpression">
                  <xs:annotation>
                    <xs:documentation>
                      The surface element that has been attacked (if one exists). Will match the passed-in surface element, provided it was a valid surface element of the object. NOTE: the returned surface element can already be destroyed!
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="attacker" type="object" use="required" />
          <xs:attribute name="strength" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Approximate total attack strength as a single value (individual values ignored if supplied).
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="hullshield" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Attack strength to be applied to hull and shields (ignored if total supplied).
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="hullonly" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Attack strength to be applied to hull only (ignored if total supplied).
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="shieldonly" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Attack strength to be applied to shields only (ignored if total supplied).
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="hullnoshield" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Attack strength to be applied to hull only if no shields are present (ignored if total supplied).
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="module" type="expression">
            <xs:annotation>
              <xs:documentation>
                Attack a specific module of the object (optional, defaults to a random operational module, if there are any, or the object as a whole otherwise.)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="surfaceelement" type="expression">
            <xs:annotation>
              <xs:documentation>
                Attack a specific surface element of the object (optional, defaults to a random operational surface element of the module/object, if there are any.)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="assert">
        <xs:annotation>
          <xs:documentation>
            Evaluates the value and prints an error message if it does not match. This requires the script debug filter to be enabled, both at game start and on the assert. (In developer builds a modal message box will pop up, and there is no filter requirement.)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="conditionalaction"/>
          <xs:attribute name="text" type="expression">
            <xs:annotation>
              <xs:documentation>
                Message text to be displayed on assertion failure
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="break">
            <xs:annotation>
              <xs:documentation>
                Determines on how many assertion failures the message box may pop up (default is 1).
                Note that resetting or refreshing the MD resets the counter.
              </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:union memberTypes="xs:nonNegativeInteger">
                <xs:simpleType>
                  <xs:restriction base="xs:string">
                    <xs:enumeration value="1" />
                    <xs:enumeration value="0" />
                    <xs:enumeration value="always" />
                  </xs:restriction>
                </xs:simpleType>
              </xs:union>
            </xs:simpleType>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="assign_control_entity">
        <xs:annotation>
          <xs:documentation>
            Assign NPC actor as the control entity for the specified control post of the specified object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="actor" type="actor" use="required" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="post" type="controlpost" use="required" />
          <xs:attribute name="transfer" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Move the actor to the object's control room instantly. (defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="init" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Start the suitable AI scripts on the actor. (defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Was the NPC sucessfully assigned?
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="add_actor_to_post_location">
        <xs:annotation>
          <xs:documentation>
            Move the NPC actor to its default location for its control post
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="actor" type="actor" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="initialise_control_entity">
        <xs:annotation>
          <xs:documentation>
            Start suitable AI scripts on a control entity which has not been initialised yet
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="actor" type="actor" use="required" />
        </xs:complexType>
      </xs:element>
      
      <xs:element name="reinitialise_control_entities">
        <xs:annotation>
          <xs:documentation>
            (Re-)Start suitable AI scripts on all control entities of object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="dismiss_control_entity">
        <xs:annotation>
          <xs:documentation>
            Remove NPC actor the control entity of its type of the specified object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="actor" type="actor" use="required" />
          <xs:attribute name="object" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_object_npc_assignment_restricted">
        <xs:annotation>
          <xs:documentation>
            Set restriction against assigning NPCs to the controllable object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="restricted" type="booleanexpression" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="get_control_entities">
        <xs:annotation>
          <xs:documentation>
            Get all control entities of the specified object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="multiple" type="boolean">
            <xs:annotation>
              <xs:documentation>
                If true then the result is a list of control entities, otherwise the result is a random control entity or null (default is true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="append" type="findappend" />
          <xs:attribute name="name" type="lvaluename" />
          <xs:attribute name="groupname" type="groupname" />

        </xs:complexType>
      </xs:element>

      <xs:element name="dismiss_pilot">
        <xs:annotation>
          <xs:documentation>
            Remove the pilot control entity of the specified object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="assign_hired_actor">
        <xs:annotation>
          <xs:documentation>
            Assign NPC actor (hired by player) as the control entity for the specified control post, or as a crew member with the specified role, on the specified player-owned object.
            If the assignment is possible, &lt;event_player_assigned_hired_actor&gt; is triggered and a success is indicated, otherwise a failure reason is provided.
            The actual assignment logic is implemented in an MD event handler.
            If the check value is set to true, the assignment via the event is skipped, so this action has no effect and only indicates success or failure.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="actor" type="genericactor" use="required" />
          <xs:attribute name="target" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Player-owned controllable target object on which the actor is assigned to a control post or role (may be the actor's currently assigned object)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="post" type="controlpostexprlookup">
            <xs:annotation>
              <xs:documentation>
                Control post (either post or role must be specified)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="role" type="entityroleexprlookup">
            <xs:annotation>
              <xs:documentation>
                Actor (entity) role (either post or role must be specified)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="check" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Only check for expected outcome (with attributes success and/or failed), without actually performing the assignment? Defaults to false.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="success" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Optional name of the value that will be set to true if successful, false in case of failure
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="failed" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Optional name of the value that will receive the failure reason string, or null if successful
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_actor_pod_arrival_time">
        <xs:annotation>
          <xs:documentation>
            Sets scheduled time of arrival for an actor (hired by the player) at the current object via a crew transfer pod, indicating that the actor has not arrived at the current location yet.
            Actors that are being transferred via pod can already exist at their target location, but should be treated as hidden and unavailable.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="actor" type="genericactor" use="required" />
          <xs:attribute name="time" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Arrival time (must be in the future)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="clear_actor_pod_arrival_time">
        <xs:annotation>
          <xs:documentation>
            Clears the scheduled time of arrival for an actor (hired by the player). If an arrival time was previously set on the actor, this triggers the arrival at the current object.
            See &lt;set_actor_pod_arrival_time&gt;.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="actor" type="genericactor" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="attach_object_to_target">
        <xs:annotation>
          <xs:documentation>
            Attach an object to the target using the 'limpet' connection (only supported on ships so far)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="target" type="object" use="required" />
          <xs:attribute name="keepoffset" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Whether the currect offset of object relative to target should be kept, uses target center otherwise (defaults: true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="break">
        <xs:annotation>
          <xs:documentation>
            Abort the most inner &lt;do_while&gt;, &lt;do_for_each&gt; or (counted) &lt;do_all&gt; loop.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="break_formation">
        <xs:annotation>
          <xs:documentation>
            Break formation as a formation leader. No effect if the object is not a formation leader
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="cease_fire">
        <xs:annotation>
          <xs:documentation>
            Cease fire
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="weaponmode" type="weaponmodelookup">
            <xs:annotation>
              <xs:documentation>
                Turret in this mode should stop firing. (defaults to any)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="staydeployed" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Should turrets stay deployed if they already are? (defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="change_relation_on_attack">
        <xs:annotation>
          <xs:documentation>
            Change relation of the attacked object towards the attacker
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="attacker" type="object" use="required" />
          <xs:attribute name="weapon" type="object" use="optional" />
          <xs:attribute name="attacked" type="object" use="required" />
          <xs:attribute name="method" type="killmethodlookup" use="required" />
          <xs:attribute name="result" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                This value will be set to true if there was an effect on the relation (or at least the relation boost decay), otherwise it is set to false.
                The action can fail in several cases, e.g. if attacker and victim are of the same faction.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="change_relation_on_boarding">
        <xs:annotation>
          <xs:documentation>
            Change relation of the boarded object towards the boarder
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="boarder" type="object" use="required" />
          <xs:attribute name="boarded" type="object" use="required" />
          <xs:attribute name="attempt" type="booleanexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                Is this a boarding attempt or the end of a successful boarding operation?
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                This value will be set to true if there was an effect on the relation (or at least the relation boost decay), otherwise it is set to false.
                The action can fail in several cases, e.g. if attacker and victim are of the same faction.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="change_relation_on_kill">
        <xs:annotation>
          <xs:documentation>
            Change relation of the killed object towards the killer
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="killer" type="object" use="required" />
          <xs:attribute name="killed" type="object" use="required" />
          <xs:attribute name="method" type="killmethodlookup" use="required" />
          <xs:attribute name="result" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                This value will be set to true if there was an effect on the relation (or at least the relation boost decay), otherwise it is set to false.
                The action can fail in several cases, e.g. if attacker and victim are of the same faction.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="check_line_of_sight">
        <xs:annotation>
          <xs:documentation>
            Check if object has line of sight to the target (uses ray casts)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="target" type="object" use="required" />
          <xs:attribute name="name" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="check_is_area_obstructed">
        <xs:annotation>
          <xs:documentation>
            Check if a ship is inside the designated area. Ignores mass traffic (as long as it's in the lane) and ships that have collision avoidance currently disabled (due to docking or parking).
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="position" type="position" minOccurs="0" maxOccurs="1" />
            <xs:element name="rotation" type="rotation" minOccurs="0" maxOccurs="1" />
            <xs:element name="boundingbox" type="boundingbox" minOccurs="1" maxOccurs="1" />
          </xs:sequence>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="zone" type="zone" use="required" />
          <xs:attribute name="macro" type="macro" use="required" />
          <xs:attribute name="excluded" type="ship" />
          <xs:attribute name="name" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="check_is_build_location_free">
        <xs:annotation>
          <xs:documentation>
            Check if a build location is free. Takes highways and objects like stations and gates into account, but ignores ships or asteroids.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="position" type="position" minOccurs="0" maxOccurs="1" />
            <xs:element name="rotation" type="rotation" minOccurs="0" maxOccurs="1" />
          </xs:sequence>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="zone" type="zone" use="required" />
          <xs:attribute name="macro" type="macro" use="required" />
          <xs:attribute name="excluded" type="object" />
          <xs:attribute name="name" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="start_observation">
        <xs:annotation>
          <xs:documentation>
            Notify the game that a target is being observed by this entity now (target: the observed object; range: the distance in which observation is actually happening)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The observer object
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="target" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The observed object
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="range" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The distance in which observation is actually happening
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="stop_observation">
        <xs:annotation>
          <xs:documentation>
            Notify the game that a target is no longer being observed by this entity
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The observer object
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="target" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The previously observed object
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="start_attack">
        <xs:annotation>
          <xs:documentation>
            Notify the game that a target is being attacked by this entity now
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The attacker object
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="target" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The attacked object
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="stop_attack">
        <xs:annotation>
          <xs:documentation>
            Notify the game that a target is no longer being attacked by this entity
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The attacker object
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="target" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The previously attacked object
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="report_illegal_activity">
        <xs:annotation>
          <xs:documentation>
            Report illegal activity
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The object doing the illegal activity
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="target" type="expression">
            <xs:annotation>
              <xs:documentation>
                The victim of the activity
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="claim_ship">
        <xs:annotation>
          <xs:documentation>
            Claim the target ship using pilot. ATTENTION: this moves 'this' to $target! All further this.* calls will correspond to $target!
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="target" type="expression" use="required" >
            <xs:annotation>
              <xs:documentation>
                Ship that will be claimed. Must be ownerless.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="pilot" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Pilot that will do the claiming. Will be moved from its current controllable to target.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="faction" type="factionexprlookup">
            <xs:annotation>
              <xs:documentation>
                Faction that will take owership of ship. Will default to ownership of pilot controllable if omitted.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="clamp_equipment_amount">
        <xs:annotation>
          <xs:documentation>
            Clamp wares and amounts of ordered ammunition, units, and deployables depending on resources available to the builder
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The object that is getting the new equipment
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="builder" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The object that is building the new equipment
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="ammo" type="expression">
            <xs:annotation>
              <xs:documentation>
                Table of ammunition or deployable wares with assigned amounts to be clamped
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="units" type="expression">
            <xs:annotation>
              <xs:documentation>
                Table of unit wares with assigned amounts to be clamped
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="resultammo" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Resulting table of ammo wares and amounts clamped to what the builder has enough resources to build. Will return null if attribute ammo is not populated.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="resultunits" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Resulting table of unit wares and amounts clamped to what the builder has enough resources to build. Will return null if attribute units is not populated.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="clamp_trade_amount">
        <xs:annotation>
          <xs:documentation>
            Clamp trade amount value based on buyer/seller storage situation (bundle/unbundle states are taken into account and the appropriate storages - cargo, ammo or units - are checked)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="trade" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The trade to check
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="amount" type="expression">
            <xs:annotation>
              <xs:documentation>
                Initial amount to clamp based on buyer/seller storage limits (optional, defaults to 2147483647)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="buyer" type="expression">
            <xs:annotation>
              <xs:documentation>
                The buyer to look at for free storage limitations (optional, either buyer or seller must be specified)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="seller" type="expression">
            <xs:annotation>
              <xs:documentation>
                The seller to look at for stored item limitations (optional, either buyer or seller must be specified)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="bundle" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Should the ware be bundled (convert ammo/unit -> ware) on transfer? (optional, defaults to the trade offer bundle flag)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="unbundle" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Should the ware be unbundled (turn ware into ammo/units) on transfer? (optional, defaults to the trade offer unbundle flag)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="updatedeal" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Should the passed-in tradedeal amount be updated if the clamp results in a reduction of amount? (optional, defaults to false, DO NOT USE FOR TRADE OFFERS!)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                Amount clamped so it both matches what seller has and what buyer can store.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="clear_collision_filter">
        <xs:annotation>
          <xs:documentation>
            Clear the list of objects for which collisions are disabled
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="clear_group">
        <xs:annotation>
          <xs:documentation>
            Clear a group, i.e. remove all members from it
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="group" type="group" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="clear_list">
        <xs:annotation>
          <xs:documentation>
            Clear a list (equivalent to resizing to 0 elements)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="list" type="list" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="clear_table">
        <xs:annotation>
          <xs:documentation>
            Clear a table, i.e. remove all keys and values from it
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="table" type="table" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="get_building_position">
        <xs:annotation>
          <xs:documentation>
            Get buildership position outside of the stations boundaries, requires using 'position', 'space' and 'macro' OR an already placed 'construction'
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="position" type="position" minOccurs="0" maxOccurs="1" />
            <xs:element name="rotation" type="rotation" minOccurs="0" maxOccurs="1" />
          </xs:sequence>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="construction" type="object" />
          <xs:attribute name="macro" type="macro" />
          <xs:attribute name="space" type="zone" />
          <xs:attribute name="name" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="assign_construction_vessel">
        <xs:annotation>
          <xs:documentation>
            Assign a construction vessel to work for a build module of a build storage. Construction vessel is not yet deployed to aid in building.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="buildmodule" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="deploy_construction_vessel">
        <xs:annotation>
          <xs:documentation>
            Deploy a construction vessel to begin work for a build module of a build storage.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="buildmodule" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="disengage_construction_vessel">
        <xs:annotation>
          <xs:documentation>
            Disengage a construction vessel from a build module
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Build Module or Construction Vessel
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="connect_to_trade_location">
        <xs:annotation>
          <xs:documentation>
            Connect a ship to a trade location (= reserve parking space)
            If result is null then the operation failed.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="ship" type="ship" use="required" />
          <xs:attribute name="tradedock" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Trade Location ComponentSlot (find using &lt;find_tradeoffer_parking_slot&gt;)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="disconnect_from_trade_location">
        <xs:annotation>
          <xs:documentation>
            Disconnect a ship from a trade location (= free up parking space)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="ship" type="ship" use="required" />
          <xs:attribute name="tradedock" type="expression">
            <xs:annotation>
              <xs:documentation>
                (optional) the Trade Location ComponentSlot to disconnect from. (if supplied, additional validation will be performed)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvaluename" />
        </xs:complexType>
      </xs:element>

      <xs:element name="add_build_to_construct_ship">
        <xs:annotation>
          <xs:documentation>
            Add a build task to construct a ship
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="override" minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
                  Define override resources and build duration
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attribute name="duration" type="expression" use="required">
                  <xs:annotation>
                    <xs:documentation>
                      Overriding build duration (note that the duration may still be affected by build efficiency and minimum build step times)
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="resources" type="expression" use="required">
                  <xs:annotation>
                    <xs:documentation>
                      Ware amount table of overriding resources (wares must be tagged as 'economy')
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Container object that has a build module
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="macro" type="macro" use="optional">
            <xs:annotation>
              <xs:documentation>
                Macro to build (overriden by the macro of buildobject if provided)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="buildobject" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Existing object to be built as a new object
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="faction" type="faction" use="optional">
            <xs:annotation>
              <xs:documentation>
                Specific faction to be used (optional)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="loadout" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Loadout value or Loadout ID (must be valid in 'macro' or the macro of 'buildobject')
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="price" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Price of the constructed object
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvaluename" use="optional" />
        </xs:complexType>
      </xs:element>

      <xs:element name="add_build_to_recycle_ship">
        <xs:annotation>
          <xs:documentation>
            Add a build task to recycle a ship
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Container object that has a build module
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="buildobject" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Ship to be recycled
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="faction" type="faction" use="optional">
            <xs:annotation>
              <xs:documentation>
                Owner of the build task (optional)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="price" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Price of the constructed object
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="immediate" type="immediateorder" />
          <xs:attribute name="internal" type="booleanexpression" />
          <xs:attribute name="result" type="lvaluename" use="optional" />
        </xs:complexType>
      </xs:element>

      <xs:element name="add_build_to_expand_station">
        <xs:annotation>
          <xs:documentation>
            Add a build task to expand a station
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Container object that has a build module
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="buildobject" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Existing object to be expanded
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="constructionplan" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Construction plan ID string or constructionsequence value
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="price" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Price of the expansion
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvaluename" use="optional" />
        </xs:complexType>
      </xs:element>

      <xs:element name="add_build_to_modify_ship">
        <xs:annotation>
          <xs:documentation>
            Add a build task to upgrade or restock a ship
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="people" minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
                  People definitions
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="add" minOccurs="0" maxOccurs="1">
                    <xs:complexType>
                      <xs:choice maxOccurs="1">
                        <xs:element name="existing_people" minOccurs="0" maxOccurs="1">
                          <xs:annotation>
                            <xs:documentation>
                              People to be added to the object from NPC templates existing on the building object
                            </xs:documentation>
                          </xs:annotation>
                          <xs:complexType>
                            <xs:attributeGroup ref="existingpeoplelist"/>
                          </xs:complexType>
                        </xs:element>
                        <xs:element name="matching_people" minOccurs="0" maxOccurs="1">
                          <xs:annotation>
                            <xs:documentation>
                              People to be added to the object from matching people or workforce on the building object (or from nowhere otherwise)
                            </xs:documentation>
                          </xs:annotation>
                          <xs:complexType>
                            <xs:attributeGroup ref="matchingpeoplelist"/>
                            <xs:attribute name="force" type="booleanexpression">
                              <xs:annotation>
                                <xs:documentation>
                                  Force the people to be added regardless of available matching NPCs on the providing object (defaults to false)
                                </xs:documentation>
                              </xs:annotation>
                            </xs:attribute>
                          </xs:complexType>
                        </xs:element>
                      </xs:choice>
                    </xs:complexType>
                  </xs:element>
                  <xs:element name="remove" minOccurs="0" maxOccurs="1">
                    <xs:complexType>
                      <xs:choice maxOccurs="1">
                        <xs:element name="existing_people" minOccurs="0" maxOccurs="1">
                          <xs:annotation>
                            <xs:documentation>
                              People to be added to the object from NPC templates existing on the building object
                            </xs:documentation>
                          </xs:annotation>
                          <xs:complexType>
                            <xs:attributeGroup ref="existingpeoplelist"/>
                          </xs:complexType>
                        </xs:element>
                        <xs:element name="matching_people" minOccurs="0" maxOccurs="1">
                          <xs:annotation>
                            <xs:documentation>
                              People to be added to the object from matching people or workforce on the building object (or from nowhere otherwise)
                            </xs:documentation>
                          </xs:annotation>
                          <xs:complexType>
                            <xs:attributeGroup ref="matchingpeoplelist"/>
                            <xs:attribute name="force" type="booleanexpression">
                              <xs:annotation>
                                <xs:documentation>
                                  Force the people to be removed, regardless of available free space on the receiving object (defaults to true)
                                </xs:documentation>
                              </xs:annotation>
                            </xs:attribute>
                          </xs:complexType>
                        </xs:element>
                      </xs:choice>
                    </xs:complexType>
                  </xs:element>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Container object that has a build module
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="buildobject" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Existing object to be upgraded or restocked
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="loadout" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Loadout ID (must be valid in the macro of 'buildobject')
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="ammo" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Table of ammo types (ware or macro) with assigned amounts
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="units" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Table of unit types (ware or macro) with assigned amounts
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="price" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Price of the upgrade
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvaluename" use="optional" />
          <xs:attribute name="immediate" type="immediateorder" />
          <xs:attribute name="internal" type="booleanexpression" />
        </xs:complexType>
      </xs:element>

      <xs:element name="get_build_people">
        <xs:annotation>
          <xs:documentation>
            Get build people definitions in the form of a set of lists, either to be removed or added
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="build" type="build" use="required" />
          <xs:attribute name="amounts" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Result list of amounts
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="currentroles" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Result list of roles used to identify people
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="newroles" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Result list of roles to reassign people
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="races" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Result list of races used to identify people
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="skills" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Result list of skills used to identify people
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="people" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Result list of people (if 'removed' == true, then these people are currently on the built object, otherwise, the building object)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="remove" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Get the people set to be removed (defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="reassign_existing_people">
        <xs:annotation>
          <xs:documentation>
            Reassign people's roles
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="existingpeoplelist"/>
          <xs:attribute name="object" type="object" use="required"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="reassign_matching_people">
        <xs:annotation>
          <xs:documentation>
            Reassign people's roles
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="matchingpeoplelist"/>
          <xs:attribute name="object" type="object" use="required"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="transfer_people">
        <xs:annotation>
          <xs:documentation>
            Transfer people as defined in a build order, or by this definition
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="failed" minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
                  Result values for the cost of people which were unable to be transferred
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attribute name="added" type="lvalueexpression">
                  <xs:annotation>
                    <xs:documentation>
                      Money value of people who were unable to be added during the transfer
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="removed" type="lvalueexpression">
                  <xs:annotation>
                    <xs:documentation>
                      Money value of people who were unable to be removed during the transfer
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
              </xs:complexType>
            </xs:element>
            <xs:choice maxOccurs="1">
              <xs:element name="existing_people" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                  <xs:documentation>
                    People to be added to the object from NPC templates existing on the building object
                  </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                  <xs:attributeGroup ref="existingpeoplelist"/>
                </xs:complexType>
              </xs:element>
              <xs:element name="matching_people" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                  <xs:documentation>
                    People to be added to the object from matching people or workforce on the building object (or from nowhere otherwise)
                  </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                  <xs:attributeGroup ref="matchingpeoplelist"/>
                </xs:complexType>
              </xs:element>
            </xs:choice>
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="build" type="build" use="optional">
            <xs:annotation>
              <xs:documentation>
                Build containing the people definition
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="object" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Object recieving the people
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="otherobject" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Object providing the people
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="force" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Force the transfer, ignoring people capacities. Defaults to false.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Result list of people successfully transferred from otherobject to object
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_build">
        <xs:annotation>
          <xs:documentation>
            Remove a build task from an object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="build" type="build" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="process_build">
        <xs:annotation>
          <xs:documentation>
            Begin processing a build task
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="result" type="lvalueexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Returns true if the build was successfully processed, otherwise false.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Container object that has a build processor
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="buildmodule" type="expression">
            <xs:annotation>
              <xs:documentation>
                Specific build module to be used (optional, ignored if build processor is supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="buildprocessor" type="expression">
            <xs:annotation>
              <xs:documentation>
                Specific build processor to be used (optional, overrides build module if supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="build" type="build" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="reserve_build_plot">
        <xs:annotation>
          <xs:documentation>
            Reserve a build plot, creating the base station and build storage
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="position" type="position" minOccurs="0" maxOccurs="1" />
            <xs:element name="safepos" type="createobjectsafepos" minOccurs="0" maxOccurs="1" />
            <xs:element name="rotation" type="rotation" minOccurs="0" maxOccurs="1" />
            <xs:element name="plot" minOccurs="0" maxOccurs="1">
              <xs:complexType>
                <xs:annotation>
                  <xs:documentation>
                    Initial build plot dimensions, with the base station in the centre
                  </xs:documentation>
                </xs:annotation>
                <xs:attribute name="x" type="expression">
                  <xs:annotation>
                    <xs:documentation>
                      Length of the plot on the X axis
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="y" type="expression">
                  <xs:annotation>
                    <xs:documentation>
                      Length of the plot on the Y axis
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="z" type="expression">
                  <xs:annotation>
                    <xs:documentation>
                      Length of the plot on the Z axis
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="zone" type="zone" use="required" />
          <xs:attribute name="owner" type="faction" use="optional" />
          <xs:attribute name="missioncue" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Mission cue build plot belongs to (default is none)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvalueexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Created build storage
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_build_plot">
        <xs:annotation>
          <xs:documentation>
            Set the build plot of an object to be a given size.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="expression">
            <xs:annotation>
              <xs:documentation>
                Station or BuildStorage of which the plot will be extendedm
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="x" type="expression" use="required" />
          <xs:attribute name="y" type="expression" use="required" />
          <xs:attribute name="z" type="expression" use="required" />
          <xs:attribute name="allowreduction" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Should the build plot be allowed to be reduced from its current size? Defaults to false.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="paid" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Is this plot size paid for (defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="extend_build_plot">
        <xs:annotation>
          <xs:documentation>
            Extend the length of a build plot (potentially shifing the BuildStorage's position)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Station or BuildStorage of which the plot will be extended
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="negx" type="expression">
            <xs:annotation>
              <xs:documentation>
                Extension of the plot length on the negative X axis
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="negy" type="expression">
            <xs:annotation>
              <xs:documentation>
                Extension of the plot length on the negative Y axis
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="negz" type="expression">
            <xs:annotation>
              <xs:documentation>
                Extension of the plot length on the negative Z axis
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="posx" type="expression">
            <xs:annotation>
              <xs:documentation>
                Extension of the plot length on the positive X axis
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="posy" type="expression">
            <xs:annotation>
              <xs:documentation>
                Extension of the plot length on the positive Y axis
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="posz" type="expression">
            <xs:annotation>
              <xs:documentation>
                Extension of the plot length on the positive Z axis
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="allowreduction" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Should the build plot be allowed to reduce in size if necessary. Defaults to false.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="abort_build">
        <xs:annotation>
          <xs:documentation>
            Attempt to abort a build task. Only succeedes if task is currently abortable. Can provide either a build processor or container. Container requires a build task.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="build" type="build" use="optional" />
          <xs:attribute name="buildprocessor" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Build processor. Takes precedence over 'container' If 'buildtask' is provided, it must be the current build for this processor. If not provided, the current build is aborted.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="container" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Container. 'buildtask' must also be provided.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="commandeer_object">
        <xs:annotation>
          <xs:documentation>
            Commandeer an object to be used by faction logic
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="expression" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="release_commandeered_object">
        <xs:annotation>
          <xs:documentation>
            Release a commandeered object (job ships restart their orders)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="expression" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="release_job_ship">
        <xs:annotation>
          <xs:documentation>
            Release a ship from its job
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="ship" type="expression" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="find_waiting_job_ship">
        <xs:annotation>
          <xs:documentation>
            Find waiting job ship(s)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="action" />
              <xs:attributeGroup ref="findobject" />
              <xs:attribute name="append" type="findappend" />
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attributeGroup ref="sortresultwithlimit" />
              <xs:attribute name="name" type="lvaluename" />
              <xs:attribute name="groupname" type="groupname" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="find_waiting_subordinate">
        <xs:annotation>
          <xs:documentation>
            Find waiting subordinate(s)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="action" />
              <xs:attributeGroup ref="findobject" />
              <xs:attribute name="commander" type="object" />
              <xs:attribute name="append" type="findappend" />
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attributeGroup ref="sortresultwithlimit" />
              <xs:attribute name="name" type="lvaluename" />
              <xs:attribute name="groupname" type="groupname" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="get_subordinate_jobs">
        <xs:annotation>
          <xs:documentation>
            Get the possible subordinate jobs and the number of missing desired ships
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="action" />
              <xs:attribute name="commander" type="object" use="required" />
              <xs:attribute name="init" type="booleanexpression" use="optional">
                <xs:annotation>
                  <xs:documentation>
                    Is the commander initialising (defaults to false)? If false, subordinates flagged to not rebuild are ignored
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="jobs" type="lvalueexpression" use="required">
                <xs:annotation>
                  <xs:documentation>
                    Result list of job IDs (paired with amount)
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="amount" type="lvalueexpression" use="optional">
                <xs:annotation>
                  <xs:documentation>
                    Result list of desired ship amounts (paired with jobs)
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="get_subordinate_macro">
        <xs:annotation>
          <xs:documentation>
            Get the possible subordinate macro(s) of a job ship
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="action" />
              <xs:attribute name="commander" type="object" use="required" />
              <xs:attribute name="init" type="booleanexpression" use="optional">
                <xs:annotation>
                  <xs:documentation>
                    Is the commander initialising (defaults to false)? If false, subordinates flagged to not rebuild are ignored
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attribute name="name" type="lvaluename" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="organise_job_ship_subordinates">
        <xs:annotation>
          <xs:documentation>
            Organise a job ship's subordinate hierarchy based on job definitions
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="commander" type="object" />
        </xs:complexType>
      </xs:element>

      <xs:element name="get_suitable_job">
        <xs:annotation>
          <xs:documentation>
            Get suitable job(s) by their category and basket data
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="faction" type="factionexprlookup">
            <xs:annotation>
              <xs:documentation>
                Faction or list of factions
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="tags" type="expression">
            <xs:annotation>
              <xs:documentation>
                Specification tag or list of tags
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="size" type="shipsizeclasslookup">
            <xs:annotation>
              <xs:documentation>
                Ship size
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="ware" type="ware">
            <xs:annotation>
              <xs:documentation>
                Ware to be matched to job basket
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="force" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Find suitable jobs even if the Job Engine is deactivated?
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="exceedquota" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Include jobs which are currently exceeding their maxgalaxy quota (defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="includeinactive" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Include jobs which are currently inactive (defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="onlycommandeerable" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Include only jobs which are commandeerable (defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="multiple" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Find multiple definitions? If true, the result values return a list. If false (default), the results returns a single value.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                Result job id or list of job id's
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="request_job_ship">
        <xs:annotation>
          <xs:documentation>
            Request a new job ship for a purpose
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="job" type="expression" use="required"/>
          <xs:attribute name="requester" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Object requesting the ship to be created (can also be a space)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="zone" type="expression">
            <xs:annotation>
              <xs:documentation>
                Zone to become the ship's main job zone
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="ware" type="ware">
            <xs:annotation>
              <xs:documentation>
                Ware requested to be transported by the job ship.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="name" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                Result ship (may not be connected to universe)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_job_ship_request">
        <xs:annotation>
          <xs:documentation>
            Remove the request for a job ship (ship is removed if it does not exist in the universe)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="ship" type="object" use="required"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_requested_job_ship_timeout">
        <xs:annotation>
          <xs:documentation>
            Set the time after which a job ship will be unregistered as a requested ship (will not happen at the exact time)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="ship" type="object" use="required"/>
          <xs:attribute name="timeout" type="expression" use="required"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="find_requested_job_ship">
        <xs:annotation>
          <xs:documentation>
            Find requested job ship(s). Allows specialised filtering by 'requester', 'ware', 'includeexisting' and 'includewaiting'.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="action" />
              <xs:attributeGroup ref="findobject" />
              <xs:attribute name="append" type="findappend" />
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attributeGroup ref="sortresultwithlimit" />
              <xs:attribute name="name" type="lvaluename" />
              <xs:attribute name="groupname" type="groupname" />
              <xs:attribute name="requester" type="expression" use="optional">
                <xs:annotation>
                  <xs:documentation>
                    The object which requested the ship (if null, the ships are not filtered by requester)
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="ware" type="expression" use="optional">
                <xs:annotation>
                  <xs:documentation>
                    The ware associated with the ship request (if null, the ships are not filtered by ware)
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="includeexisting" type="booleanexpression" use="optional">
                <xs:annotation>
                  <xs:documentation>
                    Include ships which are in the universe (defaults to true)
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="includewaiting" type="booleanexpression" use="optional">
                <xs:annotation>
                  <xs:documentation>
                    Include ships which are waiting to be created in the universe (defaults to true. do not use with groups)
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="spawn_waiting_job_ship">
        <xs:annotation>
          <xs:documentation>
            Spawn a waiting job ship into an area of space or a dock
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="orientation" type="orientation" minOccurs="0" maxOccurs="1" />
            <xs:element name="position" type="position" minOccurs="0" maxOccurs="1" />
            <xs:element name="safepos" type="createobjectsafepos" minOccurs="0" maxOccurs="1" />
            <xs:element name="rotation" type="rotation" minOccurs="0" maxOccurs="1" />
          </xs:sequence>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="ship" type="object" use="required"/>
          <xs:attribute name="dock" type="expression">
            <xs:annotation>
              <xs:documentation>
                Either a DockingBay, Container or WalkableModule component or a Dockslot to spawn in (takes precedence from zone or sector)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="zone" type="expression">
            <xs:annotation>
              <xs:documentation>
                Zone to spawn in (used if dock is omitted or invalid, take precedence from sector)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="sector" type="expression">
            <xs:annotation>
              <xs:documentation>
                Sector to spawn the ship in using position in the sector space. Creates a tempzone if a zone does not exist at the coordinates
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvalueexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Was the ship successfully spawned?
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="create_replacement_subordinates">
        <xs:annotation>
          <xs:documentation>
            Create needed subordinates which can be built by buildobject. The resulting ships will be disconnected as waiting subordinates.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="commander" type="object" />
          <xs:attribute name="buildobject" type="expression">
            <xs:annotation>
              <xs:documentation>
                The builder object. Used to check what types of ships which can be built.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="init" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Is the commander initialising (defaults to false)? If false, subordinates flagged to not rebuild are ignored
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="max" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Maximum amount of requested subordinates (if omitted, no limit)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="append" type="findappend" />
          <xs:attribute name="multiple" type="findmultiple" />
          <xs:attribute name="name" type="lvaluename" />
          <xs:attribute name="groupname" type="groupname" />
        </xs:complexType>
      </xs:element>

      <xs:element name="activate_job_ship_orders">
        <xs:annotation>
          <xs:documentation>
            Trigger the orders for this ship's job to start
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="ship" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="activate_waiting_job_ship">
        <xs:annotation>
          <xs:documentation>
            Inform the job engine that a waiting ship is ready for use
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="ship" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_job_ship_mainzone">
        <xs:annotation>
          <xs:documentation>
            Set a job ship's start location to a zone (sector will be set implicitly)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="ship" type="object" use="required" />
          <xs:attribute name="zone" type="zone" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_job_ship_mainsector">
        <xs:annotation>
          <xs:documentation>
            Set a job ship's start location to a sector (zone will be set implioitly, and may be a random zone within the sector)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="ship" type="object" use="required" />
          <xs:attribute name="sector" type="sector" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_ship_expiration_time">
        <xs:annotation>
          <xs:documentation>
            Set the time at which a job ship is treated as expired
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="ship" type="object" use="required" />
          <xs:attribute name="time" type="expression" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_ship_safepos_allowed">
        <xs:annotation>
          <xs:documentation>
            When set to false, the ship will no longer be moved to a safe position when it enters visible attention.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="ship" type="object" use="required" />
          <xs:attribute name="allow" type="booleanexpression" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="continue">
        <xs:annotation>
          <xs:documentation>
            Skip the current iteration of the most inner &lt;do_while&gt;, &lt;do_for_each&gt; or (counted) &lt;do_all&gt; loop, and continue with the next iteration.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="create_ai_unit">
        <xs:annotation>
          <xs:documentation>
            Create an AI unit from the provided object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="expression" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="create_group">
        <xs:annotation>
          <xs:documentation>
            Create an empty group
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="groupname" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                Name of the group to be created
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="create_list">
        <xs:annotation>
          <xs:documentation>
            Create a list of given element count (default is 0), filled with null values. Use [] syntax instead for lists with fixed size/content.
            Note that the list variable name has to be provided in the name attribute, not the list attribute.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="random">
            <xs:annotation>
              <xs:documentation>
                Number of elements
              </xs:documentation>
            </xs:annotation>
          </xs:attributeGroup>
          <xs:attribute name="name" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="create_formation">
        <xs:annotation>
          <xs:documentation>
            Create formation on a object. If that object has already a formation, it only changes the shape. Nested formations supported.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="leader" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Object for which this formation should be created (can be any member of an existing formation or a new leader)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="follower" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Object for which this formation should be created (can be any member of an existing formation or a new leader)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="formation" type="formationshapelookup" use="required">
            <xs:annotation>
              <xs:documentation>
                Formation shape
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="param" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Parameter for formation shape, see formation shape documentation
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="rollformation" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether the entire formation shape should roll with the leader (optional, defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="rollmembers" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether individual members should mimic the roll orientation of the leader (optional, defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="maxshipsperline" type="expression">
            <xs:annotation>
              <xs:documentation>
                Maximum number of ships per line of formation shape (optional, defaults to 20).
                If the amount of ships exceed this number, the formation will split creating lines up to this maximum amount.
                Does not affect the following formation shapes:  wshape, eagle, twin, triangle, dartvertical and darthorizontal.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="create_crate">
        <xs:annotation>
          <xs:documentation>
            Create a crate in a room
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="name" type="lvaluename" />
          <xs:attribute name="groupname" type="groupname" />
          <xs:attribute name="macro" type="macro" use="required"/>
          <xs:attribute name="slot" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Room slot to place the crate
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="create_lockbox">
        <xs:annotation>
          <xs:documentation>
            Create a Lockbox (wrapped inside its own object)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="position" type="position" minOccurs="0" maxOccurs="1" />
            <xs:element name="safepos" type="createobjectsafepos" minOccurs="0" maxOccurs="1" />
            <xs:element name="rotation" type="rotation" minOccurs="0" maxOccurs="1" />
          </xs:sequence>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="name" type="lvaluename" />
          <xs:attribute name="groupname" type="groupname" />
          <xs:attribute name="macro" type="macro" use="required"/>
          <xs:attribute name="zone" type="expression">
            <xs:annotation>
              <xs:documentation>
                Zone to create the lockbox in. (takes precedence from sector)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="sector" type="expression">
            <xs:annotation>
              <xs:documentation>
                Sector to create the lockbox in using position in the sector space. Creates a tempzone if a zone does not exist at the coordinates
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="owner" type="faction" />
          <xs:attribute name="missioncue" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Mission cue lockbox belongs to (default is none)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="create_object">
        <xs:annotation>
          <xs:documentation>
            Create an Object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="position" type="position" minOccurs="0" maxOccurs="1" />
            <xs:element name="safepos" type="createobjectsafepos" minOccurs="0" maxOccurs="1" />
            <xs:element name="rotation" type="rotation" minOccurs="0" maxOccurs="1" />
          </xs:sequence>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="name" type="lvaluename" />
          <xs:attribute name="groupname" type="groupname" />
          <xs:attribute name="macro" type="macro" use="required"/>
          <xs:attribute name="zone" type="expression">
            <xs:annotation>
              <xs:documentation>
                Zone to create the object in. (takes precedence from sector)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="sector" type="expression">
            <xs:annotation>
              <xs:documentation>
                Sector to create the object in using position in the sector space. Creates a tempzone if a zone does not exist at the coordinates
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="owner" type="faction" />
          <xs:attribute name="missioncue" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Mission cue object belongs to (default is none)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="commandeerable" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Is the ship commandeerable by faction logic (defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="spinning" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Should the object be spinning? Only works for asteroids, lockboxes, drops, mines, and ships. Defaults to true if not supplied.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="create_signal_leak">
        <xs:annotation>
          <xs:documentation>
            Create a signal leak on an object or in space
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="position" type="position" minOccurs="0" maxOccurs="1" />
            <xs:element name="rotation" type="rotation" minOccurs="0" maxOccurs="1" />
            <xs:element name="voice" minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
                  Specify voice pageID and a text ID or a list of text IDs for this signal leak. A random one will be chosen if multiple are provided. Only valid and required for type signalleaktype.voice!
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attribute name="page" type="page" use="required" />
                <xs:attribute name="lines" type="expression" use="required">
                  <xs:annotation>
                    <xs:documentation>
                      List of line IDs or single line ID in a text page
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="name" type="lvaluename" />
          <xs:attribute name="groupname" type="groupname" />
          <xs:attribute name="macro" type="macro" use="required"/>
          <xs:attribute name="type" type="signalleaktypelookup" use="required"/>
          <xs:attribute name="object" type="expression">
            <xs:annotation>
              <xs:documentation>
                Object (or zone) to create the signal leak in. (takes precedence from sector)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="sector" type="expression">
            <xs:annotation>
              <xs:documentation>
                Sector to create the signal leak in using position in the sector space. Creates a tempzone if a zone does not exist at the coordinates
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="slot" type="expression">
            <xs:annotation>
              <xs:documentation>
                Slot to connect the signal leak to (only works for 'info' or 'mission' slots on objects, ignored for zone signal leaks)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="update_signal_leak_voice">
        <xs:annotation>
          <xs:documentation>
            Specify voice pageID and a text ID or a list of text IDs for an existing signal leak. A random one will be chosen if multiple are provided. Only valid and required for type signalleaktype.voice!
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="page" type="page" use="required" />
          <xs:attribute name="lines" type="lineorlist" use="required" />
          <xs:attribute name="object" type="expression">
            <xs:annotation>
              <xs:documentation>
                The signal leak to update
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attributeGroup ref="action"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="create_order">
        <xs:annotation>
          <xs:documentation>
            Creates an AI order and adds it to an object's order queue
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="param" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>
                  AI order parameter
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attribute name="name" type="paramname" use="required">
                  <xs:annotation>
                    <xs:documentation>
                      Parameter name
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="value" type="expression" use="required">
                  <xs:annotation>
                    <xs:documentation>
                      Parameter value
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="comment" type="comment" />
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="id" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Order ID
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="default" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Create as default order of the object? Instead of being added to the order queue, the order will replace the previous default order.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="immediate" type="immediateorder" />
          <xs:attribute name="override" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Is this an override order?
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="name" type="lvaluename" />
        </xs:complexType>
        <xs:key name="create_order_param_name">
          <xs:selector xpath="param" />
          <xs:field xpath="@name" />
        </xs:key>
      </xs:element>

      <xs:element name="create_trade_order">
        <xs:annotation>
          <xs:documentation>
            Creates an AI trade order and adds it to an object's order queue. A trade deal is created based on the given trade offer,
            so the trade can be performed in the future even if the trade offer changes or disappears in the meantime.
            The trade order ID is hard-coded. The trade deal is associated with the order (accessible via $order.trade) and is passed
            to the order as the &quot;trade&quot; parameter.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="tradeoffer" type="tradeoffer" use="required" />
          <xs:attribute name="amount" type="expression" use="required" />
          <xs:attribute name="price" type="expression">
            <xs:annotation>
              <xs:documentation>
                Price per piece (defaults to the trade offer price)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="bundle" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Should the ware be bundled (convert ammo/unit -> ware) on transfer? (optional, defaults to the trade offer bundle flag)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="unbundle" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Should the ware be unbundled (turn ware into ammo/units) on transfer? (optional, defaults to the trade offer unbundle flag)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="immediate" type="immediateorder" />
          <xs:attribute name="internal" type="booleanexpression" />
          <xs:attribute name="name" type="lvaluename" />
        </xs:complexType>
      </xs:element>

      <xs:element name="create_orientation">
        <xs:annotation>
          <xs:documentation>
            Create an orientation(rotation) value. refobject takes priority over refposition if both are supplied
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="position" type="position">
              <xs:annotation>
                <xs:documentation>
                  Position the orientation originates at (e.g. look_at means look from position towards refposition)
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="maxpitch" type="expression">
            <xs:annotation>
              <xs:documentation>
                The maximum pitch angle to be returned, in positive degrees (default: 90deg, i.e. no restriction)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="name" type="lvaluename" use="required" />
          <xs:attributeGroup ref="orientation" />
        </xs:complexType>
      </xs:element>

      <xs:element name="create_construction_sequence">
        <xs:annotation>
          <xs:documentation>
            Create a construction sequence for a station randomly, connecting station modules with each other (but not applying the result to the station automatically).
            Since it takes a lot of CPU time to calculate the result, the action is completed instantly and the result will be provided later via &lt;event_object_construction_sequence_created&gt;.
            To retrieve the result immediately as part of the action, use the child element &lt;immediate&gt;, but be aware that it will block the rest of the game until the result is available.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="immediate" minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
                  Provide the construction sequence immediately. The action will block the game until the result is available.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attribute name="result" type="lvalueexpression" use="required">
                  <xs:annotation>
                    <xs:documentation>
                      Name of the variable that will receive the resulting construction sequence. In case of failure the result will be null.
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="station" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The station for which the construction sequence should be created. Its plot bounding box will be used as a constraint,
                and the station will receive the event &lt;event_object_construction_sequence_created&gt;.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="macros" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                List of macros of functional modules to be added to the construction sequence
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="connectors" type="expression">
            <xs:annotation>
              <xs:documentation>
                List of macros of connector modules that are allowed in the construction sequence to connect functional modules.
                The algorithm may use a connector macro multiple times; it is not necessary to have duplicates in the list.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="constructionbias" type="expression">
            <xs:annotation>
              <xs:documentation>
                Construction direction bias (omit or set to 0.0 to use default, or use range 0.1 to 10.0 where less than 1.0 prefers vertical connections, 1.0 is balanced, and greater than 1.0 prefers horizontal connections)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="base" type="expression">
            <xs:annotation>
              <xs:documentation>
                Optional existing construction sequence that should be extended (null is allowed)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="timeout" type="expression">
            <xs:annotation>
              <xs:documentation>
                Time limit for the computationally intensive part of the generation algorithm (default is no limit). See also the failsafe attribute.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="failsafe" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Prevent failure of the sequence generation (default is true), in case the generator fails to connect all modules. Normally a failure
                only occurs by reaching the timeout (if timeout attribute is present) or if the input to the generator does not allow for enough flexibility
                (e.g. if no connectors are supplied or the plot size is too small). To prevent failure, the remaining unconnected modules will be added in
                free space without any connections. This additional step can only fail if the plot size is too limited to allow adding the missing modules.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_from_construction_sequence">
        <xs:annotation>
          <xs:documentation>
            Remove entries from the construction sequence that use the provided macros, also detaching all descendant entries in the connection tree.
            It is possible that more entries get removed than requested in the macro list.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="result">
              <xs:annotation>
                <xs:documentation>
                  Element for defining variable names that will receive the results
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attribute name="sequence" type="lvalueexpression" use="required">
                  <xs:annotation>
                    <xs:documentation>
                      Resulting construction sequence
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="removed" type="lvalueexpression">
                  <xs:annotation>
                    <xs:documentation>
                      List of existing components that are associated with input sequence entries but are removed in the result sequence (only returned if object is supplied)
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="cost" type="lvalueexpression">
                  <xs:annotation>
                    <xs:documentation>
                      Total removal cost
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="object" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Object that the construction sequence belongs to (if supplied, it affects attribute 'costs' and result attribute 'removed')
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="sequence" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Existing construction sequence from which entries should be removed
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="macros" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                List of macros of functional modules to be removed from the construction sequence.
                In order to remove multiple entries of the same macro, provide the macro multiple times.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="connectors" type="expression">
            <xs:annotation>
              <xs:documentation>
                List of macros of connector modules which may be removed in addition to the functional modules,
                except for the ones that are still required to keep the remaining sequence connected.
                It is not necessary to have duplicates in the list.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="costs" type="expression">
            <xs:annotation>
              <xs:documentation>
                Optional table of existing station components, with numeric cost values assigned to them. The action seeks to minimise the total cost of removed functional modules.
                For all sequence entries for which no cost is defined, a cost of 1.0 will be assumed for functional modules, and 0.0 for connectors.
                If object is provided, a cost of 0.0 will be assumed for all functional modules that do not exist in the object (i.e. have not been built yet).
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="generate_loadout">
        <xs:annotation>
          <xs:documentation>
            Generate a loadout for a given object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="sequence" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                A construction sequence for which loadouts should be generated. Loadouts will be generated an entry at a time.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="macro" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                A macro (ship or station) for which a loadout should be generated. Loadout will be returned as a single entry. Ignored if a sequence is provided.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="module" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                A module macro (station module) for which a loadout should be generated. Loadout will be returned as a single entry. Optional, ignored unless macro is provided.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="faction" type="factionexprlookup" use="optional">
            <xs:annotation>
              <xs:documentation>
                Faction to use for selecting equipment.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="otherfaction" type="factionexprlookup" use="optional">
            <xs:annotation>
              <xs:documentation>
                Additional faction to use for selecting equipment, where licences for both selling and buying are required. Ignored if wares or macros are supplied.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="wares" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                A list of wares or table of ware amounts, from which the loadout should be generated. If neither wares nor macros are provided, default items for faction will be used.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="macros" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                A list of macros or table of macro amounts, from which the loadout should be generated. Ignored if wares are provided. If neither wares nor macros are provided, default items for faction will be used.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="repeat" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                If a list of wares or macros is supplied, use repeated entries to indicate quantity, otherwise quantity is unlimited. Default is false (unlimited). Ignored if wares or macros are specified as a table, or if neither are specified.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="level" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                The level of the loadout that should be generated. This should be a value between 0 and 1. If variation is non-zero, it will add variation to this number. Defaults to value defined in parameters.xml.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="variation" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Allows an amount of variation on both the number of slots filled on a given entry in the sequence and what the slots can be filled with. Defaults to value defined in parameters.xml.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="requireblueprints" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                When generating a default loadout with no supplied ware or macro lists, select only items for which the supplied faction has blueprints. Has no effect for non-player factions. Defaults to false.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="flags" type="loadoutflagbitmask" use="optional">
            <xs:annotation>
              <xs:documentation>
                Loadout flags for elements to generate (add/remove flags not used in this case).
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="invertflags" type="boolean" use="optional">
            <xs:annotation>
              <xs:documentation>
                Invert the loadout flags provided in 'flags' attribute.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                A list of loadouts that have been generated for the given construction sequence. The index of each loadout refers to the index of the construction plan entry in the sequence.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="used" type="lvalueexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Optional variable to receive used items. Contents will follow the format of data supplied, i.e. wares if wares were supplied, macros if macros were supplied, and repeated if repeat parameter is true. Not populated if no ware/macro list is provided at all.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="remaining" type="lvalueexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Optional variable to receive remaining items. Contents will follow the format of data supplied, i.e. wares if wares were supplied, macros if macros were supplied. If repeat is false then the remaining items will be the same as the originally-supplied list because quantities are unlimited. Not populated if no ware/macro list is provided at all.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="get_loadout">
        <xs:annotation>
          <xs:documentation>
            Get a loadout via an ID
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="loadout" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                ID string of the loadout
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="macro" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Macro of which the loadout is defined for
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                Result loadout
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="create_loadout">
        <xs:annotation>
          <xs:documentation>
            Create a loadout using a fixed loadout definition
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:group ref="loadoutelements" />
          <xs:attributeGroup ref="action" />
          <xs:attribute name="result" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                Result loadout
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="apply_loadout">
        <xs:annotation>
          <xs:documentation>
            Apply the specified loadout to an object or construction sequence at the specified index.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="loadout" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The loadout that should be applied.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="object" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Object to apply the loadout to. Either a ship, or a station module.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="sequence" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                A sequence to which the loadout should be applied. If sequence is given, index must also be given, as a loadout is applied to a specific entry in the sequence.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="index" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                The index of the entry in the sequence to which the loadout that should be applied. Must be supplied if sequence is also supplied.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="flags" type="loadoutflagbitmask" use="optional">
            <xs:annotation>
              <xs:documentation>
                Loadout flags for elements to apply, and operations (add/remove) to perform.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="add_equipment_mods">
        <xs:annotation>
          <xs:documentation>
            Add one or more equipment mods to a ship
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:group ref="equipmentmods" />
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Ship to add the equipment mods to.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="add_paint_mod">
        <xs:annotation>
          <xs:documentation>
            Add paint mod to a ship
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Ship to add the paint mod to.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="ware" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Paint mod ware (from paintmods.xml, defines a quality level and visual properties of a paint mod)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_loadout_level">
        <xs:annotation>
          <xs:documentation>
            Set the specified loadout level for an object. Allowed range: 0.0 to 1.0. This loadout level will be used as the default for subsequent functions working with it (e.g. &lt;evaluate_unit_storage /&gt;)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="object" type="expression">
            <xs:annotation>
              <xs:documentation>
                Object loadout level applies to. Either a ship or station.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attributeGroup ref="random" />
        </xs:complexType>
      </xs:element>

      <xs:element name="create_random_position_in_boundingbox">
        <xs:annotation>
          <xs:documentation>
            Create a random position value within the bounding box of a component (the resulting value is relative to the component)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="component" type="object" use="required" />
          <xs:attribute name="name" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="create_random_position_outside_boundingbox">
        <xs:annotation>
          <xs:documentation>
            Create a random position value outside the bounding box of a component (the resulting value is relative to the component)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="component" type="object" use="required" />
          <xs:attribute name="mindistance" type="expression">
            <xs:annotation>
              <xs:documentation>
                The minimum distance the generated point will have from the edge of the component's bounding box in each axis.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="maxdistance" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The maximum distance the generated point will have from the edge of the component's bounding box in each axis.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="name" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="create_trade_offer">
        <xs:annotation>
          <xs:documentation>
            Create a trade offer and if provided, add it to an object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="seller" type="object" use="optional" >
            <xs:annotation>
              <xs:documentation>
                Setting the seller object makes this a Sell type offer. Also setting buyer negates this.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="buyer" type="object" use="optional" >
            <xs:annotation>
              <xs:documentation>
                Setting the buyer object makes this a Buy type offer. Also setting seller negates this.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="object" type="object" use="required" >
            <xs:annotation>
              <xs:documentation>
                Object for the offer to be localiased on
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="ware" type="ware" use="required" />
          <xs:attribute name="price" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The price of a single item
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="amount" type="expression" use="required" />
          <xs:attribute name="desiredamount" type="expression">
            <xs:annotation>
              <xs:documentation>
                The real amount we desire if available funds would not matter (optional, defaults to amount)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="minamount" type="expression" use="optional" />
          <xs:attribute name="fixedamount" type="boolean" use="optional">
            <xs:annotation>
              <xs:documentation>
                Is the ware amount fixed? Ignored if minamount is set
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="unbundle" type="boolean" use="optional">
            <xs:annotation>
              <xs:documentation>
                Should the ware be unbundled (turn ware into ammo/units) on transfer? (optional, defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="bundle" type="boolean" use="optional">
            <xs:annotation>
              <xs:documentation>
                Should the ware be bundled (convert ammo/unit -> ware) on transfer? (optional, defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="playeronly" type="boolean" use="required">
            <xs:annotation>
              <xs:documentation>
                Should this tradeoffer only be available to the player faction? (defaults to true, will allow *all* factions to trade if set to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="missioncue" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Mission cue trade belongs to (default is none)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="name" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_trade_offer">
        <xs:annotation>
          <xs:documentation>
            Remove a trade offer from an object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="tradeoffer" type="tradeoffer" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="create_position_outside_boundingbox">
        <xs:annotation>
          <xs:documentation>
            Create a position value just outside the bounding box of a component, in the direction of the given position (the resulting value is relative to the component).
            If the given position is inside the bounding box, it will be used as the result.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="position" type="position" minOccurs="1" maxOccurs="1" />
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="component" type="object" use="required" />
          <xs:attribute name="distance" type="expression">
            <xs:annotation>
              <xs:documentation>
                The distance the generated point will have from the edge of the component's bounding box.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="name" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="check_is_position_inside_boundingbox">
        <xs:annotation>
          <xs:documentation>
            Check if a position is inside an object's bounding box
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="position" type="position" minOccurs="0" maxOccurs="1" />
          </xs:sequence>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="name" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="find_object_surface">
        <xs:annotation>
          <xs:documentation>
            Create a position value directly on the surface of an object, in the direction of the given position (the resulting value is relative to the space, or the object if no space was supplied).
            The rotation value will be set from the surface normal.
            If no position is supplied, it will be randomized in a sphere around the object.
            If the position return value is null, no raycast was performed. This can happen if the collision mesh was not loaded yet. To handle this case, wait a second or so and retry.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="position" type="position" minOccurs="0" maxOccurs="1" />
            <xs:element name="end" type="position" minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
                  Position to aim the raycast at (otherwise 'component' if provided, object center if not) (optional)
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="offsetrotation" type="rotation" minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
                  Optional rotation that will be applied to the result in addition to the rotation based on the surface normal.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="component" type="object" >
            <xs:annotation>
              <xs:documentation>
                Sub component of object to aim the raycast at (otherwise object center) (optional)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="space" type="space" />
          <xs:attribute name="height" type="expression">
            <xs:annotation>
              <xs:documentation>
                If specified, the result will be moved by this distance along the surface normal. Can also be negative.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="posname" type="lvaluename" use="required" />
          <xs:attribute name="rotname" type="lvaluename" />
        </xs:complexType>
      </xs:element>

      <xs:element name="create_position">
        <xs:annotation>
          <xs:documentation>
            Create a position value
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="position" />
          <xs:attribute name="name" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="transform_position">
        <xs:annotation>
          <xs:documentation>
            Create a position value
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="position" type="position" minOccurs="0" maxOccurs="1" />
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="refposition" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Reference position
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="refrotation" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Rotation at the reference position
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="name" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="create_rotation">
        <xs:annotation>
          <xs:documentation>
            Create a rotation value
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="rotation" />
          <xs:attribute name="name" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="create_ship">
        <xs:annotation>
          <xs:documentation>
            Create a ship
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:group ref="createship" />
            <xs:element name="orientation" type="orientation" minOccurs="0" maxOccurs="1" />
            <xs:element name="position" type="position" minOccurs="0" maxOccurs="1" />
            <xs:element name="safepos" type="createobjectsafepos" minOccurs="0" maxOccurs="1" />
            <xs:element name="rotation" type="rotation" minOccurs="0" maxOccurs="1" />
          </xs:sequence>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="name" type="lvaluename" />
          <xs:attribute name="groupname" type="groupname" />
          <xs:attributeGroup ref="createship"/>
          <xs:attribute name="dock" type="expression">
            <xs:annotation>
              <xs:documentation>
                Either a DockingBay, Container or WalkableModule component or a Dockslot to spawn in (takes precedence from zone or sector)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="missioncue" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Mission cue ship belongs to (default is none)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="commandeerable" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Is the ship commandeerable by faction logic (defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="zone" type="expression">
            <xs:annotation>
              <xs:documentation>
                Zone to spawn in (used if dock is omitted or invalid, take precedence from sector)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="sector" type="expression">
            <xs:annotation>
              <xs:documentation>
                Sector to create the ship in using position in the sector space. Creates a tempzone if a zone does not exist at the coordinates
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="defaultscript" type="expression">
            <xs:annotation>
              <xs:documentation>
                Default script name
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="create_station">
        <xs:annotation>
          <xs:documentation>
            Create a station
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="position" type="position" minOccurs="0" maxOccurs="1" />
            <xs:element name="safepos" type="createobjectsafepos" minOccurs="0" maxOccurs="1" />
            <xs:element name="rotation" type="rotation" minOccurs="0" maxOccurs="1" />
          </xs:sequence>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="name" type="lvaluename" />
          <xs:attribute name="groupname" type="groupname" />
          <xs:attribute name="macro" type="macro" use="required"/>
          <xs:attribute name="constructionplan" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Construction plan ID string or constructionsequence value
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="zone" type="expression">
            <xs:annotation>
              <xs:documentation>
                Zone to create the station in. (takes precedence from sector)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="sector" type="expression">
            <xs:annotation>
              <xs:documentation>
                Sector to create the station in using position in the sector space. Creates a tempzone if a zone does not exist at the coordinates
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="owner" type="faction" use="required" />
          <xs:attribute name="state" type="componentstateexprlookup">
            <xs:annotation>
              <xs:documentation>
                State of the new station. Defaults to construction
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="missioncue" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Mission cue station belongs to (default is none)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="rawname" type="expression">
            <xs:annotation>
              <xs:documentation>
                Raw name for the station to be named to (in case of a fixed text reference, use format '{page,line}' as string for full localisation support, including support for saving and loading with a different language)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="create_factory">
        <xs:annotation>
          <xs:documentation>
            Create a factory
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:group ref="createmodule"/>
            <xs:element name="position" type="position" minOccurs="0" maxOccurs="1" />
            <xs:element name="safepos" type="createobjectsafepos" minOccurs="0" maxOccurs="1" />
            <xs:element name="rotation" type="rotation" minOccurs="0" maxOccurs="1" />
          </xs:sequence>
          <xs:attributeGroup ref="action"/>
          <xs:attributeGroup ref="createmodule" />
          <xs:attribute name="name" type="lvaluename" use="required" />
          <xs:attribute name="groupname" type="groupname" />
          <xs:attribute name="modules" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                Result list of module macros to be incorporated into a generated sequence
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="resultbasesequence" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                Result construction sequence which is the base which the resulting 'modules' will be added to (can be null if no base sequence is defined and the modules should be incorporated into an empty plan)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="zone" type="expression">
            <xs:annotation>
              <xs:documentation>
                Zone to create the station in. (takes precedence from sector)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="sector" type="expression">
            <xs:annotation>
              <xs:documentation>
                Sector to create the station in using position in the sector space. Creates a tempzone if a zone does not exist at the coordinates
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="owner" type="faction" use="required"/>
          <xs:attribute name="race" type="race">
            <xs:annotation>
              <xs:documentation>
                Race of the factory, used to get a valid set (overridden by 'set')
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="missioncue" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Mission cue factory belongs to (default is none)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="set" type="expression">
            <xs:annotation>
              <xs:documentation>
                Module set ID used to construct this factory
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="originalproduct" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Define the ware that the station identifies as its original product
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="create_module">
        <xs:annotation>
          <xs:documentation>
            Create and add a module to an object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="position" type="position" minOccurs="0" maxOccurs="1" />
            <xs:element name="safepos" type="createobjectsafepos" minOccurs="0" maxOccurs="1" />
            <xs:element name="rotation" type="rotation" minOccurs="0" maxOccurs="1" />
          </xs:sequence>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="name" type="lvaluename" />
          <xs:attribute name="groupname" type="groupname" />
          <xs:attribute name="macro" type="macro" use="required"/>
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Object to add the module to
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="create_prop">
        <xs:annotation>
          <xs:documentation>
            Create a prop
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="name" type="lvaluename" />
          <xs:attribute name="groupname" type="groupname" />
          <xs:attributeGroup ref="createprop"/>
          <xs:attribute name="slot" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Prop slot
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="seed" type="expression">
            <xs:annotation>
              <xs:documentation>
                Seed for prop selection (either a numerical value or an object with a seed provided by their spawnsource e.g. job or god engine)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="create_dynamic_interior">
        <xs:annotation>
          <xs:documentation>
            Create and add a dynamic interior to an object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="interiorname" type="lvaluename" />
          <xs:attribute name="corridorname" type="lvaluename" />
          <xs:attribute name="roomname" type="lvaluename" />
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Object to add the interior to
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="module" type="expression">
            <xs:annotation>
              <xs:documentation>
                Optional module within the object where the interior should be added
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="corridor" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Corridor macro
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="door" type="expression">
            <xs:annotation>
              <xs:documentation>
                Door macro slot or connection name withing corridor (random door is selected if not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="room" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Room macro
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="name" type="expression">
            <xs:annotation>
              <xs:documentation>
                Name to be applied to new interior
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="roomtype" type="roomtypeexprlookup" />
          <xs:attribute name="seed" type="expression">
            <xs:annotation>
              <xs:documentation>
                Seed for interior generation (either a numerical value or an object with a seed provided by their spawnsource e.g. job or god engine)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="persistent" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Is the interior persistent in low attention? (defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="private" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Are the dynamic interior rooms private? (defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_dynamic_interior">
        <xs:annotation>
          <xs:documentation>
            Remove a dynamic interior from an object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Object to remove the interior from (any one of interior, corridor or room component can be supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="interior" type="expression">
            <xs:annotation>
              <xs:documentation>
                Interior to remove
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="corridor" type="expression">
            <xs:annotation>
              <xs:documentation>
                Corridor to remove (ignored if interior provided)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="room" type="expression">
            <xs:annotation>
              <xs:documentation>
                Room to remove (ignored if interior or corridor provided)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_dynamic_interior_private">
        <xs:annotation>
          <xs:documentation>
            Set the rooms of a dynamic interior to private so contained NPC slots and waypoints can only be found by querying the rooms specifically, not via their contexts
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Object containing the interior (any one of interior, corridor or room component can be supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="interior" type="expression">
            <xs:annotation>
              <xs:documentation>
                Interior to set privacy for
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="corridor" type="expression">
            <xs:annotation>
              <xs:documentation>
                Corridor used to find interior to set privacy for (ignored if interior provided)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="room" type="expression">
            <xs:annotation>
              <xs:documentation>
                Room used to find interior to set privacy for (ignored if interior or corridor provided)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="private" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Are the dynamic interior rooms private? (default is true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_dynamic_interior_persistent">
        <xs:annotation>
          <xs:documentation>
            Set a dynamic interior to be persistent so that it won't be cleaned up when the player leaves its vicinity
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Object containing the interior (any one of interior, corridor or room component can be supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="interior" type="expression">
            <xs:annotation>
              <xs:documentation>
                Interior to set persistence for
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="corridor" type="expression">
            <xs:annotation>
              <xs:documentation>
                Corridor used to find interior to set persistence for (ignored if interior provided)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="room" type="expression">
            <xs:annotation>
              <xs:documentation>
                Room used to find interior to set persistence for (ignored if interior or corridor provided)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="persistent" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Should the dynamic interior rooms be persistent? (default is true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="create_control_entity">
        <xs:annotation>
          <xs:documentation>
            Create a control entity for the specified object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:group ref="createnpc" />
          <xs:attributeGroup ref="createnpc" />
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="name" type="lvaluename" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="post" type="controlpost" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="create_npc_from_template">
        <xs:annotation>
          <xs:documentation>
            Create a NPC from a NPC template on an object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="position" type="position" minOccurs="0" maxOccurs="1" />
            <xs:element name="rotation" type="rotation" minOccurs="0" maxOccurs="1" />
          </xs:sequence>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="name" type="lvaluename" use="optional" />
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Object containing the NPC template. If 'slot' and 'placementobject' not provided, NPC will attempt to be placed on 'object'
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="template" type="expression" use="required" />
          <xs:attribute name="owner" type="faction" use="required" />
          <xs:attribute name="placementobject" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Object or room to place the new actor if 'slot' not provided
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="slot" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Room slot
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="setroomslot" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Set the roomslot of the actor to the provided slot if it is a valid NPC slot (defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="triggeranimation" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Trigger the default animations for this room slot on the actor (defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="chairtrigger" use="optional">
            <xs:annotation>
              <xs:documentation>
                Activation state for the chair if the slot is a chair slot (defaults to 'activate_chair'. Using 'invalid' will keep the chair in it current activation state)
              </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="activate_chair">
                  <xs:annotation>
                    <xs:documentation>
                      Have the chair animate to its active position
                    </xs:documentation>
                  </xs:annotation>
                </xs:enumeration>
                <xs:enumeration value="deactivate_chair">
                  <xs:annotation>
                    <xs:documentation>
                      Have the chair animation to its inactive position
                    </xs:documentation>
                  </xs:annotation>
                </xs:enumeration>
                <xs:enumeration value="invalid">
                  <xs:annotation>
                    <xs:documentation>
                      Have the chair remain in its current activation state
                    </xs:documentation>
                  </xs:annotation>
                </xs:enumeration>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="required" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Is the npc required to be successfully created and placed in a room? (defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name ="release_npc_template_from_crew_exchange">
        <xs:annotation>
          <xs:documentation>
            Cancel a scheduled crew transfer for this person
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Object containing the NPC template
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="template" type="expression" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="create_npc_template">
        <xs:annotation>
          <xs:documentation>
            Create a NPC template and place it on an object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="name" type="lvaluename" use="optional" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="otherobject" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Other object to contain an existing template if 'template' is prodived. If 'otherobject' is not provided, default to 'object'
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="entity" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                NPC to use as a base when creating the template - Must be provided if 'template' or 'macro' is not
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="template" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Existing NPC template to base when creating the template (taken from either 'object' or 'otherobject' if provided) - Must be provided if 'entity' or 'macro' is not
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="macro" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Macro of the new NPC template - Must be provided if 'entity' or 'template' is not
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="role" type="entityroleexprlookup" use="optional">
            <xs:annotation>
              <xs:documentation>
                Entity role this template will be set to
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="force" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Force the template to be added even if there is no available space
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_npc_template">
        <xs:annotation>
          <xs:documentation>
            Remove a NPC template from an object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="template" type="expression" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="cutscene_event">
        <xs:annotation>
          <xs:documentation>
            Send an event to a running cutscene
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="key" type="cutscenekey" use="required" />
          <xs:attribute name="event" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Event string that is sent to the cutscene
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="debug_text">
        <xs:annotation>
          <xs:documentation>
            Output debug text
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="text" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Text
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="context" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Include the context of this debug_text (defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="filter">
            <xs:annotation>
              <xs:documentation>
                Debug output filter (optional, default is scripts)
              </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="error" />
                <xs:enumeration value="general" />
                <xs:enumeration value="scripts" />
                <xs:enumeration value="scripts_verbose" />
                <xs:enumeration value="economy_verbose" />
                <xs:enumeration value="combat" />
                <xs:enumeration value="savegame" />
                <xs:enumeration value="none" />
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="debug_to_file">
        <xs:annotation>
          <xs:documentation>
            Output debug text to logfile in game\logs folder under My Documents\Egosoft. Text will only be logged to a file if the game has been started with parameter -scriptlogfiles !
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="text" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Text
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="name" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Filename (required, allowed extensions: .txt, .csv, .log and .xml - otherwise .txt is appended automatically.)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="directory" type="expression">
            <xs:annotation>
              <xs:documentation>
                Sub-Directory of logs folder (optional, defaults to blank)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="append" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Controls whether the text should be appended to an existing logfile of the same name or overwrite and create a new file (optional, defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="output" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Controls whether the text should also be written to the regular 'scripts' debug output (optional, defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="deplete_yield">
        <xs:annotation>
          <xs:documentation>
            Deplete yield for a certain ware in a zone of a specific region. If container is provided, attempt to add the wares to it (which may affect the deleted amount)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="position" type="position" minOccurs="1" maxOccurs="1" />
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="sector" type="object" use="required" />
          <xs:attribute name="container" type="expression">
            <xs:annotation>
              <xs:documentation>
                If provided, the wares will attempt to be added to the container object. The wares successfully transferred will then be depleted from the region
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="ware" type="object" use="required" />
          <xs:attribute name="amount" type="lvaluename" use="required" >
            <xs:annotation>
              <xs:documentation>
                Amount to be drained from the region, this value will contain the actual amount that was drained after the command has been executed
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="get_highest_resource_yield">
        <xs:annotation>
          <xs:documentation>
            Get the highest local resource yield in a sector
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="ware" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The ware for which to get the highest yield
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="yieldname" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The name of the yield definition (see libraries/regionyields.xml for valid values)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="sector" type="sector" use="required">
            <xs:annotation>
              <xs:documentation>
                Where to look for the resource in.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                The highest yield value (total amount in a box with 32km long edges)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="get_resource_gatherrate">
        <xs:annotation>
          <xs:documentation>
            Determine rate at which the refobject can drain resources from the supplied region in the specified zone (averaged using available colletector drones)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="position" type="position" minOccurs="1" maxOccurs="1" />
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="sector" type="object" use="required" />
          <xs:attribute name="ware" type="object" use="required" />
          <xs:attribute name="refobject" type="object" use="required" />
          <xs:attribute name="scantime" type="expression">
            <xs:annotation>
              <xs:documentation>
                The time this ship spends scanning for a mineable object (only applies to mineral mining, defaults to 0s)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="name" type="lvaluename" use="required" >
            <xs:annotation>
              <xs:documentation>
                Rate at which the specified resource can be drained from the region by the refobject (float)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="add_anomaly_destination">
        <xs:annotation>
          <xs:documentation>
            Add an anomaly as a set destination of another. The destination will be picked at random on transition.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="anomaly" type="object" use="required" />
          <xs:attribute name="destination" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="destroy_object">
        <xs:annotation>
          <xs:documentation>
            Destroy specified object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="explosion" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Show explosion effect? Default is false
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="destroy_group">
        <xs:annotation>
          <xs:documentation>
            Destroy specified group
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="group" type="group" use="required" />
          <xs:attribute name="explosion" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Show explosion effect? Default is false
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="restore_object">
        <xs:annotation>
          <xs:documentation>
            Restore specified object from the wreck state
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="hull" type="expression">
            <xs:annotation>
              <xs:documentation>
                The hull value to set after restoring the object
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="recursive" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Recursivly repair contained components (default = false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="disable_collisions_between">
        <xs:annotation>
          <xs:documentation>
            Disable collisions between the object and the target
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="target" type="targetcomponent" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="disable_collision_response">
        <xs:annotation>
          <xs:documentation>
            Does all collision checks but disables all reaction to the checks = no collision. Only works for objects in visible attention.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="dock">
        <xs:annotation>
          <xs:documentation>
            Dock ship instantly at the pre-selected docking bay (&lt;request_docking&gt; must have been performed successfully before!)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="ship" type="ship" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="drop_cargo">
        <xs:annotation>
          <xs:documentation>
            Drop ware from cargo bay (if possible)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="random" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="ware" type="dropware" use="required" />
          <xs:attributeGroup ref="dropcargo" />
        </xs:complexType>
      </xs:element>

      <xs:element name="drop_illegal_cargo">
        <xs:annotation>
          <xs:documentation>
            Drop all illegal cargo from cargo bay
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="faction" type="faction">
            <xs:annotation>
              <xs:documentation>
                Faction to check ware legality against (optional, if omitted only wares that are globally illegal will be dropped)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attributeGroup ref="dropcargo" />
        </xs:complexType>
      </xs:element>

      <xs:element name="drop_illegal_inventory">
        <xs:annotation>
          <xs:documentation>
            Drop all illegal wares from entity inventory
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="faction" type="faction">
            <xs:annotation>
              <xs:documentation>
                Faction to check ware legality against (optional, if omitted only wares that are globally illegal will be dropped)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="macro" type="expression">
            <xs:annotation>
              <xs:documentation>
                Lockbox macro (optional, if omitted wares will spawn as ordinary drops)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attributeGroup ref="dropcargo" />
        </xs:complexType>
      </xs:element>

      <xs:element name="drop_inventory">
        <xs:annotation>
          <xs:documentation>
            Drop ware from inventory (if possible)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="random" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="ware" type="dropware" use="required" />
          <xs:attribute name="macro" type="expression">
            <xs:annotation>
              <xs:documentation>
                Lockbox macro (optional, if omitted wares will spawn as ordinary drops)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attributeGroup ref="dropcargo" />
        </xs:complexType>
      </xs:element>

      <xs:element name="eject_npcs">
        <xs:annotation>
          <xs:documentation>
            Eject all NPCs from the object (they will use escape pods. Cannot be used for ship_xs!)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="force" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Force the pods to spawn even if the object is not capturable?
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="eject_people">
        <xs:annotation>
          <xs:documentation>
            Eject all people (passengers) from the object (they will use escape pods. Cannot be used for ship_xs!)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="attacker" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Attacker that causes people to eject (optional)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="max" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Maximum number of people to eject (eject all if not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="role" type="entityrole" use="optional"/>
          <xs:attribute name="level" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Skill level to match people with others of their tier.
				        Only valid when used with attribute 'role'
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="force" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Force the pods to spawn even if the object is not capturable?
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="enable_collisions_between">
        <xs:annotation>
          <xs:documentation>
            Disable collisions between the object and the target
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="target" type="targetcomponent" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="find_actor_interaction_point">
        <xs:annotation>
          <xs:documentation>
            Find a suitable NPC position near an object to interact with it.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="actor" type="actor" use="required" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="slot" type="expression">
            <xs:annotation>
              <xs:documentation>
                Slot to connect the NPC to - returned offset is relative to this slot
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="posname" type="lvaluename" use="required" />
          <xs:attribute name="rotname" type="lvaluename" />
        </xs:complexType>
      </xs:element>

      <xs:element name="find_asteroid_in_cluster">
        <xs:annotation>
          <xs:documentation>
            Find asteroid in cluster near specified position
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="position" type="position" minOccurs="0" maxOccurs="1" />
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="cluster" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Cluster
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="refobject" type="expression">
            <xs:annotation>
              <xs:documentation>
                Reference object or space (defaults to cluster if not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="canpickup" type="boolean" >
            <xs:annotation>
              <xs:documentation>
                Whether this should return a rock that can be collected or an asteroid that needs to be broken up first
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="multiple" type="boolean" >
            <xs:annotation>
              <xs:documentation>
                If true the command will return a list of asteroids and will automatically do a view check, see viewangle and maxdistance attributes!
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="viewangle" type="expression" >
            <xs:annotation>
              <xs:documentation>
                If multiple is true this controls the forward angle to see if asteroids are in range (defaults to 30°)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="maxdistance" type="expression" >
            <xs:annotation>
              <xs:documentation>
                If multiple is true this controls the maximum distance at which asteroids can be found (defaults to 3000m)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="ware" type="expression" >
            <xs:annotation>
              <xs:documentation>
                Only include asteroids that contain the specified ware as resource (ignored by default)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="name" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="find_buy_offer">
        <xs:annotation>
          <xs:documentation>
            Find matching buy offer(s)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchtrade">
              <xs:attributeGroup ref="action" />
              <xs:attribute name="result" type="lvaluename" use="required" />
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attribute name="tradepartner" type="container">
                <xs:annotation>
                  <xs:documentation>
                    object that will do the trading (usually a trade ship)
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="buyer" type="container">
                <xs:annotation>
                  <xs:documentation>
                    (optional) only find buy offers on this buyer
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="seller" type="container">
                <xs:annotation>
                  <xs:documentation>
                    (optional) filter for wares that the seller produces (and does not need itself)
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="space" type="space">
                <xs:annotation>
                  <xs:documentation>
                    (optional) zone or sector in which to look for offers, defaults to zone of tradepartner
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="excludeempty" type="boolean">
                <xs:annotation>
                  <xs:documentation>
                    (optional) exclude empty trade offers (amount = 0, desired amount > 0)? (defaults to true)
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="excludemissions" type="booleanexpression">
                <xs:annotation>
                  <xs:documentation>
                    (optional) exclude mission trade offers? (defaults to true)
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="usereservations" type="boolean">
                <xs:annotation>
                  <xs:documentation>
                    (optional) take reservations into account when checking if a trade is empty? (defaults to true)
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="find_closest_octree_object">
        <xs:annotation>
          <xs:documentation>
            Find closest object that has an octree
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="action" />
              <xs:attributeGroup ref="findobject" />
              <xs:attribute name="name" type="lvaluename" use="required" />
              <xs:attribute name="refobject" type="expression" use="required">
                <xs:annotation>
                  <xs:documentation>
                    Reference object for distance check
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="find_closest_resource">
        <xs:annotation>
          <xs:documentation>
            Find closest resource
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="refposition" type="position" minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
                  After evaluation this position will be treated as relative to refobject.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="ware" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                a single ware or list of wares that needs to be available as a resource in the region
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="minamount" type="expression" >
            <xs:annotation>
              <xs:documentation>
                (optional) minimum resource yield that the region/zone needs to provide
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="refobject" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Reference object for distance check
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="wares" type="expression" >
            <xs:annotation>
              <xs:documentation>
                (optional, resultvalue) list of all the resources that can be gathered in the found zone
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="zone" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                (resultvalue) the zone where the requested resource can be found (mutually exclusive with sector)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="sector" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                (resultvalue) the sector where the requested resource can be found (mutually exclusive with zone)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="distance" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                (resultvalue) distance from the refposition to to the result position
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="position" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                (resultvalue) the position relative to the returned space (sector or zone) where the requested resource can be found
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="find_closest_station_part">
        <xs:annotation>
          <xs:documentation>
            Find closest part of a station
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="action" />
              <xs:attributeGroup ref="findarbitrary" />
              <xs:attribute name="station" type="object" use="required" />
              <xs:attribute name="name" type="lvaluename" use="required" />
              <xs:attribute name="refobject" type="expression" use="required">
                <xs:annotation>
                  <xs:documentation>
                    Reference object for distance check
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="find_closest_undiscovered_position">
        <xs:annotation>
          <xs:documentation>
            Find the closest position in a sector that the player hasn't uncovered yet. May return null if none exists.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="position" type="position" minOccurs="1" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
                  The reference position in sector coordinates.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="rangecenter" type="position" minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
                  The center of the valid range in sector coordinates. Required if and only if range is valid.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="sector" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The sector in which to look for undiscovered areas.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="range" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                (optional) The range in which to look for undiscovered hexes. Also requires rangecenter to be valid.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                The center of the nearest undiscovered hex in sector coordinates if there is one within range, null if there is none.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="find_cluster">
        <xs:annotation>
          <xs:documentation>
            Find matching cluster(s)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="action" />
              <xs:attributeGroup ref="findcluster" />
              <xs:attribute name="append" type="findappend" />
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attribute name="required" type="findrequired" />
              <xs:attributeGroup ref="sortresultwithlimit" />
              <xs:attribute name="name" type="lvaluename" />
              <xs:attribute name="groupname" type="groupname" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="find_cluster_in_range">
        <xs:annotation>
          <xs:documentation>
            Find matching cluster(s) within 'maxdistance' jumps of 'object'
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="action" />
              <xs:attributeGroup ref="findcluster" />
              <xs:attribute name="append" type="findclusterappend">
                <xs:annotation>
                  <xs:documentation>
                    If true then the found clusters are appended to 'name' list and 'distances' table. Should the values 'name' or 'distances' not be a list or table respectively, they will become one, losing their previous value (default false)
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attribute name="mindistance" type="expression" use="optional">
                <xs:annotation>
                  <xs:documentation>
                    Minimum number of Jump Gates or Orbital Accelerators to 'object'
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="maxdistance" type="expression" use="optional">
                <xs:annotation>
                  <xs:documentation>
                    Maximum number of Jump Gates or Orbital Accelerators to 'object' (omit to have no jump distance limit)
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="object" type="expression" use="required">
                <xs:annotation>
                  <xs:documentation>
                    Object or Cluster to check jump distances to
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="name" type="lvaluename" />
              <xs:attribute name="distances" type="lvalueexpression">
                <xs:annotation>
                  <xs:documentation>
                    Result table of clusters and distances (key = cluster, value = jump distance)
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="groupname" type="groupname" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="find_sector_in_range">
        <xs:annotation>
          <xs:documentation>
            Find matching sector(s) within 'maxdistance' jumps of 'object'
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="action" />
              <xs:attributeGroup ref="findsector" />
              <xs:attribute name="append" type="findsectorappend">
                <xs:annotation>
                  <xs:documentation>
                    If true then the found sectors are appended to 'name' list and 'distances' table. Should the values 'name' or 'distances' not be a list or table respectively, they will become one, losing their previous value (default false)
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attribute name="mindistance" type="expression" use="optional">
                <xs:annotation>
                  <xs:documentation>
                    Minimum number of Jump Gates, Orbital Accelerators or Super Highway Entry Gates to 'object'
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="maxdistance" type="expression" use="optional">
                <xs:annotation>
                  <xs:documentation>
                    Maximum number of Jump Gates, Orbital Accelerators or Super Highway Entry Gates to 'object' (omit to have no jump distance limit)
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="object" type="expression" use="required">
                <xs:annotation>
                  <xs:documentation>
                    Object or Sector to check jump distances to
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="name" type="lvaluename" />
              <xs:attribute name="distances" type="lvalueexpression">
                <xs:annotation>
                  <xs:documentation>
                    Result table of sectors and distances (key = sector, value = jump distance)
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="groupname" type="groupname" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="find_connected_macro">
        <xs:annotation>
          <xs:documentation>
            Search a macro for a connected macro or macros, optionally of a certain type.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="name" type="lvaluename" use="required" />
          <xs:attribute name="macro" type="expression" use="required" />
          <xs:attribute name="class" type="expression">
            <xs:annotation>
              <xs:documentation>
                Add a class filter to the search so that only children of a certain class are returned. If not provided, all children will be returned.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="multiple" type="findmultiple" />
        </xs:complexType>
      </xs:element>

      <xs:element name="find_room">
        <xs:annotation>
          <xs:documentation>
            Find matching room(s)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="action" />
              <xs:attributeGroup ref="findroom" />
              <xs:attribute name="object" type="objectlist" use="required" />
              <xs:attribute name="append" type="findappend" />
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attribute name="required" type="findrequired" />
              <xs:attributeGroup ref="sortresultwithlimit" />
              <xs:attribute name="name" type="lvaluename" />
              <xs:attribute name="groupname" type="groupname" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="find_dockingbay">
        <xs:annotation>
          <xs:documentation>
            Find matching dock(s)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="action" />
              <xs:attributeGroup ref="find" />
              <xs:attribute name="object" type="objectlist" use="required" />
              <xs:attribute name="append" type="findappend" />
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attribute name="required" type="findrequired" />
              <xs:attributeGroup ref="sortresultwithlimit" />
              <xs:attribute name="name" type="lvaluename" />
              <xs:attribute name="groupname" type="groupname" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="find_dockingbay_for_trade">
        <xs:annotation>
          <xs:documentation>
            Find dockingbay for trade
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="name" type="lvaluename" use="required" />
          <xs:attribute name="tradepartner" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Trader ship
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="tradeoffer" type="tradeoffer" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="find_closest_dockingbay">
        <xs:annotation>
          <xs:documentation>
            Find dockingbay for trade
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="name" type="lvaluename" use="required" />
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Dock object (Container, DockArea or BuildModule)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="ship" type="ship" use="required" />
          <xs:attribute name="free" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether the dock to be found must be free, defaults to false
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="requiredocking" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether the dock to be found must support docking, defaults to false
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="requireundocking" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether the dock to be found must support undocking, defaults to false
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="requirebuilding" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether the dock to be found must support building, defaults to false
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="requiretrading" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether the dock to be found must support trading, defaults to false
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="allowplayeronly" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether the dock to be found may also be one that only allows the player to dock, defaults to false
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="ventureronly" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Whether the dock to be found must be exclusively meant for venturing, defaults to false
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="ventureplatform" type="expression">
            <xs:annotation>
              <xs:documentation>
                Specific venture platform with which venture dock must be associated (can be null)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="highpriority" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Whether to find a high priority dock, defaults to false (will fall back to the other kind of dock if no matching ones exist)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="find_gravidar_contact">
        <xs:annotation>
          <xs:documentation>
            Find gravidar contact(s)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="action" />
              <xs:attributeGroup ref="findobject" />
              <xs:attribute name="object" type="expression" use="required">
                <xs:annotation>
                  <xs:documentation>
                    Scanning object
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="append" type="findappend" />
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attributeGroup ref="sortresultwithlimit" />
              <xs:attribute name="name" type="lvaluename" />
              <xs:attribute name="groupname" type="groupname" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="find_signalleak_location">
        <xs:annotation>
          <xs:documentation>
            Find signal leak locations at an object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="name" type="lvaluename" use="required" />
          <xs:attribute name="append" type="findappend" />
          <xs:attribute name="multiple" type="findmultiple" />
          <xs:attribute name="required" type="findrequired" />
          <xs:attribute name="container" type="object" use="required" />
          <xs:attribute name="excludefilled" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Do not include slots currently filled by a signal leak (defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="find_npc_slot">
        <xs:annotation>
          <xs:documentation>
            Find npc slot in an object, walkable module or room
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="name" type="lvaluename" use="required" />
          <xs:attribute name="append" type="findappend" />
          <xs:attribute name="multiple" type="findmultiple" />
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Container or room
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="post" type="controlpost" use="optional" />
          <xs:attribute name="role" type="entityrole" use="optional" />
          <xs:attribute name="anytag" type="expression" use="optional" />
          <xs:attribute name="tags" type="expression" use="optional" />
          <xs:attribute name="excludefilled" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Do not include slots currently reserved by a NPC (defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="excludeblocked" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Do not include slots which are blocked by obstacles such as props (defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="find_npc_waypoint">
        <xs:annotation>
          <xs:documentation>
            Find npc waypoint in an object, walkable module or room
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="name" type="lvaluename" use="required" />
          <xs:attribute name="append" type="findappend" />
          <xs:attribute name="multiple" type="findmultiple" />
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Container or room
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="anytag" type="expression" use="optional" />
          <xs:attribute name="tags" type="expression" use="optional" />
          <xs:attribute name="excludeblocked" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Do not include slots which are blocked by obstacles such as props (defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="get_floor_position">
        <xs:annotation>
          <xs:documentation>
            Get the closest valid floor position for a NPC (requires the object to have active physics)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="position" type="position" minOccurs="1" maxOccurs="1" />
            <xs:element name="result" minOccurs="1" maxOccurs="1">
              <xs:complexType>
                <xs:attribute name="context" type="lvalueexpression" use="required">
                  <xs:annotation>
                    <xs:documentation>
                      The component which is used for entity navigation at the 'position' result value
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="position" type="lvalueexpression" use="required">
                  <xs:annotation>
                    <xs:documentation>
                      The floor position relative to the 'context' result value
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="room" type="lvalueexpression" use="optional">
                  <xs:annotation>
                    <xs:documentation>
                      The room related to the result floor position. Result position is not necessarily relative to it.
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="tags" type="lvalueexpression" use="optional">
                  <xs:annotation>
                    <xs:documentation>
                      List of floor tag at the result position
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="find_crate_slot">
        <xs:annotation>
          <xs:documentation>
            Find a crate slot in a walkable module or room
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="name" type="lvaluename" use="required" />
          <xs:attribute name="append" type="findappend" />
          <xs:attribute name="multiple" type="findmultiple" />
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Container or room
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="tags" type="expression" use="optional" />
          <xs:attribute name="excludefilled" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Do not include slots currently taken by a crate (defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="find_prop_slot">
        <xs:annotation>
          <xs:documentation>
            Find a prop slot in a room
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="name" type="lvaluename" use="required" />
          <xs:attribute name="append" type="findappend" />
          <xs:attribute name="multiple" type="findmultiple" />
          <xs:attribute name="room" type="room" use="required"/>
          <xs:attribute name="tags" type="expression" use="optional" />
        </xs:complexType>
      </xs:element>

      <xs:element name="find_player_transporter_slot">
        <xs:annotation>
          <xs:documentation>
            Find player transporter slot in a ship or room. Note that such slots are distinct from NPC waypoint/transport slots.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="name" type="lvaluename" use="required" />
          <xs:attribute name="append" type="findappend" />
          <xs:attribute name="multiple" type="findmultiple" />
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Ship or room (e.g. cockpit, dockingbay). A ship should only be provided if the cockpit is virtual, i.e. if the cockpit slots are actually on the ship instead of the cockpit.
                It is safe to provide a cockpit even if it's virtual - in this case, the matching slot will be found on the ship itself.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="tags" type="expression" use="optional" />
        </xs:complexType>
      </xs:element>

      <xs:element name="find_object_component">
        <xs:annotation>
          <xs:documentation>
            Find matching component(s) contained in an object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="action" />
              <xs:attributeGroup ref="findarbitrary" />
              <xs:attribute name="object" type="objectlist" use="required" />
              <xs:attribute name="append" type="findappend" />
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attribute name="required" type="findrequired" />
              <xs:attribute name="recursive" type="findrecursive" />
              <xs:attribute name="includeobjects" type="findincludeobjects" />
              <xs:attributeGroup ref="sortresultwithlimit" />
              <xs:attribute name="name" type="lvaluename" />
              <xs:attribute name="groupname" type="groupname" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="find_resource">
        <xs:annotation>
          <xs:documentation>
            Find resource (random location in cluster)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="ware" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                a single ware or list of wares that needs to be available as a resource in the region
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="minamount" type="expression" >
            <xs:annotation>
              <xs:documentation>
                (optional) minimum resource yield that the region/zone needs to provide
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="refobject" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Reference object for distance check or a cluster for all contained regions
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="snap" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                (optional) snap result position to the size of a region grid (defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="wares" type="expression" >
            <xs:annotation>
              <xs:documentation>
                (optional, resultvalue) list of all the resources that can be gathered in the found zone. If used with multiple="true", gives a list of lists of resources synchronized with the zone list from $zone.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="zone" type="expression">
            <xs:annotation>
              <xs:documentation>
                (resultvalue) the zone where the requested resource can be found (mutually exclusive with sector)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="sector" type="expression">
            <xs:annotation>
              <xs:documentation>
                (resultvalue) the sector where the requested resource can be found (mutually exclusive with zone)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="position" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                (resultvalue) the position relative to the returned space (sector or zone) where the requested resource can be found
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="check_object">
        <xs:annotation>
          <xs:documentation>
            Check an object against filters
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="action" />
              <xs:attributeGroup ref="findarbitrary" />
              <!-- <xs:attribute name="space" type="space" /> -->
              <xs:attribute name="object" type="expression" use="required"/>
              <xs:attribute name="result" type="lvaluename" use="required"/>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="end_repair_mass_traffic">
        <xs:annotation>
          <xs:documentation>
            Ends all repair mass traffic networks for an object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="endtime" type="expression">
            <xs:annotation>
              <xs:documentation>
                The time the network should end (defaults to 'as soon as possible' if not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="find_active_repair_mass_traffic">
        <xs:annotation>
          <xs:documentation>
            Find a repair mass traffic network for an object that doesn't have an end time set already
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="result" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                The ID of the mass traffic network - IMPORTANT: this will become invalid if a savegame is loaded
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="object" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="find_pos_in_mass_traffic_at_time">
        <xs:annotation>
          <xs:documentation>
            Find position in mass traffic network where the object would be at the specified time (only works for ships originating from mass traffic!)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="name" type="lvaluename" use="required" />
          <xs:attribute name="zone" type="zone" use="required" />
          <xs:attribute name="object" type="ship" use="required" />
          <xs:attribute name="time" type="expression" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="find_random_pos_in_mass_traffic">
        <xs:annotation>
          <xs:documentation>
            Find random position in mass traffic network
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="name" type="lvaluename" use="required" />
          <xs:attribute name="zone" type="zone" use="required" />
          <xs:attribute name="start" type="expression">
            <xs:annotation>
              <xs:documentation>
                Minimal time after beginning of path
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="end" type="expression">
            <xs:annotation>
              <xs:documentation>
                Minimal time until end of path
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="find_object">
        <xs:annotation>
          <xs:documentation>
            Find matching object(s)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="action" />
              <xs:attributeGroup ref="findobject" />
              <xs:attribute name="space" type="spacelist" use="required" />
              <xs:attribute name="append" type="findappend" />
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attribute name="required" type="findrequired" />
              <xs:attribute name="recursive" type="findrecursive" />
              <xs:attributeGroup ref="sortresultwithlimit" />
              <xs:attribute name="name" type="lvaluename" />
              <xs:attribute name="groupname" type="groupname" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="find_sector">
        <xs:annotation>
          <xs:documentation>
            Find matching sector(s)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="action" />
              <xs:attributeGroup ref="findsector" />
              <xs:attribute name="space" type="spacelist" />
              <xs:attribute name="append" type="findappend" />
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attribute name="required" type="findrequired" />
              <xs:attributeGroup ref="sortresultwithlimit" />
              <xs:attribute name="name" type="lvaluename" />
              <xs:attribute name="groupname" type="groupname" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="find_sell_offer">
        <xs:annotation>
          <xs:documentation>
            Find matching sell offer(s)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchtrade">
              <xs:attributeGroup ref="action" />
              <xs:attribute name="result" type="lvaluename" use="required" />
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attribute name="tradepartner" type="container">
                <xs:annotation>
                  <xs:documentation>
                    object that will do the trading (usually a trade ship)
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="buyer" type="container">
                <xs:annotation>
                  <xs:documentation>
                    (optional) filter for wares that the buyer can use(and does not produce itself)
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="seller" type="container">
                <xs:annotation>
                  <xs:documentation>
                    (optional) only find sell offers on this seller
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="space" type="space">
                <xs:annotation>
                  <xs:documentation>
                    (optional) zone or sector in which to look for offers, defaults to zone of tradepartner
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="excludeempty" type="boolean">
                <xs:annotation>
                  <xs:documentation>
                    (optional) exclude empty trade offers (amount = 0, desired amount > 0)? (defaults to true)
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="excludemissions" type="booleanexpression">
                <xs:annotation>
                  <xs:documentation>
                    (optional) exclude mission trade offers? (defaults to true)
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="usereservations" type="boolean">
                <xs:annotation>
                  <xs:documentation>
                    (optional) take reservations into account when checking if a trade is empty? (defaults to true)
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="find_ship">
        <xs:annotation>
          <xs:documentation>
            Find matching ship(s)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="action" />
              <xs:attributeGroup ref="findship" />
              <xs:attribute name="space" type="spacelist" use="required" />
              <xs:attribute name="append" type="findappend" />
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attribute name="required" type="findrequired" />
              <xs:attribute name="recursive" type="findrecursive" />
              <xs:attributeGroup ref="sortresultwithlimit" />
              <xs:attribute name="name" type="lvaluename" />
              <xs:attribute name="groupname" type="groupname" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="find_ship_by_true_owner">
        <xs:annotation>
          <xs:documentation>
            Find matching ship(s) by true owner faction. More efficient than using find_ship with 'trueowner' filter. 'space' must be of class Space.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="action" />
              <xs:attributeGroup ref="findship" />
              <xs:attribute name="faction" type="factionexprlookup" use="required">
                <xs:annotation>
                  <xs:documentation>
                    True owner faction
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="space" type="spacelist" use="required" />
              <xs:attribute name="append" type="findappend" />
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attribute name="required" type="findrequired" />
              <xs:attributeGroup ref="sortresultwithlimit" />
              <xs:attribute name="name" type="lvaluename" />
              <xs:attribute name="groupname" type="groupname" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="find_station">
        <xs:annotation>
          <xs:documentation>
            Find matching station(s)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="action" />
              <xs:attributeGroup ref="findstation" />
              <xs:attribute name="space" type="spacelist" use="required" />
              <xs:attribute name="append" type="findappend" />
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attribute name="required" type="findrequired" />
              <xs:attributeGroup ref="sortresultwithlimit" />
              <xs:attribute name="name" type="lvaluename" />
              <xs:attribute name="groupname" type="groupname" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="find_station_by_true_owner">
        <xs:annotation>
          <xs:documentation>
            Find matching station(s) by true owner faction. More efficient than using find_station with the 'trueowner' filter. 'space' must be of class Space.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="action" />
              <xs:attributeGroup ref="findstation" />
              <xs:attribute name="faction" type="factionexprlookup" use="required">
                <xs:annotation>
                  <xs:documentation>
                    True owner faction
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
              <xs:attribute name="space" type="spacelist" use="required" />
              <xs:attribute name="append" type="findappend" />
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attribute name="required" type="findrequired" />
              <xs:attributeGroup ref="sortresultwithlimit" />
              <xs:attribute name="name" type="lvaluename" />
              <xs:attribute name="groupname" type="groupname" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="find_gate">
        <xs:annotation>
          <xs:documentation>
            Find matching gate(s)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="action" />
              <xs:attributeGroup ref="find" />
              <xs:attribute name="space" type="spacelist" use="required" />
              <xs:attribute name="append" type="findappend" />
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attribute name="required" type="findrequired" />
              <xs:attributeGroup ref="sortresultwithlimit" />
              <xs:attribute name="name" type="lvaluename" />
              <xs:attribute name="groupname" type="groupname" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="find_tradeoffer_parking_slot">
        <xs:annotation>
          <xs:documentation>
            Find tradeoffer location parking ComponentSlot
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="object" type="object" use="required" >
            <xs:annotation>
              <xs:documentation>
                Object (container) that has the tradeoffer locations.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="refobject" type="object" >
            <xs:annotation>
              <xs:documentation>
                (optional) If supplied the list of slots will be sorted by distance to refobject.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="trade" type="tradeoffer" >
            <xs:annotation>
              <xs:documentation>
                (optional) If supplied the slot for this trade will be preferred.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="includeoccupied" type="boolean" >
            <xs:annotation>
              <xs:documentation>
                Include slots that are marked as occupied (defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="multiple" type="findmultiple" />
          <xs:attribute name="name" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="find_highway">
        <xs:annotation>
          <xs:documentation>
            Find matching highways(s)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="action" />
              <xs:attributeGroup ref="find" />
              <xs:attribute name="space" type="spacelist" />
              <xs:attribute name="append" type="findappend" />
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attribute name="required" type="findrequired" />
              <xs:attributeGroup ref="sortresultwithlimit" />
              <xs:attribute name="name" type="lvaluename" />
              <xs:attribute name="groupname" type="groupname" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="find_zone">
        <xs:annotation>
          <xs:documentation>
            Find matching zone(s) - excludes highways
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="action" />
              <xs:attributeGroup ref="findzone" />
              <xs:attribute name="space" type="spacelist" />
              <xs:attribute name="append" type="findappend" />
              <xs:attribute name="multiple" type="findmultiple" />
              <xs:attribute name="required" type="findrequired" />
              <xs:attributeGroup ref="sortresultwithlimit" />
              <xs:attribute name="name" type="lvaluename" />
              <xs:attribute name="groupname" type="groupname" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="fire_turret">
        <xs:annotation>
          <xs:documentation>
            Fire turret
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="turret" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Turret
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="get_attackstrength">
        <xs:annotation>
          <xs:documentation>
            Get attack strength against target
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="result" minOccurs="0" maxOccurs="1">
              <xs:complexType>
                <xs:attribute name="hullshield" type="lvalueexpression" use="optional">
                  <xs:annotation>
                    <xs:documentation>
                      Attack strength applied to hull and shields
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="hullonly" type="lvalueexpression" use="optional">
                  <xs:annotation>
                    <xs:documentation>
                      Attack strength applied to hull only
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="shieldonly" type="lvalueexpression" use="optional">
                  <xs:annotation>
                    <xs:documentation>
                      Attack strength applied to shields only
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="hullnoshield" type="lvalueexpression" use="optional">
                  <xs:annotation>
                    <xs:documentation>
                      Attack strength applied to hull only if no shields are present
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="target" type="object" use="required" />
          <xs:attribute name="usedrones" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Include damage of defence drones (defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Approximate total attack strength as a single value
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="get_character_definition">
        <xs:annotation>
          <xs:documentation>
            Get character macro or reference by filtering via category parameters
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="faction" type="factionexprlookup">
            <xs:annotation>
              <xs:documentation>
                Faction or list of factions
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="tags" type="expression">
            <xs:annotation>
              <xs:documentation>
                Specification tag or list of tags
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="race" type="raceexprlookup">
            <xs:annotation>
              <xs:documentation>
                Race
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="multiple" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Find multiple definitions? If true, the result values return a list. If false (default), the results returns a single value.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="macro" type="lvalueexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Result macro (list if 'multiple' is true. Less performant than 'reference')
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="reference" type="lvalueexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Result character reference (list if 'multiple' is true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="get_crew_exchange_lists">
        <xs:annotation>
          <xs:documentation>
            Get the lists of people to be exchanged between the &quot;trader&quot; and the &quot;tradepartner&quot; of a ship-to-ship crew exchange trade.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="result">
              <xs:complexType>
                <xs:attribute name="trader" type="lvalueexpression">
                  <xs:annotation>
                    <xs:documentation>
                      Result list of people on the object to be transferred to the tradepartner ship
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="tradepartner" type="lvalueexpression">
                  <xs:annotation>
                    <xs:documentation>
                      Result list of people on the tradepartner ship to be transferred to the object
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The ship (trader) that performs the crew exchange to and from the other ship (tradepartner)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="trade" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The crew exchange trade deal
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="get_docking_approach_pos">
        <xs:annotation>
          <xs:documentation>
            Get docking approach pos
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="ship" type="ship" use="required" />
          <xs:attribute name="dock" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Docking bay component slot (find using &lt;find_dockingbay&gt;)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="position" type="lvaluename" use="required" />
          <xs:attribute name="rotation" type="lvaluename" />
        </xs:complexType>
      </xs:element>

      <xs:element name="get_gate_approach_pos">
        <xs:annotation>
          <xs:documentation>
            Get gate approach pos
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="ship" type="ship" use="required" />
          <xs:attribute name="gate" type="expression" use="required" >
            <xs:annotation>
              <xs:documentation>
                Jumpgate
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="position" type="lvaluename" use="required" />
          <xs:attribute name="rotation" type="lvaluename" />
        </xs:complexType>
      </xs:element>

      <xs:element name="get_global_path">
        <xs:annotation>
          <xs:documentation>
            Get global path from start to end (multiple=0 returns first value. multiple=1 returns whole path as lists)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="start" type="componentoffset" />
            <xs:element name="end" type="componentoffset" />
          </xs:sequence>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="component" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                Result list of components if attribute multiple is used, otherwise first value
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="offset" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Result list of positions if attribute multiple is used, otherwise first value
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="multiple" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Return the whole path or the first pair of Component and offset?
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="useblacklist" type="blacklistgrouplookup" use="optional">
            <xs:annotation>
              <xs:documentation>
                Default faction sector travel blacklist group (civilian, military) to use if object doesn't have a blacklist of its own (does not use any blacklist if null or not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="refobject" type="object" use="optional" >
            <xs:annotation>
              <xs:documentation>
                Reference object for blacklist (required if useblacklist supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="uselocalhighways" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether the path should include local highway entrance/exit points or not (defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="get_jump_path">
        <xs:annotation>
          <xs:documentation>
            Get jump path from start to end (multiple=0 returns first value. multiple=1 returns whole path as lists)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="start" type="componentoffset" />
            <xs:element name="end" type="componentoffset" />
          </xs:sequence>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="component" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                Result list of components if attribute multiple is used, otherwise first value
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="offset" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Result list of positions if attribute multiple is used, otherwise first value
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="multiple" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Return the whole path or the first pair of Component and offset?
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="useblacklist" type="blacklistgrouplookup" use="optional">
            <xs:annotation>
              <xs:documentation>
                Default faction sector travel blacklist group (civilian, military) to use if object doesn't have a blacklist of its own (does not use any blacklist if null or not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="refobject" type="object" use="optional" >
            <xs:annotation>
              <xs:documentation>
                Reference object for blacklist (required if useblacklist supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="uselocalhighways" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether the path should include local highway entrance/exit points or not (defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="get_closest_highway_offset">
        <xs:annotation>
          <xs:documentation>
            Get the internal highway offset which is closest to this position
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="position" type="position" minOccurs="0" maxOccurs="1" />
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="highway" type="zone" use="required" />
          <xs:attribute name="space" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Co-ordinate space for the position (can be a space or object)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="get_safe_pos">
        <xs:annotation>
          <xs:documentation>
            Get a safe position in a zone or sector
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="zone" type="expression">
            <xs:annotation>
              <xs:documentation>
                Required if using zone coordinates (takes precedence over sector if both are specified), result will be in zone coordinates relative to this zone.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="sector" type="sector">
            <xs:annotation>
              <xs:documentation>
                Required if using sector coordinates (ignored if zone is specified), result will be in sector coordinates relative to this sector.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attributeGroup ref="safepos" />
          <xs:attribute name="result" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="get_satellite_coverage">
        <xs:annotation>
          <xs:documentation>
            Get the percentage of hexes in an area that are being covered by player-owned satellites
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="position" type="position" minOccurs="1" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
                  The center of the target area.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="radius" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The radius of the target area
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="sector" type="sector" use="required">
            <xs:annotation>
              <xs:documentation>
                The sector the position is relative to
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="get_ship_definition">
        <xs:annotation>
          <xs:documentation>
            Get ship macro or reference by filtering via category parameters
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="faction" type="factionexprlookup">
            <xs:annotation>
              <xs:documentation>
                Faction or list of factions
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="tags" type="expression">
            <xs:annotation>
              <xs:documentation>
                Specification tag or list of tags
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="size" type="shipsizeclasslookup">
            <xs:annotation>
              <xs:documentation>
                Ship size or list of sizes
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="multiple" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Find multiple definitions? If true, the result values return a list. If false (default), the results returns a single value.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="macro" type="lvalueexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Result macro (list if 'multiple' is true. Less performant than 'reference')
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="reference" type="lvalueexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Result ship reference (list if 'multiple' is true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="get_module_definition">
        <xs:annotation>
          <xs:documentation>
            Get module macro or reference by filtering via category parameters
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="faction" type="factionexprlookup">
            <xs:annotation>
              <xs:documentation>
                Faction or list of factions
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="race" type="raceexprlookup">
            <xs:annotation>
              <xs:documentation>
                Race
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="tags" type="expression">
            <xs:annotation>
              <xs:documentation>
                Specification tag or list of tags
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="ware" type="expression">
            <xs:annotation>
              <xs:documentation>
                Production ware
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="set" type="expression">
            <xs:annotation>
              <xs:documentation>
                The set from which the module should be taken. If used with reference (as opposed to macro), this attribute will have no effect.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="multiple" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Find multiple definitions? If true, the result values return a list. If false (default), the results returns a single value.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="macro" type="lvalueexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Result macro (list if 'multiple' is true. Less performant than 'reference')
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="reference" type="lvalueexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Result module reference (list if 'multiple' is true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="get_module_set_macro">
        <xs:annotation>
          <xs:documentation>
            Get station macro of a module set
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="race" type="raceexprlookup">
            <xs:annotation>
              <xs:documentation>
                Module set race
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="type" type="expression">
            <xs:annotation>
              <xs:documentation>
                Module set type string
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="set" type="expression">
            <xs:annotation>
              <xs:documentation>
                Module set ID (takes preference over 'race' or 'type')
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                Result macro
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="check_production_allowed">
        <xs:annotation>
          <xs:documentation>
            Check if a production for a specified ware is allowed to be added to an object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" />
          <xs:attribute name="ware" type="expression" />
          <xs:attribute name="result" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="get_construction_plan">
        <xs:annotation>
          <xs:documentation>
            Get construction plan from stations.xml by filtering via category parameters
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="faction" type="factionexprlookup">
            <xs:annotation>
              <xs:documentation>
                Faction or list of factions
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="race" type="raceexprlookup">
            <xs:annotation>
              <xs:documentation>
                Race
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="tags" type="expression">
            <xs:annotation>
              <xs:documentation>
                Specification tag or list of tags
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="multiple" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Find multiple definitions? If true, the result values return a list. If false (default), the results returns a single value.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                Result construction plan (list if 'multiple' is true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="rawname" type="lvalueexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Result raw name string of the construction plan (list if 'multiple' is true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="get_god_station_construction_plan">
        <xs:annotation>
          <xs:documentation>
            Get construction plan from matching station entry god.xml
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="faction" type="factionexprlookup" use="required"/>
          <xs:attribute name="space" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Space to filter for a suitable god entry by location (no location filter if null)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="type" type="modulesettypelookup" use="required">
            <xs:annotation>
              <xs:documentation>
                Module set type
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="multiple" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Find multiple definitions? If true, the result values return a list. If false (default), the results returns a single value.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                Result construction plan (list if 'multiple' is true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="rawname" type="lvalueexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Result raw name string of the construction plan (list if 'multiple' is true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="get_station_definition">
        <xs:annotation>
          <xs:documentation>
            Get station macros from stations.xml by filtering via category parameters
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="faction" type="factionexprlookup">
            <xs:annotation>
              <xs:documentation>
                Faction or list of factions
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="race" type="raceexprlookup">
            <xs:annotation>
              <xs:documentation>
                Race
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="tags" type="expression">
            <xs:annotation>
              <xs:documentation>
                Specification tag or list of tags
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="multiple" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Find multiple? If true, the result values return a list. If false (default), the results returns a single value.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="macro" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                Result macro (list if 'multiple' is true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="get_room_definition">
        <xs:annotation>
          <xs:documentation>
            Get room macro or reference by filtering via category parameters
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="race" type="raceexprlookup">
            <xs:annotation>
              <xs:documentation>
                Race
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="tags" type="expression">
            <xs:annotation>
              <xs:documentation>
                Specification tag or list of tags
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="multiple" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Find multiple definitions? If true, the result values return a list. If false (default), the results returns a single value.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="macro" type="lvalueexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Result macro (list if 'multiple' is true. Less performant than 'reference')
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="doors" type="lvalueexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Result doors (list of macroslots for a single macro, a list of lists of macroslots for multiple macros, nothing if only references are returned)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="reference" type="lvalueexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Result module reference (list if 'multiple' is true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="get_target_points">
        <xs:annotation>
          <xs:documentation>
            Get position list of matching target points from a macro
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="macro" type="macro" use="required" />
          <xs:attribute name="tags" type="expression">
            <xs:annotation>
              <xs:documentation>
                Either a single tag or a list of tags which are required for the target points
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvaluename" />
        </xs:complexType>
      </xs:element>

      <xs:element name="get_waypoint_path">
        <xs:annotation>
          <xs:documentation>
            Get position list of matching waypoints from a component, starting from a start waypoint and progressing along the links until the end is reached
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="space" type="expression" use="required" />
          <xs:attribute name="tags" type="expression">
            <xs:annotation>
              <xs:documentation>
                Either a single tag or a list of tags which are required for the waypoints
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="start_tags" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Either a single tag or a list of tags which are required for the start waypoint (matched in addition to the other required tags, if they are defined)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group" type="expression">
            <xs:annotation>
              <xs:documentation>
                Group tag
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="posname" type="lvaluename" use="required" />
          <xs:attribute name="rotname" type="lvaluename" />
          <xs:attribute name="radiusname" type="lvaluename" />
        </xs:complexType>
      </xs:element>

      <xs:element name="get_text_ids_in_range">
        <xs:annotation>
          <xs:documentation>
            Get list of text IDs in given range on a TextDB page
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="page" type="page" use="required" />
          <xs:attribute name="start" type="expression">
            <xs:annotation>
              <xs:documentation>
                Lower bound of text ID range (default is 0)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="end" type="expression">
            <xs:annotation>
              <xs:documentation>
                Upper bound of text ID range (default is no upper bound). Note that text IDs outside the signed integer range cannot be found.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="factor" type="expression">
            <xs:annotation>
              <xs:documentation>
                Factor used as a filter for found text IDs. The list will contain only text IDs that are multiples of this factor. Default is no factor.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="get_trade_parking_pos">
        <xs:annotation>
          <xs:documentation>
            Get trade parking position (for L and XL trade ships that cannot dock directly), optionally gets the quadrant of the ship where the traffic lanes are.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="ship" type="ship" use="required" />
          <xs:attribute name="tradedock" type="expression">
            <xs:annotation>
              <xs:documentation>
                Trade dock component slot (find using &lt;find_tradeoffer_parking_slot&gt;)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="approach" type="boolean" >
            <xs:annotation>
              <xs:documentation>
                Return "approach" position (defaults to false). If false, this is the position at which masstraffic lanes snap to the tradeoffer location for optimal connection.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="space" type="expression">
            <xs:annotation>
              <xs:documentation>
                Space that the resulting position and rotation should be relative to (optional, defaults to the tradeoffercomponent)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="position" type="lvaluename" use="required" />
          <xs:attribute name="rotation" type="lvaluename" />
          <xs:attribute name="quadrant" type="lvaluename" />
        </xs:complexType>
      </xs:element>

      <xs:element name="get_ware_definition">
        <xs:annotation>
          <xs:documentation>
            Get a single or multiple definitions for wares from the WareDB.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="faction" type="factionexprlookup" use="optional">
            <xs:annotation>
              <xs:documentation>
                The faction or factions for which the wares should be defined - this will filter the result down to what this faction can produce.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="flags" type="wareflags" use="optional">
            <xs:annotation>
              <xs:documentation>
                Ware flags for filtering wares
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Group ID string
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="tags" type="expression" />
          <xs:attribute name="result" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                A filtered list of wares.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="get_ware_reservation">
        <xs:annotation>
          <xs:documentation>
            Get reserved space for ware (optionally object specific) on an object.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="container" use="required">
            <xs:annotation>
              <xs:documentation>
                The container to query for reserved amounts of the specified ware.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="type" use="required">
            <xs:annotation>
              <xs:documentation>
                Reservation type
              </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="buy">
                  <xs:annotation>
                    <xs:documentation>
                      Buy reservations only.
                    </xs:documentation>
                  </xs:annotation>
                </xs:enumeration>
                <xs:enumeration value="sell">
                  <xs:annotation>
                    <xs:documentation>
                      Sell reservations only.
                    </xs:documentation>
                  </xs:annotation>
                </xs:enumeration>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="reserver" type="expression">
            <xs:annotation>
              <xs:documentation>
                Only count reservations for a specific object. If 'mission' is true, the object must be player owned and will return all player owned mission reservations (optional)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="mission" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether the reservation is for a mission trade (optional, defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="supplies" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether the reservation is for a supply trade (optional, defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="virtual" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Whether to look at the "real" or the "virtual" dataset - virtual reservations are IGNORED for trades. (optional, defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="ware" type="ware" use="required" />
          <xs:attribute name="result" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                The amount that is reserved for this reserver (or all reservers).
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="get_wares_illegal_to">
        <xs:annotation>
          <xs:documentation>
            Get list of wares illegal to a faction
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="faction" type="factionexprlookup" use="required">
            <xs:annotation>
              <xs:documentation>
                The faction to which wares are illegal.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                A filtered list of wares.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="get_equipment_build_wares">
        <xs:annotation>
          <xs:documentation>
            Get equipment wares this object can build
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required"/>
          <xs:attribute name="otherfaction" type="factionexprlookup" use="optional">
            <xs:annotation>
              <xs:documentation>
                The other faction which may have restrictions on which wares they can use from this object
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="requireblueprints" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Select only items for which the supplied faction has blueprints. Has no effect for non-player objects. Defaults to false.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                A filtered list of wares.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="get_ship_build_wares">
        <xs:annotation>
          <xs:documentation>
            Get ship wares this object can build
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required"/>
          <xs:attribute name="otherfaction" type="factionexprlookup" use="optional">
            <xs:annotation>
              <xs:documentation>
                The other faction which may have restrictions on which wares they can use from this object
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="requireblueprints" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Select only items for which the supplied faction has blueprints. Has no effect for non-player objects. Defaults to false.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="canbuild" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Only include ship wares the object is allowed to build. Defaults to false.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="canequip" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Only include ship wares the object is allowed to equip. Defaults to false.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="cansupply" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Only include ship wares the object is allowed to supply. Defaults to false.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                A filtered list of wares.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="get_zone_exit_pos">
        <xs:annotation>
          <xs:documentation>
            Get a safe position for leaving a zone towards a destination (destination must be in same sector!)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="position" type="position" minOccurs="0" maxOccurs="1" />
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="zone" type="zone" use="required" />
          <xs:attribute name="destination" type="object" use="required" />
          <xs:attribute name="radius" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Radius to indicate necessary space required for a safe position
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="position" type="lvaluename" use="required" />
          <xs:attribute name="rotation" type="lvaluename" />
        </xs:complexType>
      </xs:element>

      <xs:element name="get_zone_at_position">
        <xs:annotation>
          <xs:documentation>
            Get the zone at this sector position (may return null if none exists)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="position" />
          <xs:attribute name="sector" type="sector" use="required" />
          <xs:attribute name="name" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="precache_hint">
        <xs:annotation>
          <xs:documentation>
            Hint an object / zone ( precaching of assets )
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="expression">
            <xs:annotation>
              <xs:documentation>
                Object to prehint
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="zone" type="expression">
            <xs:annotation>
              <xs:documentation>
                Zone to prehint
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="precache_actor_animation_hint">
        <xs:annotation>
          <xs:documentation>
            Hint an actor's animation sequence ( precaching of assets )
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="actor" type="actor" use="required" />
          <xs:attribute name="type" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Animation sequence type
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="behavior" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Animation sequence behavior
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="is_in_quadrant">
        <xs:annotation>
          <xs:documentation>
            Check if target object is in all specified quadrants of object, returns false if target is not detected at all
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Scanning object
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="target" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The object to look for
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvaluename" use="required" />
          <xs:attribute name="up" type="boolean" />
          <xs:attribute name="down" type="boolean" />
          <xs:attribute name="left" type="boolean" />
          <xs:attribute name="right" type="boolean" />
          <xs:attribute name="front" type="boolean" />
          <xs:attribute name="back" type="boolean" />
        </xs:complexType>
      </xs:element>

      <xs:element name="join_formation">
        <xs:annotation>
          <xs:documentation>
            Join formation. No effect if there is no formation in the object.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Object joining the formation
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="leader" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Formation leader
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="launch_countermeasures">
        <xs:annotation>
          <xs:documentation>
            Launch countermeasures against enemy missile locks or incoming missiles
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="result" type="lvalueexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Whether a new batch of countermeasures has been queued for launch
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="launch_distressdrone">
        <xs:annotation>
          <xs:documentation>
            Launch distress drone
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="macro" type="macro" use="required" />
          <xs:attribute name="attacker" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Attacker that causes distress drone launch (optional)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="name" type="lvaluename" />
          <xs:attribute name="groupname" type="groupname" />
        </xs:complexType>
      </xs:element>

      <xs:element name="launch_crew_transfer_pod">
        <xs:annotation>
          <xs:documentation>
            Launch crew transfer pod. Crew being transferred is independent of this action.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required"/>
          <xs:attribute name="macro" type="macro" use="required"/>
          <xs:attribute name="destination" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Container that will receive crew transfer pod
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="arrivaltime" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Time that the pod is expected to arrive. (Optional)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="name" type="lvaluename" />
          <xs:attribute name="groupname" type="groupname" />
        </xs:complexType>
      </xs:element>

      <xs:element name="launch_lasertower">
        <xs:annotation>
          <xs:documentation>
            Launch laser tower
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="macro" type="macro" />
          <xs:attribute name="category" type="deployablecategorylookup">
            <xs:annotation>
              <xs:documentation>
                Deployable category from which macro will be selected if not supplied (optional, defaults to lasertower)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="name" type="lvaluename" />
          <xs:attribute name="groupname" type="groupname" />
        </xs:complexType>
      </xs:element>

      <xs:element name="launch_mine">
        <xs:annotation>
          <xs:documentation>
            Launch mine
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="macro" type="macro" />
          <xs:attribute name="category" type="deployablecategorylookup">
            <xs:annotation>
              <xs:documentation>
                Deployable category from which macro will be selected if not supplied (optional, defaults to mine)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="name" type="lvaluename" />
          <xs:attribute name="groupname" type="groupname" />
        </xs:complexType>
      </xs:element>

      <xs:element name="launch_navbeacon">
        <xs:annotation>
          <xs:documentation>
            Launch navigation beacon
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="macro" type="macro" />
          <xs:attribute name="category" type="deployablecategorylookup">
            <xs:annotation>
              <xs:documentation>
                Deployable category from which macro will be selected if not supplied (optional, defaults to navbeacon)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="name" type="lvaluename" />
          <xs:attribute name="groupname" type="groupname" />
        </xs:complexType>
      </xs:element>

      <xs:element name="launch_resourceprobe">
        <xs:annotation>
          <xs:documentation>
            Launch resource probe
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="macro" type="macro" />
          <xs:attribute name="category" type="deployablecategorylookup">
            <xs:annotation>
              <xs:documentation>
                Deployable category from which macro will be selected if not supplied (optional, defaults to resourceprobe)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="name" type="lvaluename" />
          <xs:attribute name="groupname" type="groupname" />
        </xs:complexType>
      </xs:element>

      <xs:element name="launch_satellite">
        <xs:annotation>
          <xs:documentation>
            Launch satellite
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="macro" type="macro" />
          <xs:attribute name="category" type="deployablecategorylookup">
            <xs:annotation>
              <xs:documentation>
                Deployable category from which macro will be selected if not supplied (optional, defaults to satellite)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="name" type="lvaluename" />
          <xs:attribute name="groupname" type="groupname" />
        </xs:complexType>
      </xs:element>

      <xs:element name="launch_drone">
        <xs:annotation>
          <xs:documentation>
            Launch drone
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="macro" type="macro" />
          <xs:attribute name="category" type="unitcategorylookup">
            <xs:annotation>
              <xs:documentation>
                Unit category from which macro will be selected if not supplied
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attributeGroup ref="random"/>
          <xs:attribute name="name" type="lvaluename" />
          <xs:attribute name="groupname" type="groupname" />
        </xs:complexType>
      </xs:element>

      <xs:element name="launch_masstraffic_drone">
        <xs:annotation>
          <xs:documentation>
            Launch a ship of the specified ship group from masstraffic docks. Will attempt to avoid docks that are in use (e.g. while trading)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="name" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                The drone that was launched as a result (if any)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The object launching the drone.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="category" type="unitcategorylookup" use="required" >
            <xs:annotation>
              <xs:documentation>
                Unit category from which the used macro will be selected
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="target" type="expression">
            <xs:annotation>
              <xs:documentation>
                The target which is to be picked up by the drone (optional, used to determine ideal launch direction)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="ware" type="expression">
            <xs:annotation>
              <xs:documentation>
                Ware to be transported, used to find best matching macro from shipgroup (optional, ignored if pickup=true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="pickup" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Is this a pickup run? If true, an empty transport ship will be launched (optional, defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="launch_war_drones">
        <xs:annotation>
          <xs:documentation>
            Launch war drones. This uses mass traffic, so both objects need to be stationary for the whole duration.
            Ensure that you kill the resulting mass traffic network when you're done with it, and wait until it's finished before moving away.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="result" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                The newly created mass traffic network.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The object launching the drones.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="target" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The target which is to be attacked by drones. Must have a nav mesh.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="amount" type="expression">
            <xs:annotation>
              <xs:documentation>
                The amount of drones to be launched. If undefined, all available units will be used.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="launch_repair_drones">
        <xs:annotation>
          <xs:documentation>
            Launch repair drones. This uses mass traffic, so both objects need to be stationary for the whole duration.
            Ensure that you kill the resulting mass traffic network when you're done with it, and wait until it's finished before moving away.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="result" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                The ID of the newly created mass traffic network - IMPORTANT: this will become invalid if a savegame is loaded
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The object launching the drones.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="target" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The target which is to be repaired by repair drones. Must have a nav mesh.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="components" type="list" use="required">
            <xs:annotation>
              <xs:documentation>
                List of components that need to be repaired
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="amount" type="expression">
            <xs:annotation>
              <xs:documentation>
                The amount of drones to be launched. If undefined, all available units will be used.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_drone_armed">
        <xs:annotation>
          <xs:documentation>
            Set the drone armed status for a specific unit category of an object to true or false
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="category" type="unitcategorylookup" use="required" />
          <xs:attribute name="armed" type="booleanexpression" use="required"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_drone_mode">
        <xs:annotation>
          <xs:documentation>
            Set the drone mode for a specific unit category of an object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="category" type="unitcategorylookup" use="required" />
          <xs:attribute name="mode" type="dronemodeexprlookup" use="required"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="leave_formation">
        <xs:annotation>
          <xs:documentation>
            Leave formation as a formation WingMan. No effect if the object is not a formation WingMan
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="open_conversation_menu">
        <xs:annotation>
          <xs:documentation>
            Open a menu as part of a conversation, which will be suspended until the menu is closed
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="menu" type="namestring" use="required">
            <xs:annotation>
              <xs:documentation>
                Name of menu to be opened as part of the conversation
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="param" type="expression">
            <xs:annotation>
              <xs:documentation>
                First menu parameter
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="param2" type="expression">
            <xs:annotation>
              <xs:documentation>
                Second menu parameter
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="open_menu">
        <xs:annotation>
          <xs:documentation>
            Open a menu
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="menu" type="namestring" use="required">
            <xs:annotation>
              <xs:documentation>
                Name of menu to be opened
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="param" type="expression">
            <xs:annotation>
              <xs:documentation>
                First menu parameter
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="param2" type="expression">
            <xs:annotation>
              <xs:documentation>
                Second menu parameter
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="pickup_target">
        <xs:annotation>
          <xs:documentation>
            Pick up a target object (connect it to the ship)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="ship" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Ship to which the picked up object will be connected
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="target" type="targetobject" use="required" />
          <xs:attribute name="prepare" type="boolean" >
            <xs:annotation>
              <xs:documentation>
                Prepare the pickup process, this makes sure the target stops rotating and is properly aligned for pickup (optional, defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="sort_collectables_by_value">
        <xs:annotation>
          <xs:documentation>
            Sort a list of collectables by price value. Note: Sorting collectables with identical price values will retain their relative order from the input list. Consider shuffling the collectables list first.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Collecting object, used to filter out collectables which can't be stored
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="collectables" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                List of collectables
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="name" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                Result list of sorted collectables
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="play_cutscene">
        <xs:annotation>
          <xs:documentation>
            Start playing a cutscene
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="interaction" minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
                  Player interaction event
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attributeGroup ref="interaction" />
              </xs:complexType>
            </xs:element>
            <xs:element name="param" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>
                  Parameter referenced by the cutscene, must have either object or number attribute
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attribute name="name" type="namestring" use="required">
                  <xs:annotation>
                    <xs:documentation>
                      Parameter name
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="object" type="expression">
                  <xs:annotation>
                    <xs:documentation>
                      Reference object
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="number" type="expression">
                  <xs:annotation>
                    <xs:documentation>
                      Numeric value
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="key" type="cutscenekey" use="required" />
          <xs:attribute name="targetmonitor" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Show cutscene in target monitor?
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="sound" type="expression">
            <xs:annotation>
              <xs:documentation>
                Sound ID (either a plain name string or a script expression that evaluates to a string - default is no sound)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="caption" type="expression">
            <xs:annotation>
              <xs:documentation>
                Optional caption text string. May be null. Requires targetmonitor=&quot;true&quot;. No caption is displayed if caption is null or an empty string.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="timeout" type="expression">
            <xs:annotation>
              <xs:documentation>
                Maximal duration of target monitor cutscene. If supplied, the cutscene will end after the timeout. Requires targetmonitor=&quot;true&quot;.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="rendertarget" type="expression">
            <xs:annotation>
              <xs:documentation>
                Name of render target on which the cutscene should be played (ignored for target monitor cutscenes)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="abortable" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether the cutscene is abortable by the player, default is true (ignored for target monitor cutscenes)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Name of the value that will receive the cutscene ID as result. If &lt;play_cutscene&gt; fails the result may be null in some cases.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="raise_lua_event">
        <xs:annotation>
          <xs:documentation>
            Raise an event to a registered callback in a lua script.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="name" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Name of the event
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="param" type="expression">
            <xs:annotation>
              <xs:documentation>
                Optional parameter. Has to be a string, number or component.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_object_account">
        <xs:annotation>
          <xs:documentation>
            Removes an account from the object if any, so the object will use the faction's account instead. Optionally the remaining money can be transferred to the faction account.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="transfer" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Transfer remaining money to faction account? Defaults to false.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_actor_from_room">
        <xs:annotation>
          <xs:documentation>
            Remove NPC actor from the room it is in (e.g. landing platform)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="actor" type="actor" use="required" />
          <xs:attribute name="clearroomslot" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Clear the current roomslot of this actor (defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_from_group">
        <xs:annotation>
          <xs:documentation>
            Remove an object from a group
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="group" type="group" use="required" />
          <xs:attribute name="object" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_from_list">
        <xs:annotation>
          <xs:documentation>
            Remove one or all elements from a list that match the specified value or are in the specified range.
            Note that the list to be updated is provided in the name attribute, not the list attribute. The list attribute can be used for matching values.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="name" type="list" use="required" />
          <xs:attributeGroup ref="range" />
          <xs:attribute name="multiple" type="boolean">
            <xs:annotation>
              <xs:documentation>
                If true (default), all matching elements are removed from the list. Set to false to remove only the first matching value
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_object_commander">
        <xs:annotation>
          <xs:documentation>
            Remove the commander of an object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_representative">
        <xs:annotation>
          <xs:documentation>
            Remove faction representative
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="faction" type="faction" />
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_value">
        <xs:annotation>
          <xs:documentation>
            Remove a variable
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="name" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="return">
        <xs:annotation>
          <xs:documentation>
            Return to caller (supported in AI scripts, as well as MD libraries with purpose=&quot;run_actions&quot;).
            In global interrupts and actions of &lt;on_abort&gt;, &lt;patch&gt; or &lt;editable&gt; elements, this action does not return to the caller and just aborts the current actions in those elements.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="retval" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>
                  Named return value (only supported for non-order AI scripts)
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attribute name="name" type="paramname" use="required">
                  <xs:annotation>
                    <xs:documentation>
                      Return value name
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="value" type="expression" use="required">
                  <xs:annotation>
                    <xs:documentation>
                      Return value
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="comment" type="comment" />
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="value" type="expression">
            <xs:annotation>
              <xs:documentation>
                Unnamed return value
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
        <xs:key name="return_value">
          <xs:selector xpath="retval" />
          <xs:field xpath="@name" />
        </xs:key>
      </xs:element>

      <xs:element name="check_walk_path">
        <xs:annotation>
          <xs:documentation>
            Check whether a NPC can walk do a destination
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="start" type="position" minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
                  Addional offset to the start position, either the 'start' slot/component or the NPCs position if 'start' was not provided
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="end" type="position" minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
                  Addional offset to the end slot/component position
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="actor" type="actor" use="required" />
          <xs:attribute name="start" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Object or component slot to start from. Combined with 'start' position. (optional, NPC uses current position if not provided)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="end" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Object or component slot destination. Combined with 'end' position.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="checkstate" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Check if the NPC is currently able to move. NPCs can not move if in low attention or are hidden. (defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="destination" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                The ultimate destination component. Used to judge which surfaces the NPC may be alowed to walk on. (if 'end' is the the destination, this is not necessary)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="destinationtags" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Known floor tags at the destination position. Used to judge which surfaces the NPC may be alowed to walk on.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="check_weapon_active">
        <xs:annotation>
          <xs:documentation>
            Check whether the weapon is currently active
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="macro" type="macro" use="required" />
          <xs:attribute name="result" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="check_weapon_installed">
        <xs:annotation>
          <xs:documentation>
            Check whether the weapon is installed/available
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="macro" type="macro" use="required" />
          <xs:attribute name="result" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="request_docking">
        <xs:annotation>
          <xs:documentation>
            Request docking procedure for ship, result is true if the request was queued. Check this.ship.assigneddock to see if the request was granted.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="ship" type="ship" use="required" />
          <xs:attribute name="container" type="container" use="required" />
          <xs:attribute name="highpriority" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Whether the ship should be using a high priority dock, defaults to false (will fall back to the other kind of dock if no matching ones exist)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="requirebuilding" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether the ship must use a dock that supports building, defaults to false
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="requiretrading" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether the ship must use a dock that supports trading, defaults to false
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="allowplayeronly" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether the ship may also use a dock that only allows the player to dock, defaults to false
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="ventureronly" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether the ship must use a dock that is only meant for venturing, defaults to false
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="ventureplatform" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Specific venture platform with which venture dock must be associated (can be null)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="queuedresult" type="lvaluename" use="required" />
          <xs:attribute name="grantedresult" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="request_undocking">
        <xs:annotation>
          <xs:documentation>
            Request undocking procedure for ship, result is true if the request was queued. If the ship is docked, this is always either granted or queued.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="ship" type="ship" use="required" />
          <xs:attribute name="highpriority" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Whether the ship should be using a high priority dock, defaults to false (will fall back to the other kind of dock if no matching ones exist)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="allowplayeronly" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether the ship may also use a dock that only allows the player to dock, defaults to false
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="ventureronly" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Whether the ship must use a dock that is exclusively meant for venturing (only applies when ship is coming out of storage), defaults to false
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="ventureplatform" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Specific venture platform with which venture dock must be associated (can be null)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="queuedresult" type="lvaluename" use="required" />
          <xs:attribute name="grantedresult" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="request_retrieval">
        <xs:annotation>
          <xs:documentation>
            Request this ship to be taken out of internal ship storage, result is true if the request was queued. If the ship is docked, this is always either granted or queued.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="ship" type="ship" use="required" />
          <xs:attribute name="highpriority" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Whether the ship should be using a high priority dock, defaults to false (will fall back to the other kind of dock if no matching ones exist)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="allowplayeronly" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether the ship may also use a dock that only allows the player to dock, defaults to false
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="ventureronly" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Whether the ship must use a dock that is exclusively meant for venturing (only applies when ship is coming out of storage), defaults to false
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="ventureplatform" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Specific venture platform with which venture dock must be associated (can be null)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="queuedresult" type="lvaluename" use="required" />
          <xs:attribute name="grantedresult" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="request_store_ship">
        <xs:annotation>
          <xs:documentation>
            Request that a ship docked at the object be stored away to free up room.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="ship" type="expression">
            <xs:annotation>
              <xs:documentation>
                If this ship is not docked at the object, take size and faction from this ship when trying to free up a dock by storing another ship away. (takes precedence over 'size' and 'faction'). If this ship is currently docked at the object, request to store it
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="size" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Dock compatibility size (also requires that faction be defined, ignored if ship is specified)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="faction" type="factionexprlookup">
            <xs:annotation>
              <xs:documentation>
                Faction to try and avoid storing a ship for (also requires that size be defined, ignored if ship is specified)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="highpriority" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Whether the ship should be using a high priority dock, defaults to false (will fall back to the other kind of dock if no matching ones exist)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="requiredocking" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether the dock to be freed must support docking, defaults to false
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="requireundocking" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether the dock to be freed must support undocking, defaults to false
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="requirebuilding" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether the dock to be freed must support building, defaults to false
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="requiretrading" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether the dock to be freed must support trading, defaults to false
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="allowplayeronly" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether the dock to be freed may also be one that only allows the player to dock, defaults to false
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="ventureronly" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Whether the dock to be freed must be exclusively meant for venturing (only applies when ship is coming out of storage), defaults to false
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="ventureplatform" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Specific venture platform with which venture dock must be associated (can be null)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="refobject" type="expression" use="optional" >
            <xs:annotation>
              <xs:documentation>
                Reference object to sort docks by distance and attempt to store away a ship on the closest suitable dock (optional)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_docking_request">
        <xs:annotation>
          <xs:documentation>
            Remove assigned dock or docking request for ship (the latter only works if the container is specified)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="ship" type="ship" use="required" />
          <xs:attribute name="container" type="container" />
          <xs:attribute name="immediate" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Whether the request should be processed immediately (defaults to false). If not instant the assignment will be removed as soon as the ship is at a safe distance, which is defined in the dockingbay macro.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_undocking_request">
        <xs:annotation>
          <xs:documentation>
            Remove undocking request for ship
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="ship" type="ship" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_retrieval_request">
        <xs:annotation>
          <xs:documentation>
            Remove retrieval request for ship
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="ship" type="ship" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="add_mass_traffic_quota">
        <xs:annotation>
          <xs:documentation>
            Add a quota to a zone's main mass traffic network. Must supply either a macro, a ship group, or a job ID. If no end time is supplied you need to store it and stop the quota when you no longer need it.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="quota" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                (optional result) ID of the created quota
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="zone" type="zone" use="required" />
          <xs:attribute name="start" type="expression">
            <xs:annotation>
              <xs:documentation>
                The station where the mass traffic ships should start
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="end" type="expression">
            <xs:annotation>
              <xs:documentation>
                The station where the mass traffic ships should end
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="starttime" type="expression">
            <xs:annotation>
              <xs:documentation>
                The time the quota should start (defaults to now if not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="endtime" type="expression">
            <xs:annotation>
              <xs:documentation>
                The time the quota should end (defaults to never if not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="macro" type="macro" />
          <xs:attribute name="group" type="namestring">
            <xs:annotation>
              <xs:documentation>
                Ship group for random macro selection
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="job" type="expression">
            <xs:annotation>
              <xs:documentation>
                Job ID for random macro selection and ship setup
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="amount" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The amount of ships in this quota
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="stop_mass_traffic_quota">
        <xs:annotation>
          <xs:documentation>
            Make a mass traffic quota stop
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="quota" type="expression" use="required" />
          <xs:attribute name="endtime" type="expression">
            <xs:annotation>
              <xs:documentation>
                The time the quota should end at the earliest (defaults to now if not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="get_macros_in_mass_traffic">
        <xs:annotation>
          <xs:documentation>
            Get all macros currently active in a zone's main mass traffic network
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="zone" type="zone" use="required" />
          <xs:attribute name="macros" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                The result list of macros in the network
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="amounts" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                The result list of ship amounts corresponding to each macro in the network
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="get_units_in_mass_traffic">
        <xs:annotation>
          <xs:documentation>
            Get all units of a category currently active in a mass traffic network
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="masstraffic" type="masstraffic" use="required" />
          <xs:attribute name="category" type="unitcategorylookup" use="required">
            <xs:annotation>
              <xs:documentation>
                The category of units to get
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="amounts" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                Result list with the index being the 'mk' of the unit
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="request_mass_traffic_ship">
        <xs:annotation>
          <xs:documentation>
            Request a ship to be spawned in a zone's mass traffic network
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="name" type="lvaluename" use="required" />
          <xs:attribute name="zone" type="zone" use="required" />
          <xs:attribute name="start" type="expression">
            <xs:annotation>
              <xs:documentation>
                The station where the mass traffic ship should start
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="end" type="expression">
            <xs:annotation>
              <xs:documentation>
                The station where the mass traffic ship should end
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="mintime" type="expression">
            <xs:annotation>
              <xs:documentation>
                Minimum flight time
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group" type="namestring">
            <xs:annotation>
              <xs:documentation>
                Ship group for random macro selection (taken from zone's master quota if not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="request_boarding_support">
        <xs:annotation>
          <xs:documentation>
            Request boarding support by the player (triggers an MD cue to select a mission)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="boarder" type="entity" use="required" />
          <xs:attribute name="boarded" type="object" use="required" />
          <xs:attribute name="forcedmission" type="expression">
            <xs:annotation>
              <xs:documentation>
                Forced mission type, prevents random selection (see md/BoardingSupport.xml)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="request_gate">
        <xs:annotation>
          <xs:documentation>
            Request from a ship to lock the Gate for going through (Use 'unlock' true to unlock)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="ship" type="ship" use="required" >
            <xs:annotation>
              <xs:documentation>
                Ship requesting the Gate
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="gate" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Gate to lock (or unlock if 'unlock' = true) for the ship
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="unlock" type="expression" >
            <xs:annotation>
              <xs:documentation>
                Unlock the Gate for this ship. Safe to call if not requested befor (Optional, Default: false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvaluename" use="required" >
            <xs:annotation>
              <xs:documentation>
                Whether or not the Gate request is successful
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="notify_boarding_support_failed">
        <xs:annotation>
          <xs:documentation>
            Notify the boarder that boarding support by the player failed
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="boarder" type="entity" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="notify_boarding_support_succeeded">
        <xs:annotation>
          <xs:documentation>
            Notify the boarder that boarding support by the player was successful
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="boarder" type="entity" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="notify_universe_generated">
        <xs:annotation>
          <xs:documentation>
            Notify interested parties that universe generation is complete
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="create_boarding_operation">
        <xs:annotation>
          <xs:documentation>
            Create a boarding operation and add it as an inbound operation on the target
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="target" type="object" use="required" />
          <xs:attribute name="faction" type="faction" use="required" />
          <xs:attribute name="approach" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Threshold value to launch boarding pods (0 - 100) - Actual behaviour of this value depends on the boarding handler
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="insertion" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Threshold value to begin insertion into the hull (0 - 100) - Actual behaviour of this value depends on the boarding handler
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                Result operation
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="add_boarding_attacker">
        <xs:annotation>
          <xs:documentation>
            Add an attacker to the boarding operation and configure their behaviour and use of marines
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="marines" minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
                  Amount of marines by skill level to match against role tiers
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attribute name="amounts" type="expression" use="required">
                  <xs:annotation>
                    <xs:documentation>
                      List of amounts (size must match with other lists)
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="skills" type="expression" use="required">
                  <xs:annotation>
                    <xs:documentation>
                      List of skills to help identify people (size must match with other lists)
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="attacker" type="object" use="required" />
          <xs:attribute name="behavior" type="boardingbehaviourlookup" use="required" />
          <xs:attribute name="operation" type="expression" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="add_boarding_pod_to_operation">
        <xs:annotation>
          <xs:documentation>
            Add an approaching boarding pod to the boarding operation
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="ship" type="object" use="required" />
          <xs:attribute name="operation" type="expression" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_boarding_pod_from_operation">
        <xs:annotation>
          <xs:documentation>
            Remove an approaching boarding pod from the boarding operation
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="ship" type="object" use="required" />
          <xs:attribute name="operation" type="expression" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="dispatch_marines">
        <xs:annotation>
          <xs:documentation>
            Inform the boarding operation that an attacker has dispatched a number of marines to board the target (the creation of marines and activation of their AI behaviour is not handled by this action)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="marines" minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
                  Amount of marines by skill level to match against role tiers
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attribute name="amounts" type="expression" use="required">
                  <xs:annotation>
                    <xs:documentation>
                      List of amounts (size must match with other lists)
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="skills" type="expression" use="required">
                  <xs:annotation>
                    <xs:documentation>
                      List of skills to help identify people (size must match with other lists)
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="attacker" type="object" use="required" />
          <xs:attribute name="operation" type="expression" use="required" />
          <xs:attribute name="marines" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                List of marine npc templates
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Object which currently contains the marines
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="transfer_marines_from_operation">
        <xs:annotation>
          <xs:documentation>
            Transfer a list of marines from a boarding operation to an object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Object to transfer the marines to
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="marines" type="expression">
            <xs:annotation>
              <xs:documentation>
                List of NPC templates
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="operation" type="expression" use="required" />
          <xs:attribute name="result" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                List of people successfully transferred from otherobject to object
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="transfer_marine_to_operation">
        <xs:annotation>
          <xs:documentation>
            Transfer a marine from an object to the internals of a boarding operation
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Object containing the marine to transfer
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="template" type="expression" use="required" />
          <xs:attribute name="status" type="marinestatuslookup" use="required" />
          <xs:attribute name="operation" type="expression" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_marine_status">
        <xs:annotation>
          <xs:documentation>
            Set the status of a marine taking part in a boarding operation
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="template" type="expression" use="required" />
          <xs:attribute name="status" type="marinestatuslookup" use="required" />
          <xs:attribute name="operation" type="expression" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="start_boarding_operation">
        <xs:annotation>
          <xs:documentation>
            Trigger the boarding operation to start, adding AI orders to related ships and firing the 'event_boarding_operation_started' event
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="operation" type="expression" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="end_boarding_operation">
        <xs:annotation>
          <xs:documentation>
            Force the boarding operation to end, removing it from the target's list of inbound boarding operations
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="operation" type="expression" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_boarding_phase">
        <xs:annotation>
          <xs:documentation>
            Set the phase of the boarding operation
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="operation" type="expression" use="required" />
          <xs:attribute name="phase" type="boardingphaselookup" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="request_repair">
        <xs:annotation>
          <xs:documentation>
            Request a component to be repaired (only listened to from scripts)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="target" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The component to be repaired
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="makepriority" type="boolean" use="required">
            <xs:annotation>
              <xs:documentation>
                Whether repairing another component should wait and this one should start immediately
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="reset_relation_boost">
        <xs:annotation>
          <xs:documentation>
            Reset relation boost (otherobject or faction attribute required)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="resetobjectboost" />
        </xs:complexType>
      </xs:element>

      <xs:element name="reset_tolerance_boost">
        <xs:annotation>
          <xs:documentation>
            Reset tolerance boost (otherobject or faction attribute required)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="resetobjectboost" />
        </xs:complexType>
      </xs:element>

      <xs:element name="reset_turret">
        <xs:annotation>
          <xs:documentation>
            Reset turret
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="turret" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Turret
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="resize_list">
        <xs:annotation>
          <xs:documentation>
            Resize a list (if the list grows, it will contain new null values at the end)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="list" type="list" use="required" />
          <xs:attribute name="count" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                New number of elements
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="reward_player">
        <xs:annotation>
          <xs:documentation>
            Reward the player
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <!-- TODO: Remove the "required" if there are alternative reward types -->
          <xs:attribute name="money" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Money reward
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="save_ai_action_state">
        <xs:annotation>
          <xs:documentation>
            Save the state of the current AI script blocking action on the blackboard of an entity that is going to take over control when restarting a script (can be the same entity).
            The AI script actions &lt;wait_for_prev_script&gt; and &lt;finalize_prev_script&gt; will process the information to make sure that the current AI action (e.g. trade) ends in a clean way.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="entity" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Entity that will receive the AI action state information. To be used when a new script is supposed to start on the entity, aborting the previous entity's script.
                The new script should perform &lt;wait_for_prev_script&gt; and &lt;finalize_prev_script&gt;.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="previous" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Entity from which the AI action state information is retrieved, basically immediately before the entity's script is aborted.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_object_account">
        <xs:annotation>
          <xs:documentation>
            Assigns an account to the object if the object does not have an own account yet.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="share_object_account">
        <xs:annotation>
          <xs:documentation>
            Tells this object to use the account of otherobject. Optionally can transfer the money in the account to the object supplied as transferto (may be the same as otherobject).
            If otherobject and transferto are invalid / omitted this behaves like &lt;remove_object_account /&gt;
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="otherobject" type="expression">
            <xs:annotation>
              <xs:documentation>
                (optional) The object whose account to share, will default to faction account of transferto object if omitted!
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="transferto" type="expression">
            <xs:annotation>
              <xs:documentation>
                (optional) The object to which any money in the actors account should be transferred. (money will be lost if omitted)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_object_max_budget">
        <xs:annotation>
          <xs:documentation>
            Assigns a max budget to an object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="amount" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Amount max budget is set to
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_object_min_budget">
        <xs:annotation>
          <xs:documentation>
            Assigns a min budget
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="amount" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Amount min budget is set to
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_actor_roomslot">
        <xs:annotation>
          <xs:documentation>
            Reserve the roomslot for this actor
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="actor" type="actor" use="required" />
          <xs:attribute name="roomslot" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Component slot to reserve as the ultimate destination
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="clear_actor_roomslot">
        <xs:annotation>
          <xs:documentation>
            Clear the current roomslot of this actor
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="actor" type="actor" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_actor_current_chair">
        <xs:annotation>
          <xs:documentation>
            Set a chair slot as the current chair for this actor
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="actor" type="actor" use="required" />
          <xs:attribute name="roomslot" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Component slot to set as the chair slot
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="clear_actor_current_chair">
        <xs:annotation>
          <xs:documentation>
            Clear the current chair of this actor
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="actor" type="actor" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="start_actor_walk">
        <xs:annotation>
          <xs:documentation>
            Lets the actor walk to the target (as long as the player can watch it)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="position" type="position" minOccurs="0" maxOccurs="1" />
            <xs:element name="rotation" type="rotation" minOccurs="0" maxOccurs="1" />
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="actor" type="actor" use="required" />
          <xs:attribute name="speed" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Speed of the character in m/s
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="target" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Component slot to walk to
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="roomslot" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Component slot to reserve as the ultimate destination (NPC's current roomslot cleared if invalid)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="stop_actor_walk">
        <xs:annotation>
          <xs:documentation>
            Stop the actor's current walk behaviour
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="actor" type="actor" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="start_actor_sequence">
        <xs:annotation>
          <xs:documentation>
            Start an actor's animation sequence
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="actor" type="actor" use="required" />
          <xs:attribute name="type" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Animation sequence type
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="behavior" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Animation sequence behavior (if omitted, uses roomslot tags to decide behaviour)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="transition" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Perform a transition to the next sequence (defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="immediate" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Perform an immediate transition to the next sequence (blending from the current one, default is false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvaluename" use="optional" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_actor_emotion">
        <xs:annotation>
          <xs:documentation>
            Set an actor's emotion morph target
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="actor" type="actor" use="required" />
          <xs:attribute name="emotion" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Emotion name
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="clear_actor_emotion">
        <xs:annotation>
          <xs:documentation>
            Clear an actor's emotion morph target
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="actor" type="actor" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_actor_lookat">
        <xs:annotation>
          <xs:documentation>
            Set an actor's lookat target component
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="actor" type="actor" use="required" />
          <xs:attribute name="component" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Target component
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="clear_actor_lookat">
        <xs:annotation>
          <xs:documentation>
            Clear an actor's lookat target
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="actor" type="actor" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_actor_touch">
        <xs:annotation>
          <xs:documentation>
            Have an actor touch something with hand
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="actor" type="actor" use="required" />
          <xs:attribute name="tags" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Specification tag or list of tags
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="lefthand" type="boolean">
            <xs:annotation>
              <xs:documentation>
                false to use right hand (default), true to use left hand
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="clear_actor_touch">
        <xs:annotation>
          <xs:documentation>
            Have an actor untouch something
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="actor" type="actor" use="required" />
          <xs:attribute name="lefthand" type="boolean">
            <xs:annotation>
              <xs:documentation>
                false to use right hand (default), true to use left hand
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_actor_tool">
        <xs:annotation>
          <xs:documentation>
            Attach a tool to an actor
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="actor" type="actor" use="required" />
          <xs:attribute name="name" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Tool Name
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="lefthand" type="boolean">
            <xs:annotation>
              <xs:documentation>
                false to use right hand (default), true to use left hand
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="clear_actor_tool">
        <xs:annotation>
          <xs:documentation>
            Remove a currently held tool from the actor
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="actor" type="actor" use="required" />
          <xs:attribute name="lefthand" type="boolean">
            <xs:annotation>
              <xs:documentation>
                false to use right hand (default), true to use left hand
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="transfer_money">
        <xs:annotation>
          <xs:documentation>
            Transfers amount from one entity to another, if possible
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="from" type="factionorobject" use="required" />
          <xs:attribute name="to" type="factionorobject" use="required" />
          <xs:attribute name="amount" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Amount to be transferred
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Resulting amount that was actually transferred
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_buildanchor">
        <xs:annotation>
          <xs:documentation>
            Set a buildanchor to the specified buildprocessor
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="buildprocessor" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Build processor to set the buildanchor of
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Build anchor to be used
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="clear_buildanchor">
        <xs:annotation>
          <xs:documentation>
            Clear the buildanchor of the specified buildprocessor
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="buildprocessor" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Build processor to clear the buildanchor of
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_cockpit_tint">
        <xs:annotation>
          <xs:documentation>
            Sets the cockpit boarder tint for use in certain activities
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="rgbcolour" />
          <xs:attribute name="frequency" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Frequency as light pulses per second (Requires 'amplitude' to be specified as well. Setting either 'frequency' or 'amplitude' to a value &gt;= 0 will disable the pulse.)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="amplitude" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Amplitude fluctuation range for light pulses (Range 0 to 1. Requires 'frequency' to be specified as well. Setting either 'frequency' or 'amplitude' to a value &gt;= 0 will disable the pulse.)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_object_active">
        <xs:annotation>
          <xs:documentation>
            Set the object to activated or deactivated
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="activate" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Activate object? (default is true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_object_access_licence">
        <xs:annotation>
          <xs:documentation>
            Set licence restriction for access to object or space
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="licence" type="licencelookup" use="required">
            <xs:annotation>
              <xs:documentation>
                Licence required to access object or space
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="clear_object_access_licence">
        <xs:annotation>
          <xs:documentation>
            Clear licence restriction for access to object or space
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_object_capturable">
        <xs:annotation>
          <xs:documentation>
            Set the object to be capturable or not
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="capturable" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Is the object capturable? (default is based on class)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_object_docking_enabled">
        <xs:annotation>
          <xs:documentation>
            Set docking at the object to be enabled or not
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="enabled" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Are any ships allowed to dock at the object? (default is true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_object_friend_list">
        <xs:annotation>
          <xs:documentation>
            Set friend list of a mine that supports this (mine will treat everyone else as foe, regardless of faction relations)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The mine whose friend list should be set
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="factions" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Faction or list of factions to be set as friends
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_object_foe_list">
        <xs:annotation>
          <xs:documentation>
            Set foe list of a mine that supports this (mine will treat everyone else as friend, regardless of faction relations)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The mine whose foe list should be set
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="factions" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Faction or list of factions to be set as foes
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="clear_object_friend_foe_list">
        <xs:annotation>
          <xs:documentation>
            Clea friend/foe list of a mine that supports this (mine will revert to using faction relations)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The mine whose foe list should be cleared
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_object_radar_visible">
        <xs:annotation>
          <xs:documentation>
            Set the object to be visible in the map or in the UI or not
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="visible" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Is the object visible? (default is true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_object_sellable">
        <xs:annotation>
          <xs:documentation>
            Set the object to be sellable
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="sellable" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Is the object sellable? (default is true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_object_commander">
        <xs:annotation>
          <xs:documentation>
            Set the commander of an object (use 'remove_object_commander' to remove commander)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="commander" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Object to be the commander (null not allowed)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="assignment" type="assignmentexprlookup" use="optional">
            <xs:annotation>
              <xs:documentation>
                Assignment for this subordinate on the commander. Mutually exclusive with subordinategroupid.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="subordinategroupid" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Subordinate group ID for this subordinate on the commander. Integer from 1 to 10. (ignored if assignment is supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_subordinate_group_assignment">
        <xs:annotation>
          <xs:documentation>
            Set the assignment of a commander's subordinate group.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="commander" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Commander of the subordinate group (null not allowed)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="subordinategroupid" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Subordinate group ID whose assignment will be changed. Integer from 1 to 10.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="assignment" type="assignmentexprlookup" use="required">
            <xs:annotation>
              <xs:documentation>
                Assignment to set to specified subordinate group.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_order_state">
        <xs:annotation>
          <xs:documentation>
            Set the state of a running AI order to the specified state, if the state transition is supported.
            Explicit state changes with this action are optional. See orderstate documentation in scriptproperties.html.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="order" type="order" use="required" />
          <xs:attribute name="state">
            <xs:annotation>
              <xs:documentation>
                Order state
              </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:restriction base="expression">
                <xs:enumeration value="orderstate.critical">
                  <xs:annotation>
                    <xs:documentation>
                      Enter critical state of order script. This requires the order to be in the active state.
                    </xs:documentation>
                  </xs:annotation>
                </xs:enumeration>
                <xs:enumeration value="orderstate.finish">
                  <xs:annotation>
                    <xs:documentation>
                      Enter finish state of order script. This requires the order to be in the active or critical state.
                    </xs:documentation>
                  </xs:annotation>
                </xs:enumeration>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_order_syncpoint_reached">
        <xs:annotation>
          <xs:documentation>
            Mark the sync point of a running AI order as reached. This action is a requirement for all infinite orders.
            Once the sync point of such an order is reached, the sync point is ready to be released by a signal, which will terminate the
            order (&lt;event_object_order_syncpoint_released&gt;). For player orders, the signal behaviour can be controlled in the UI.
            On queued infinite orders that do not use the sync point signalling system, the sync point is released (the order ends) as soon as the next order is ready in the queue.
            On default orders, this action only affects the UI display. There is no effect on finite orders.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="order" type="order" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="edit_order_param">
        <xs:annotation>
          <xs:documentation>
            Changes an order parameter, as if edited by the player in the UI. Note that this has side effects for already running orders and can fail in some cases.
            If the order is in the started state (non-critical), it will be reset and start over. If in the critical state, any &lt;editable&gt; actions will be performed
            and &lt;event_order_param_edited&gt; will be triggered. You can check with &quot;$order.isparameditable.&lt;param&gt;&quot; whether a param is currently editable.
            Editing a param fails if:
            (1) the order is in the critical state and the param has no &lt;editable&gt; node that allows editing, or
            (2) the order is the default order or in a critical state and the param decides whether the order is infinite (i.e. it has an infinitevalue), or
            (3) the order is in the finish state.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="order" type="order" use="required" />
          <xs:attribute name="param" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Parameter name as string
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="value" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                New parameter value
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="move_order">
        <xs:annotation>
          <xs:documentation>
            Moves an order to a new position in the order queue (or checks whether moving is possible). Note that this can have side effects for already running orders and can fail in some cases.
            If the movement changes the first order in the queue that was in the started state (non-critical), the running order will be reset and start over once it reaches the front of the queue.
            Moving an order fails if:
            (1) the order is a default order,
            (2) the newindex value is not a valid index in the order queue,
            (3) the order is a running order in the critical state or the finish state, or
            (4) the movement would replace a running order in the critical state or the finish state.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="order" type="order" use="required" />
          <xs:attribute name="newindex" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                New index of order within the order queue (moving the order to its current index is allowed and has no effect)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="check" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Check if moving the order is possible but do not actually move it (defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Name of the value that will indicate whether the move operation was a success
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="create_order_syncpoint">
        <xs:annotation>
          <xs:documentation>
            Create an AI-controlled sync point that is owned by an AI order.
            The AI order must be an infinite order in the queue (not a default order), and it may not have entered the critical state or the finish state yet.
            The sync point is automatically assigned to the owning AI order, and remains assigned as long as the order exists.
            The sync point is removed completely (including all order assignments) when either the owning order is completed/removed or the sync point gets unassigned from it
            (see &lt;unassign_order_syncpoint_from_order&gt;).
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="owner" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                AI order that should become the owner of the sync point
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="assign_order_syncpoint_to_order">
        <xs:annotation>
          <xs:documentation>
            Assign a sync point to an AI order. Sync point must have been created previously with &lt;create_order_syncpoint&gt;.
            The AI order must be an infinite order in the queue (not a default order), and it may not have entered the critical state or the finish state yet.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="owner" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                AI order that is the owner of the sync point
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="order" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                AI order to which the existing sync point should be assigned
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="unassign_order_syncpoint_from_order">
        <xs:annotation>
          <xs:documentation>
            Unassign an AI-controlled sync point from an AI order. If the AI order is the owner of the sync point, the sync point is removed completely.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="order" type="order" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_object_min_hull">
        <xs:annotation>
          <xs:documentation>
            Set an object's minimum hull value (percentage)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="object" type="object" use="required" />
          <xs:attributeGroup ref="random" />
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_object_min_shield">
        <xs:annotation>
          <xs:documentation>
            Set an object's minimum shield value (percentage)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="object" type="object" use="required" />
          <xs:attributeGroup ref="random" />
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_object_hull">
        <xs:annotation>
          <xs:documentation>
            Set an object's hull value (percentage)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="object" type="object" use="required" />
          <xs:attributeGroup ref="random" />
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_object_name">
        <xs:annotation>
          <xs:documentation>
            Set an object's name (use page and line for full localisation support, including support for saving and loading with a different language - otherwise use name attribute.
            Note that an object of either class &quot;object&quot; or &quot;space&quot; requires a name on a ship computer voice page when using page and line.)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="name" type="expression">
            <xs:annotation>
              <xs:documentation>
                New object name (takes precedence over page and line)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="page" type="page" />
          <xs:attribute name="line" type="line" />
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="clear_object_name">
        <xs:annotation>
          <xs:documentation>
            Clear an object's name and revert to default
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="object" type="object" use="required" />
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_object_description">
        <xs:annotation>
          <xs:documentation>
            Set an object's description (use page and line for full localisation support, including support for saving and loading with a different language - otherwise use description attribute)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="description" type="expression">
            <xs:annotation>
              <xs:documentation>
                New object description (takes precedence over page and line)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="page" type="page" />
          <xs:attribute name="line" type="line" />
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="clear_object_description">
        <xs:annotation>
          <xs:documentation>
            Clear an object's description and revert to default
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="object" type="object" use="required" />
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_object_fleet_name">
        <xs:annotation>
          <xs:documentation>
            Set a controllable object's fleet name
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="name" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                New fleet name
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_object_relation_behaviour">
        <xs:annotation>
          <xs:documentation>
            Set relation change behaviour for an object when attacked or killed
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Object
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="disable" type="booleanexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                Disable relation change? (true = disabled; false = default behaviour)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_object_shield">
        <xs:annotation>
          <xs:documentation>
            Set an object's shield value (percentage)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="object" type="object" use="required" />
          <xs:attributeGroup ref="random" />
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_object_scanned">
        <xs:annotation>
          <xs:documentation>
            Sets the scanned level of an object to the maximum level of the player's scanner
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_object_hackable">
        <xs:annotation>
          <xs:documentation>
            Sets an object as able to be hacked
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="hackable" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Should object be hackable? (default is true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_object_hacked">
        <xs:annotation>
          <xs:documentation>
            Sets an object as hacked
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                If this is a ship or station, all content in the given build stage is set as hacked. If this is a subcomponent, it and *all* content is set as hacked.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="duration" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Duration of the hack
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="hacker" type="expression">
            <xs:annotation>
              <xs:documentation>
                The object performing the hacking
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Name of the value that will receive the list of hacked components
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="dropresult" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Name of the value that will receive the list of ejected drops
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_object_hull_unrepairable">
        <xs:annotation>
          <xs:documentation>
            Sets an object's hull to be unrepairable
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="unrepairable" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Should object's hull be unrepairable? (default is true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_object_shield_unrepairable">
        <xs:annotation>
          <xs:documentation>
            Sets an object's shield to be unrepairable
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="unrepairable" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Should object's shield be unrepairable? (default is true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_object_velocity">
        <xs:annotation>
          <xs:documentation>
            Sets the object's velocity
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="linear" minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
                  The new linear velocity (linear velocity will not be changed if this is omitted)
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attributeGroup ref="vector" />
              </xs:complexType>
            </xs:element>
            <xs:element name="angular" minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
                  The new angular velocity (angular velocity will not be changed if this is omitted)
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attributeGroup ref="vector" />
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="add_object_velocity">
        <xs:annotation>
          <xs:documentation>
            Adds to the object's velocity
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="linear" minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
                  The new linear velocity (linear velocity will not be changed if this is omitted)
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attributeGroup ref="vector" />
              </xs:complexType>
            </xs:element>
            <xs:element name="angular" minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
                  The new angular velocity (original angular velocity will not be changed if this is omitted)
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attributeGroup ref="vector" />
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_room_locked">
        <xs:annotation>
          <xs:documentation>
            Set the room to be locked or not
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="room" type="object" use="required" />
          <xs:attribute name="locked" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Is the room locked? (default is true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_triggers_locked">
        <xs:annotation>
          <xs:documentation>
            Set triggers on platforms (e.g. doors and buttons) with optional matching group or tags in the room to be locked or not
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Room or Ship
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group" type="expression">
            <xs:annotation>
              <xs:documentation>
                Group tag
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="locked" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Are the triggers locked? (default is true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="duration" type="expression">
            <xs:annotation>
              <xs:documentation>
                How long this lock should last. Unlimited duration if omitted. (optional)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_trigger_activation_wares">
        <xs:annotation>
          <xs:documentation>
            Set platform triggers with optional matching group or tags in the room to require certain inventory wares for activation
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="room" type="object" use="required" />
          <xs:attribute name="group" type="expression">
            <xs:annotation>
              <xs:documentation>
                Group tag
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="tags" type="expression">
            <xs:annotation>
              <xs:documentation>
                Specification tag or list of tags
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="ware" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The required inventory ware
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="amount" type="expression">
            <xs:annotation>
              <xs:documentation>
                The required inventory ware amount (default is 1)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="consumeonuse" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Are the wares consumed on use? If true, there is also an event when the trigger was "unlocked" by the player. (default is false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_allow_drop">
        <xs:annotation>
          <xs:documentation>
            Whether the object (which can be any destructible subcomponent of an object!) can drop something
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="allow" type="boolean" use="required" />
          <xs:attribute name="recursive" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Whether this setting should be propagated to all child destructibles
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_drop_object">
        <xs:annotation>
          <xs:documentation>
            Sets the drop for the object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="drop" type="expression">
            <xs:annotation>
              <xs:documentation>
                Drop string identifier (drop is cleared if not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="spawn_docked">
        <xs:annotation>
          <xs:documentation>
            Attempt to spawn an existing ship in a dock (bypassing dock request checks)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="ship" type="ship" use="required" />
          <xs:attribute name="dock" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="spawn_drop">
        <xs:annotation>
          <xs:documentation>
            Spawn the drop defined for the object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="drop" type="expression">
            <xs:annotation>
              <xs:documentation>
                Drop string identifier (will drop whatever is currently defined in the object if not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="collect_drop">
        <xs:annotation>
          <xs:documentation>
            Have a drop be instantly collected by an object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="drop" type="object" use="required"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="collect_asteroid">
        <xs:annotation>
          <xs:documentation>
            Have an asteroid be instantly collected by a ship
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="ship" use="required" />
          <xs:attribute name="asteroid" type="asteroid" use="required"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="collect_deployable">
        <xs:annotation>
          <xs:documentation>
            Have a deployable be instantly collected by a ship
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="deployable" type="object" use="required"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="collect_unit">
        <xs:annotation>
          <xs:documentation>
            Have a unit be instantly collected by an object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="unit" type="object" use="required"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="open_lockbox">
        <xs:annotation>
          <xs:documentation>
            Open the specified lockbox
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Object that opens the lockbox
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="lockbox" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Lockbox
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_entity_page">
        <xs:annotation>
          <xs:documentation>
            Sets/changes the page of an actor (entity)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="entity" type="entity" use="required" />
          <xs:attribute name="page" type="page" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_entity_type">
        <xs:annotation>
          <xs:documentation>
            Sets/changes the type of an actor (entity)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="entity" type="entity" use="required" />
          <xs:attribute name="type" type="entitytype" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_entity_role">
        <xs:annotation>
          <xs:documentation>
            Sets/changes the role of an actor (entity)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="entity" type="entity" use="required" />
          <xs:attribute name="role" type="entityrole" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_npc_template_role">
        <xs:annotation>
          <xs:documentation>
            Sets/changes the role of a npc template
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required"/>
          <xs:attribute name="template" type="expression" use="required"/>
          <xs:attribute name="role" type="entityrole" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="clear_entity_role">
        <xs:annotation>
          <xs:documentation>
            Clear the role of an actor (entity)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="entity" type="entity" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_entity_role_object">
        <xs:annotation>
          <xs:documentation>
            Sets/changes the role object of an actor (entity)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="entity" type="entity" use="required" />
          <xs:attribute name="object" type="object" use="required"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="clear_entity_role_object">
        <xs:annotation>
          <xs:documentation>
            Clear the role object of an actor (entity)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="entity" type="entity" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="clear_npc_template_role">
        <xs:annotation>
          <xs:documentation>
            Clear the role of a npc template
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required"/>
          <xs:attribute name="template" type="expression" use="required"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_faction_relation">
        <xs:annotation>
          <xs:documentation>
            Set global faction relation
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="faction" type="faction" use="required" />
          <xs:attribute name="otherfaction" type="faction" use="required" />
          <xs:attribute name="value" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Relation boost value
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="reason" type="relationchangereasonlookup">
            <xs:annotation>
              <xs:documentation>
                The reason for relationship change
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="reset_faction_relation">
        <xs:annotation>
          <xs:documentation>
            Reset faction relation to base value in factions.xml
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="faction" type="faction" use="required" />
          <xs:attribute name="otherfaction" type="faction" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_faction_relation_locked">
        <xs:annotation>
          <xs:documentation>
            Set faction relations to be locked
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="faction" type="faction" use="required" />
          <xs:attribute name="locked" type="booleanexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                Whether the faction's relations towards others should be able to change
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="reason" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Reason why relations cannot change (shown to player, defaults to empty string and player is just told it's not currently possible, use format '{page,line}' as string for full localisation support, including support for saving and loading with a different language)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_mass_traffic_object_persistence">
        <xs:annotation>
          <xs:documentation>
            Set this mass traffic objects persistance in the game
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="persistent" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Should object be persistent? (default is true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_region_object_persistence">
        <xs:annotation>
          <xs:documentation>
            Set this region objects persistance in the game
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="persistent" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Should object be persistent? (default is true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="end_mass_traffic">
        <xs:annotation>
          <xs:documentation>
            Set this mass traffic network's end time. Note that the time will be adjusted so that no ships are underway when the network is removed.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="network" type="masstraffic" use="required" />
          <xs:attribute name="endtime" type="expression">
            <xs:annotation>
              <xs:documentation>
                The end time (default is the current time)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_owner">
        <xs:annotation>
          <xs:documentation>
            Sets the owner faction of an object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="faction" type="owner" use="required">
            <xs:annotation>
              <xs:documentation>
                (No owner is set if null or not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="overridenpc" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Set the owner faction of the control entities (defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_cover_owner">
        <xs:annotation>
          <xs:documentation>
            Sets the cover owner faction of an object (cover owner is cleared if faction is null or not supplied)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="faction" type="owner"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_player_activity">
        <xs:annotation>
          <xs:documentation>
            Set player activity (mode mission)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="activity" type="activityexprlookup" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_player_entity_position">
        <xs:annotation>
          <xs:documentation>
            Set player position in room
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:choice minOccurs="0" maxOccurs="unbounded">
            <xs:element name="position" type="position" minOccurs="0" maxOccurs="1" />
            <xs:element name="rotation" type="rotation" minOccurs="0" maxOccurs="1" />
          </xs:choice>
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="teleport_player">
        <xs:annotation>
          <xs:documentation>
            Trigger a teleport to a object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="control" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Have the player take control if it is free (defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="instant" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Instant teleportation (defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="force" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Allow the teleportation, even if the research criteria is not fulfilled (defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_emergency_eject_active">
        <xs:annotation>
          <xs:documentation>
            Set the player emergency eject feature to active/inactive.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="active" type="booleanexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                Active state can be set at any time but may have no effect if the player does not have emergency effect capability (player.hasemergencyeject) or has disabled it in their game options.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_relation_boost">
        <xs:annotation>
          <xs:documentation>
            Set relation boost (otherobject or faction attribute required)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="objectrelationboost" />
          <xs:attribute name="value" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Relation boost value
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="reason" type="relationchangereasonlookup">
            <xs:annotation>
              <xs:documentation>
                The reason for relationship change
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_representative">
        <xs:annotation>
          <xs:documentation>
            Set faction representative
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="faction" type="faction" />
          <xs:attribute name="representative" type="expression">
            <xs:annotation>
              <xs:documentation>
                Entity to be assigned to the sector as faction representative
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_scan_target">
        <xs:annotation>
          <xs:documentation>
            Set the player's current scan target
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="target" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_skill">
        <xs:annotation>
          <xs:documentation>
            Set skill value to either 'entity' or a npctemplate on 'object'
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="entity" type="entity" use="optional" />
          <xs:attribute name="object" type="object" use="optional" />
          <xs:attribute name="template" type="expression" use="optional" />
          <xs:attribute name="type" type="skilltype" use="required" />
          <xs:attributeGroup ref="random" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_spacesuit_oxygen">
        <xs:annotation>
          <xs:documentation>
            Set the oxygen level (in % of maximum oxygen supply) for specified spacesuit
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="percent" type="expression" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="apply_experience">
        <xs:annotation>
          <xs:documentation>
            Apply experience to either individual 'entity' or crew aboard 'object' (identified by npctemplate for an individual crew member or role for a group )
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="entity" type="entity" use="optional" />
          <xs:attribute name="object" type="object" use="optional" />
          <xs:attribute name="template" type="expression" use="optional" />
          <xs:attribute name="role" type="entityrole" use="optional" />
          <xs:attribute name="experience" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Experience (from libraries/experiences.xml)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="factor" type="expression" use="optional" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_entity_traits">
        <xs:annotation>
          <xs:documentation>
            Set the traits of an entity
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="setentityflags"/>
          <xs:attribute name="entity" type="object" use="required"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_npc_template_traits">
        <xs:annotation>
          <xs:documentation>
            Set the traits of a npc template
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="setentityflags"/>
          <xs:attribute name="object" type="object" use="required"/>
          <xs:attribute name="template" type="expression" use="required"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_entity_overrides">
        <xs:annotation>
          <xs:documentation>
            Set override data for an entity
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="entity" type="object" use="required"/>
          <xs:attribute name="title" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Title override (use format '{page,line}' as string for full localisation support, including support for saving and loading with a different language)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="icon" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Icon override
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_tolerance_boost">
        <xs:annotation>
          <xs:documentation>
            Set tolerance boost (otherobject or faction attribute required)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="objectboost" />
          <xs:attribute name="value" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Tolerance boost value
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_allowed_weapon_systems">
        <xs:annotation>
          <xs:documentation>
            Set allowed weapon systems (weapon system not listed will keep current state)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="allow">
            <xs:annotation>
              <xs:documentation>
                Specifically allow the use of certain weapon types (separated by space)
              </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:list itemType="weaponsystemlookup" />
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="disallow">
            <xs:annotation>
              <xs:documentation>
                Specifically disallow the use of certain weapon types (separated by space)
              </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:list itemType="weaponsystemlookup" />
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="immediate" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Optional, set to true to make disallowed weapon systems stop firing immediately (defaults to false, weapons will shoot until they lose their current target)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_trade_restrictions">
        <xs:annotation>
          <xs:documentation>
            Set trade restrictions for the object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="override" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>
                  Define an override for the trade restrictions per ware
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attribute name="ware" type="ware" use="required">
                  <xs:annotation>
                    <xs:documentation>
                      Affected ware
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="restricted" type="expression" use="required">
                  <xs:annotation>
                    <xs:documentation>
                      (DEPRECATED) Restriction to only trade ware with own faction. Overrides buy, sell and supply settings. (default: false)
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="buy" type="expression" use="required">
                  <xs:annotation>
                    <xs:documentation>
                      Restriction to only buy ware from own faction (default: false)
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="sell" type="expression" use="required">
                  <xs:annotation>
                    <xs:documentation>
                      Restriction to only sell ware to own faction (default: false)
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="supply" type="expression" use="required">
                  <xs:annotation>
                    <xs:documentation>
                      Restriction to only accept supplies from own faction (default: false)
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="comment" type="comment" />
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Object for which the restrictions will be set.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="restricted" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                (DEPRECATED) Restriction to only trade with own faction. Overrides buy, sell, supply and build settings. (default: false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="buy" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Restriction to only buy from own faction (default: false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="sell" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Restriction to only sell to own faction (default: false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="supply" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Restriction to only accept supplies from own faction (default: false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="build" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Restriction to only build ships for own faction (default: false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_tradeoffers_enabled">
        <xs:annotation>
          <xs:documentation>
            Set trade offers to enabled/disabled for the object. Note: Setting enabled to false will cancel any active/planned trade orders for other parties buying/selling at the object but will not affect trade orders of the object itself!
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Object for which the trade offers will be enabled/disabled.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="enabled" type="boolean" use="optional">
            <xs:annotation>
              <xs:documentation>
                Set the enabled state for trade offers of the object. (defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_turret_targets">
        <xs:annotation>
          <xs:documentation>
            Set turret targets
            Note: this action will not process targets in low attention, but it will set applicable turrets to deployed status
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="preferredtarget" type="expression">
            <xs:annotation>
              <xs:documentation>
                Priority target for each turret. If it can't attack, it will choose from the target list
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="clearpreferred" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                If preferredtarget is not provided, clear the existing preferred target (defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="target" type="expression">
            <xs:annotation>
              <xs:documentation>
                List of target objects for turrets (ignored in low attention)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="stopshootingold" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Stop shooting old targets which are not provided in the new target list (defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="weaponmode" type="weaponmodelookup">
            <xs:annotation>
              <xs:documentation>
                Turrets in the specified mode will choose from these targets (defaults to any)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_value">
        <xs:annotation>
          <xs:documentation>
            Set a variable value
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="name" type="lvaluename" use="required" />
          <xs:attribute name="operation" type="setoperationlookup" />
          <xs:attributeGroup ref="random"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_weapon_mode">
        <xs:annotation>
          <xs:documentation>
            Set the weapon mode of a weapon or group of weapons. When weaponmode is omitted, it is reset to default.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="weapon" type="weapon" />
          <xs:attribute name="group" type="group" />
          <xs:attribute name="weaponmode" type="extendedweaponmodelookup">
            <xs:annotation>
              <xs:documentation>
                Weapon mode, or null to reset to default
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_weapon_ammo">
        <xs:annotation>
          <xs:documentation>
            Set the current ammo (missile type) for one or more weapons (missile launcher and/or missile turrets).
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="optional">
            <xs:annotation>
              <xs:documentation>
                Object (defensible or module) for which weapon ammo should be set (should not be set if weapon and/or group attributes are supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="weapon" type="weapon" use="optional">
            <xs:annotation>
              <xs:documentation>
                Specific individual weapon to set ammo for (should not be set if object attribute is supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group" type="group" use="optional">
            <xs:annotation>
              <xs:documentation>
                Group of weapons to set ammo for (should not be set if object attribute is supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="macro" type="macro" use="optional">
            <xs:annotation>
              <xs:documentation>
                Set ammo only for weapons of this macro type (with object attribute only, all weapons if omitted)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="weaponmode" type="extendedweaponmodelookup" use="optional">
            <xs:annotation>
              <xs:documentation>
                Set ammo only for weapons set to this weapon mode (with object attribute only, all weapons if omitted)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="weapongroup"  type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Set ammo only for weapons in this weapon group (with object attribute only, missile launchers on defensibles only, all weapon groups if omitted, used in conjuction with primary attribute)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="primary" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Set ammo only for weapons primary/secondary weapon group (with object attribute only, missile launchers on defensibles only, ignored if weapongroup attribute is not supplied, default is primary)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="grouptag" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Set ammo only for weapons in this connection group (with object attribute only, missile turrets only, all connection group if omitted)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="ammo" type="macro" use="required">
            <xs:annotation>
              <xs:documentation>
                Ammo macro to set
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="shoot">
        <xs:annotation>
          <xs:documentation>
            Start shooting a weapon without a target (requires object on visible attention level and a suitable weapon selection)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="missiles" type="expression">
            <xs:annotation>
              <xs:documentation>
                Select between lasers and missile launchers. False for lasers, true for missile launchers. Defaults to false.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="primary" type="expression">
            <xs:annotation>
              <xs:documentation>
                Shoot weapons in active primary weapon group. Defaults to true.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="secondary" type="expression">
            <xs:annotation>
              <xs:documentation>
                Shoot weapons in active secondary weapon group. Defaults to true.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="weaponmode" type="weaponmodelookup">
            <xs:annotation>
              <xs:documentation>
                Only weapons/turrets set to the specified mode will shoot at the target, defaults to any.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="stop_shooting">
        <xs:annotation>
          <xs:documentation>
            Stop shooting without a target
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="missiles" type="expression">
            <xs:annotation>
              <xs:documentation>
                Select between lasers and missile launchers. False for lasers to stop shooting, true for missile launchers to stop shooting. Defaults to false.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="primary" type="expression">
            <xs:annotation>
              <xs:documentation>
                Stop shooting weapons in active primary weapon group. Defaults to true.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="secondary" type="expression">
            <xs:annotation>
              <xs:documentation>
                Stop shooting weapons in active secondary weapon group. Defaults to true.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="weaponmode" type="weaponmodelookup">
            <xs:annotation>
              <xs:documentation>
                Only weapons/turrets set to the specified mode will stop shooting, defaults to any.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="show_help">
        <xs:annotation>
          <xs:documentation>
            Show text from help text page if it was not shown before (when using line attribute), or show custom text (when using custom attribute)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="line" type="expression">
            <xs:annotation>
              <xs:documentation>
                Line (text ID) on help text page. Text will be shown if not shown before, or if force attribute value is true
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="force" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Always show help text? If true, the help is shown even if the help text ID was already used before (ignored when using custom attribute)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="custom" type="expression">
            <xs:annotation>
              <xs:documentation>
                Custom help text, takes precedence over line attribute
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="silent" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Suppress sound effect?
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attributeGroup ref="showhelp" />
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_help">
        <xs:annotation>
          <xs:documentation>
            Remove display of a help text
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="all" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Set to true to remove all help texts from display queue. Takes precedence over line attribute.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="line" type="expression">
            <xs:annotation>
              <xs:documentation>
                Specific line (text ID), or list of lines, to be removed from display queue (removing custom texts specifically is not supported). If attribute is not supplied, the currently displayed hint is removed.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="show_input_help">
        <xs:annotation>
          <xs:documentation>
            Show help text for input function (e.g. INPUT_ACTION_QUICKSAVE or INPUT_STATE_ROLL_LEFT). Keyboard/controller use is detected automatically.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="name" type="expression">
            <xs:annotation>
              <xs:documentation>
                Input function name (see inputmap.xml)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attributeGroup ref="showhelp" />
        </xs:complexType>
      </xs:element>

      <xs:element name="show_help_multi">
        <xs:annotation>
          <xs:documentation>
            Show multiple texts from help text page if it was not shown before, or if force attribute value is true
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="text" minOccurs="1" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>
                  Definition of the individual help texts.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attribute name="line" type="expression" use="required">
                  <xs:annotation>
                    <xs:documentation>
                      Line (text ID) on help text page.
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="color" type="expression">
                  <xs:annotation>
                    <xs:documentation>
                      Defines the text color in the format [r, g, b, a] - default is white
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="log" type="booleanexpression">
                  <xs:annotation>
                    <xs:documentation>
                      Defines whether this line is logged. Is overriden by the log attribute of the show_help_multi action. Default is false
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="comment" type="comment" />
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="force" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Always show help text? If true, the help is shown even if the help text ID was already used before. Default is false.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="silent" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Suppress sound effect? Default is false
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="position" type="expression">
            <xs:annotation>
              <xs:documentation>
                Position of help text (defined in parameters.xml) - defaults to 0
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="log" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Add help text to logbook? Overrides individual line settings. Default is false
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="width" type="expression">
            <xs:annotation>
              <xs:documentation>
                Factor to modify help text width in percent (default is 200, minimum is 50)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="allowclose" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether the player is allowed to close the hint, use with care (default is false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="halign" type="expression">
            <xs:annotation>
              <xs:documentation>
                Horizontal alignment of the hint text (default is 'left')
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="allowinmenu" type="expression">
            <xs:annotation>
              <xs:documentation>
                Whitelist this help text in menus which normally forbid them (e.g. the options menu) - format 'MenuA MenuB MenuC'
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="show_help_overlay">
        <xs:annotation>
          <xs:documentation>
            Show a help overlay
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="id" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The ID of the help overlay.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="highlightonly" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Only highlight the element (default is false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_help_overlay">
        <xs:annotation>
          <xs:documentation>
            Show a help overlay
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="id" type="expression">
            <xs:annotation>
              <xs:documentation>
                The ID of the help overlay to be removed.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="all" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Set to true to remove all help overlays created by scripts. Takes precedence over id attribute.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="show_notification">
        <xs:annotation>
          <xs:documentation>
            Show a non-interactive notification in the message ticker
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="text" type="notificationtext" use="required" />
          <xs:attribute name="timeout" type="expression">
            <xs:annotation>
              <xs:documentation>
                Maximal duration of notification. If not supplied, the notification will end after a default timeout (currently 5s).
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="priority" type="expression">
            <xs:annotation>
              <xs:documentation>
                The priority, an integer between 0 and 9 (default is 1).
                Unqueued notifications can only be aborted and replaced by unqueued notifications of same or higher priority, or by cutscenes. The queue for queued notifications is also sorted by priority.
                NOTE: Non-silent interactive events (notifications and cutscenes with flashing target monitor) are generally treated as having a higher priority than any non-interactive events.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <!-- not supported yet
          <xs:attribute name="prioritydelay" type="expression">
            <xs:annotation>
              <xs:documentation>
                Optional value to delay the display of this ticker message if a message with a higher priority can be displayed before.
                The message will be displayed after all queued ticker messages with higher priorities have started being displayed and subsequently the specified delay has passed.
                In case there is no message with a higher priority in the ticker and no such message is added in the same frame, the message will be displayed without delay.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          -->
          <xs:attribute name="sound" type="expression">
            <xs:annotation>
              <xs:documentation>
                Sound ID (either a plain name string or a script expression that evaluates to a string - default is &quot;notification_generic&quot; if omitted or empty)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="show_interactive_notification">
        <xs:annotation>
          <xs:documentation>
            Show an interactive notification in the target monitor
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="interaction">
              <xs:annotation>
                <xs:documentation>
                  Player interaction event
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attributeGroup ref="interaction" />
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="caption" type="expression">
            <xs:annotation>
              <xs:documentation>
                Caption text string
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="text" type="notificationtext" use="required" />
          <xs:attribute name="timeout" type="expression">
            <xs:annotation>
              <xs:documentation>
                Maximal duration of notification. If not supplied, the notification will end after a default timeout (currently 5s).
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="priority" type="expression">
            <xs:annotation>
              <xs:documentation>
                The priority, an integer between 0 and 9 (default is 1).
                Unqueued notifications can only be aborted and replaced by unqueued notifications of same or higher priority, or by cutscenes. The queue for queued notifications is also sorted by priority.
                NOTE: Non-silent interactive events (notifications and cutscenes with flashing target monitor) are generally treated as having a higher priority than any non-interactive events.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="sound" type="expression">
            <xs:annotation>
              <xs:documentation>
                Sound ID (either a plain name string or a script expression that evaluates to a string - default is &quot;notification_generic&quot; if omitted or empty)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="faction" type="factionexprlookup">
            <xs:annotation>
              <xs:documentation>
                The faction for which the notoriety ladder should be displayed (optional)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="object" type="expression">
            <xs:annotation>
              <xs:documentation>
                The object for which the notoriety ladder should be displayed (optional). Takes precedence if both faction and object are supplied.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="relationeffect" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                true iff a relation effect (blinking effect in faction bar) should be shown
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                (optional) ID of resulting notification object
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="shuffle_group">
        <xs:annotation>
          <xs:documentation>
            Shuffle components in a group randomly
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="group" type="group" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="shuffle_list">
        <xs:annotation>
          <xs:documentation>
            Shuffle elements of a list randomly
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="list" type="list" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="signal_objects">
        <xs:annotation>
          <xs:documentation>
            Signal an object and/or a group of objects using param and param2, each object will receive this signal as if it were an event.
            NOTE: When used in MD without a delay, make sure that the signal does not activate the current cue again (directly or indirectly), which could lead to an infinite recursion.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="objecteventsource" />
          <xs:attribute name="param" type="expression" />
          <xs:attribute name="param2" type="expression" />
          <xs:attribute name="param3" type="expression" />
          <xs:attribute name="delay" type="expression">
            <xs:annotation>
              <xs:documentation>
                (optional) delay this signal by the specified amount of time
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="speak">
        <xs:annotation>
          <xs:documentation>
            Play (speak) text
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:group ref="voicedata" minOccurs="0" maxOccurs="unbounded" />
          <xs:attributeGroup ref="action" />
          <xs:attribute name="actor" type="actor" use="required" />
          <xs:attribute name="page" type="pagewithdefault" />
          <xs:attribute name="line" type="lineorlist" />
          <xs:attribute name="delay" type="speakdelay" />
          <xs:attribute name="priority" type="expression">
            <xs:annotation>
              <xs:documentation>
                Speech priority. Speeches of lower priority will be interrupted. Default is 0.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="caninterrupt" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Allow interrupting a speech of the same priority? Default is true.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="recipient" type="expression">
            <xs:annotation>
              <xs:documentation>
                Speech recipient, i.e. the character being spoken to (optional). Pass an NPC if this is a background speech between two NPCs, which affects the voice style of the speech. Default is the player (if omitted or null).
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="topic" type="expression">
            <xs:annotation>
              <xs:documentation>
                Speech topic, i.e. the character being spoken about (optional). Pass an NPC or the player if the person being spoken about may have a grammatical effect on the sentence.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="backgroundcomm" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Is this a background speech and is the player able to hear this over comm? Note that a speech in background and a speech over comm are two separate properties,
                and this flag only indicates a preference, which can be partially or fully ignored.
                - If the player is the speaker or this is a broadcast, the speech is always in foreground.
                - If a recipient is specified, the speech is in background depending on whether the recipient is an NPC or the player.
                - If the speech is in background and the recipient is in hearing range of the speaker, the speech will be over comm only if backgroundcomm is enabled and the player is not within hearing range.
                (Otherwise it is assumed that the player is required to be close to the speaker to hear the speech.)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="broadcast" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Is this a broadcast speech of an entity to a group of people over comm? This implies background speech, but may cause a different comm filter to be applied. Default is false.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="voiceover" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Is this a voiceover speech in a cinematic scene? The entity will speak with maximal volume even if not near the player. Default is false.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="check" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Check for errors resolving an object name or description? Default is true
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="interrupt_speak">
        <xs:annotation>
          <xs:documentation>
            Interrupt an actor's current speak
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="actor" type="actor" use="required" />
          <xs:attribute name="priority" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Any current speech of this priority or lower will be interrupted.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="start_boost">
        <xs:annotation>
          <xs:documentation>
            Start engine booster
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="ship" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="start_conversation">
        <xs:annotation>
          <xs:documentation>
            Start a conversation on this actor
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="conversationactor" />
          <xs:attribute name="conversation" type="conversation" use="required" />
          <xs:attribute name="convparam" type="expression">
            <xs:annotation>
              <xs:documentation>
                Optional parameter that is passed to &lt;event_conversation_started&gt;. Can be of any data type.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="type">
            <xs:annotation>
              <xs:documentation>
                Type that affects how the conversation is started
              </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="normal">
                  <xs:annotation>
                    <xs:documentation>
                      Default conversation type
                    </xs:documentation>
                  </xs:annotation>
                </xs:enumeration>
                <xs:enumeration value="unqueued">
                  <xs:annotation>
                    <xs:documentation>
                      Unqueued conversation (start conversation only if there is no conversation already running)
                    </xs:documentation>
                  </xs:annotation>
                </xs:enumeration>
                <xs:enumeration value="takeover">
                  <xs:annotation>
                    <xs:documentation>
                      Take over a previous conversation. When using this type, the player does not automatically return to the default position when the previous conversation ends.
                    </xs:documentation>
                  </xs:annotation>
                </xs:enumeration>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="priority">
            <xs:annotation>
              <xs:documentation>
                Priority of conversation for the case of multiple simultaneous requests (min=0, max=100, default=0)
              </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:restriction base="xs:nonNegativeInteger">
                <xs:minInclusive value="0" />
                <xs:maxInclusive value="100" />
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="cancel_conversation">
        <xs:annotation>
          <xs:documentation>
            Cancel an active conversation (if providing a conversation actor, the conversation is only cancelled if the actor matches)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="conversationactor" />
          <xs:attribute name="conversation" type="namestring">
            <xs:annotation>
              <xs:documentation>
                Optional conversation name. If supplied then the conversation is only aborted if the conversation name matches.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="force" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Should conversation be aborted even if Escape was explicitly disabled via &lt;allow_conversation_escape&gt;?
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="cancel_all_orders">
        <xs:annotation>
          <xs:documentation>
            Cancels all existing AI orders in the object's order queue
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="cancel_order">
        <xs:annotation>
          <xs:documentation>
            Cancels an AI order and removes it from the owner object's order queue.
            NOTE: If the order is in the critical state, it will not be cancelled. Instead, a &lt;event_object_order_cancelled&gt; will be sent with immediate=&quot;false&quot;,
            which is a request that may or may not be handled by the order script (see documentation of orderstate.critical).
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="order" type="order" use="required" />
          <xs:attribute name="keepinloop" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                In case of a cancelled loop order, keep the cancelled order in the loop instead of removing it?
                This only has an effect if the order is part of an order loop and is not temporary. Any other order is not affected by the attribute and will be removed anyway.
                This attribute is useful for cancelling the current order, for the purpose of finishing its execution in a safe way and proceeding to the next order.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="start_long_range_scan">
        <xs:annotation>
          <xs:documentation>
            Starts a long range scan for the object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="stop_long_range_scan">
        <xs:annotation>
          <xs:documentation>
            Stops a long range scan for the object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="start_script">
        <xs:annotation>
          <xs:documentation>
            Start an AI script, aborting previously running scripts
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="param" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>
                  AI script parameter
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attribute name="name" type="paramname" use="required">
                  <xs:annotation>
                    <xs:documentation>
                      Parameter name
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="value" type="expression" use="required">
                  <xs:annotation>
                    <xs:documentation>
                      Parameter value
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="comment" type="comment" />
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="name" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Script name
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
        <xs:key name="start_script_param_name">
          <xs:selector xpath="param" />
          <xs:field xpath="@name" />
        </xs:key>
      </xs:element>

      <xs:element name="stop_boost">
        <xs:annotation>
          <xs:documentation>
            Stop engine booster
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="ship" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="stop_cutscene">
        <xs:annotation>
          <xs:documentation>
            Stop a running cutscene, or cancel a queued targetmonitor cutscene before it is started
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="cutscenekeyorid" />
        </xs:complexType>
      </xs:element>

      <xs:element name="stop_firing_at_target">
        <xs:annotation>
          <xs:documentation>
            Stop firing at a specific target
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="target" type="object" use="required"/>
          <xs:attribute name="weaponmode" type="weaponmodelookup">
            <xs:annotation>
              <xs:documentation>
                Turret in the specified mode will stop shooting at the target(s), defaults to any.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="read_text">
        <xs:annotation>
          <xs:documentation>
            Read converted text string from TextDB, including support for variant text (for non-variant text use readtext property or the short notation {123,456} directly)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="page" type="page" use="required" />
          <xs:attribute name="line" type="line" use="required" />
          <xs:attribute name="speaker" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Speaker of the line (optional). Pass an NPC or the player if the person speaking may have a grammatical effect on the sentence.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="recipient" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Recipient of the line, i.e. the character being spoken to (optional). Pass an NPC or the player if the person being spoken to may have a grammatical effect on the sentence.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="topic" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Topic of the line, i.e. the character being spoken about (optional). Pass an NPC or the player if the person being spoken about may have a grammatical effect on the sentence.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="test" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Fallback text string for testing during development, used when text id is not found.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="text" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                Name of the value that will receive the result text.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="substitute_text">
        <xs:annotation>
          <xs:documentation>
            Search in a text for sub-strings and substitutes them
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="replace" minOccurs="1" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>
                  Definition of a sub-string in the text and a replacement string. All occurrences of the sub-string will be replaced.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attribute name="string" type="expression" use="required">
                  <xs:annotation>
                    <xs:documentation>
                      Sub-string which is expected to occur in the text
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="with" type="expression" use="required">
                  <xs:annotation>
                    <xs:documentation>
                      New text which will replace the occurrences of the sub-string
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="comment" type="comment" />
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="text" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                Name of the value that will receive the result text. If source is not supplied then this value is also used as text source.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="source" type="expression">
            <xs:annotation>
              <xs:documentation>
                Source text. If not supplied, the text attribute is used instead.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="trigger_autosave">
        <xs:annotation>
          <xs:documentation>
            Trigger an autosave
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
        </xs:complexType>
      </xs:element>

      <xs:element name="trigger_boarding">
        <xs:annotation>
          <xs:documentation>
            Trigger a boarding process via an MD cue, including mission guidance for the player
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="boarder" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The marine commander that controls the boarding operation
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="target" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The target object to be boarded
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="faction" type="factionexprlookup">
            <xs:annotation>
              <xs:documentation>
                The boarder faction, which is trying to take ownership of the target (default is the player faction)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="undock">
        <xs:annotation>
          <xs:documentation>
            Undock ship
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="ship" type="ship" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_ship_undocking">
        <xs:annotation>
          <xs:documentation>
            Sets the state of the ship's dockingbay to 'undocking'
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="ship" type="ship" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="dock_from_storage">
        <xs:annotation>
          <xs:documentation>
            Move a ship from an internal dock to a specified dock, if free
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="result" type="lvalueexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Receives true if the retrieval from storage was successfully initiated, otherwise false.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="ship" type="ship" use="required" />
          <xs:attribute name="dockingbay" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The dockingbay to move the ship to (must be of the same object as the ship's storing object)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="unlock_achievement">
        <xs:annotation>
          <xs:documentation>
            Unlock an achievement (no effect if it was already unlocked)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="name" type="namestring" use="required">
            <xs:annotation>
              <xs:documentation>
                Achievement name
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="scenario" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Can the achievement be unlocked in a scenario gamestart? Default is false
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="indicate_achievement_progress">
        <xs:annotation>
          <xs:documentation>
            Indicate achievement progress (no effect if it was already unlocked). This does not unlock the achievement when max progress is reached (100%), use &lt;unlock_achievement&gt; instead in this case.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="name" type="namestring" use="required">
            <xs:annotation>
              <xs:documentation>
                Achievement name
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="progress" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Integer value of current progress
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="max" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Integer value of maximal progress
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="initiate_player_trade">
        <xs:annotation>
          <xs:documentation>
            Initiate a trade between an object and the player's primary ship.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="result" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                Returns true if the trade was successfully initiated, otherwise false.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="trade" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The trade to be initiated.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="amount" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Optionally, override the amount of the ware to be traded (This could have changed since the deal was made).
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="update_trade">
        <xs:annotation>
          <xs:documentation>
            Update certain parameters of a trade
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="trade" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The trade to update
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="amount" type="expression">
            <xs:annotation>
              <xs:documentation>
                New amount for the trade (optional, should already be adjusted to be the amount we can afford)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="desiredamount" type="expression">
            <xs:annotation>
              <xs:documentation>
                New desiredamount for the trade (optional, how much we *really* want, ignoring financial constraints)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="price" type="expression">
            <xs:annotation>
              <xs:documentation>
                New price (per unit) for the trade (optional)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="get_object_value">
        <xs:annotation>
          <xs:documentation>
            Get the credit value of an object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="priceobject" type="expression">
            <xs:annotation>
              <xs:documentation>
                Object of which to base resource prices. Takes precedence over 'pricetable'
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="pricetable" type="expression">
            <xs:annotation>
              <xs:documentation>
                Table of resource wares with the buy price
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="sellprice" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Calculate the sell price of the object? Default is false
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="get_pilot_dockslot">
        <xs:annotation>
          <xs:documentation>
            Retrieve the dockslot that a pilot entity is currently using for docking.
            NOTE: This action is not supposed to be used normally, it only exists for fixing a bug that appears in early game versions.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="pilot" use="required">
            <xs:annotation>
              <xs:documentation>
                Pilot
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="warp">
        <xs:annotation>
          <xs:documentation>
            Warp object to different location
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:all>
            <xs:element name="position" type="position" minOccurs="0" maxOccurs="1" />
            <xs:element name="safepos" type="safepos" minOccurs="0" maxOccurs="1" />
            <xs:element name="rotation" type="rotation" minOccurs="0" maxOccurs="1" />
            <xs:element name="orientation" type="orientation" minOccurs="0" maxOccurs="1" />
          </xs:all>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="zone" type="expression">
            <xs:annotation>
              <xs:documentation>
                Zone to warp to (take precedence from sector)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="sector" type="expression">
            <xs:annotation>
              <xs:documentation>
                Sector to warp the object in using position in the sector space. Creates a tempzone if a zone does not exist at the coordinates
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="sort_group">
        <xs:annotation>
          <xs:documentation>
            Sort components in a group by a provided criterion
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="group" type="group" use="required" />
          <xs:attributeGroup ref="sortresult" />
        </xs:complexType>
      </xs:element>

      <xs:element name="sort_list">
        <xs:annotation>
          <xs:documentation>
            Sort elements in a list either by their values or by a provided criterion
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="list" type="list" use="required" />
          <xs:attribute name="sortbyvalue" type="expression">
            <xs:annotation>
              <xs:documentation>
                Optionally sort values by a sort criterion provided by this script expression, which is evaluated for each element and can access the current value and index via 'loop.element' and 'loop.index', respectively
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="sortdescending" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Should the values be sorted in descending order (from highest to lowest)?
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="sort_trades">
        <xs:annotation>
          <xs:documentation>
            Sort trade list. Note: Sorting trades with identical sort values will retain their relative order from the input list. Consider shuffling the trade list first.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="name" type="lvaluename" use="required" />
          <xs:attribute name="tradelist" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                List of trades to sort
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="sorter" type="tradesorterlookup" use="required" />
          <xs:attribute name="min" type="boolean" use="optional" />
          <xs:attribute name="refobject" type="object" use="optional" >
            <xs:annotation>
              <xs:documentation>
                Reference object to sort trades by distances or offeramounts (required for sorter="distance", optional for sorter="offeramount")
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="sort_people">
        <xs:annotation>
          <xs:documentation>
            Sort people list. Note: Sorting people with identical sort values will retain their relative order from the input list. Consider shuffling the templatelist first.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="name" type="lvaluename" use="required" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="templatelist" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                List of NPC templates to sort
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="sorter" type="npcsummarysorterlookup" use="required" />
          <xs:attribute name="skill" type="skilltypeexprlookup" use="optional">
            <xs:annotation>
              <xs:documentation>
                Skill to sort by (required for sorter="skill", ignored otherwise)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="post" type="controlpostexprlookup" use="optional">
            <xs:annotation>
              <xs:documentation>
                Post to sort for potential skill by (required for sorter="potentialskillforpost", ignored otherwise)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="role" type="entityroleexprlookup" use="optional">
            <xs:annotation>
              <xs:documentation>
                Role to sort for potential skill by (required for sorter="potentialskillforrole", ignored otherwise)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="add_experience_progress">
        <xs:annotation>
          <xs:documentation>
            Add experience progress points
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="random" />
          <xs:attribute name="entity" type="entity" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_experience_progress">
        <xs:annotation>
          <xs:documentation>
            Set experience progress points
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="random" />
          <xs:attribute name="entity" type="entity" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="add_effect">
        <xs:annotation>
          <xs:documentation>
            Add an effect object. If the effect's duration is infinite (value of -1), you need to remove it yourself with remove_effect.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="position" type="position" minOccurs="0" maxOccurs="1" />
            <xs:element name="rotation" type="rotation" minOccurs="0" maxOccurs="1" />
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="expression">
            <xs:annotation>
              <xs:documentation>
                Object to attach the effect to
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="effect" type="expression">
            <xs:annotation>
              <xs:documentation>
                Effect definition (from libraries/effects.xml)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="strength" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Effect strength factor (default is 1.0)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_effect">
        <xs:annotation>
          <xs:documentation>
            Remove an existing effect object.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="expression">
            <xs:annotation>
              <xs:documentation>
                Object the effect is attached to
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="effect" type="expression">
            <xs:annotation>
              <xs:documentation>
                Effect definition (from libraries/effects.xml)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="flicker_object_lights">
        <xs:annotation>
          <xs:documentation>
            Flicker the lights of an object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Object to flicker the lights on (not propagating to sub-components)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="strength" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Base brightness factor for the flickering light (0.0 to 1.0, default is 0.5)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="range" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Range of the flickering around the 'strength' value (0.0 to 1.0, default is 0.2)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="duration" type="expression">
            <xs:annotation>
              <xs:documentation>
                Duration for the flickering
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="fadein" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Fade in duration back to normal brightness (default is 0.2s)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="play_sound">
        <xs:annotation>
          <xs:documentation>
            Play a sound. Does not support looping sounds yet.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="expression">
            <xs:annotation>
              <xs:documentation>
                Object to act as the sound source (required unless type=&quot;ui&quot; is specified)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="sound" type="expression">
            <xs:annotation>
              <xs:documentation>
                Sound ID (from libraries/sound_library.xml)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="type">
            <xs:annotation>
              <xs:documentation>
                Sound type (default is &quot;effect&quot; - NOTE: The player can adjust the volume for each sound type individually in the settings)
              </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="effect">
                  <xs:annotation>
                    <xs:documentation>
                      Effect sound
                    </xs:documentation>
                  </xs:annotation>
                </xs:enumeration>
                <xs:enumeration value="ui">
                  <xs:annotation>
                    <xs:documentation>
                      UI sound (NOTE: The sound source object is ignored in this case)
                    </xs:documentation>
                  </xs:annotation>
                </xs:enumeration>
                <xs:enumeration value="ambient">
                  <xs:annotation>
                    <xs:documentation>
                      Ambient sound
                    </xs:documentation>
                  </xs:annotation>
                </xs:enumeration>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="play_music">
        <xs:annotation>
          <xs:documentation>
            Play a music track, interrupting regular music handling for the duration. An infinitely repeating track (where the 'repeat' property of its entry in libraries/sound_library.xml is negative) must be aborted manually by calling &lt;stop_music&gt;.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="music" type="expression">
            <xs:annotation>
              <xs:documentation>
                Sound ID of music track (from libraries/sound_library.xml)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="loop" type="xs:boolean">
            <xs:annotation>
              <xs:documentation>
                This is a looping track and I will take care of calling &lt;stop_music&gt; (default:false, must correspond to the 'repeat' property of the music track in libraries/sound_library.xml, if it's negative this must be true, otherwise this must be false).
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="stop_music">
        <xs:annotation>
          <xs:documentation>
            Stop a manually started music track
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_ambient_sound_state">
        <xs:annotation>
          <xs:documentation>
            Activate/deactivate ambient sounds
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="active" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Set ambient sounds to active (defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_object_sound_override">
        <xs:annotation>
          <xs:documentation>
            Override an object's default sound. Currently only room ambient sounds are supported.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Object to set override for
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="type" use="required">
            <xs:annotation>
              <xs:documentation>
                Sound type (default is &quot;ambient&quot;)
              </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="ambient">
                  <xs:annotation>
                    <xs:documentation>
                      Ambient sound
                    </xs:documentation>
                  </xs:annotation>
                </xs:enumeration>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="sound" type="expression">
            <xs:annotation>
              <xs:documentation>
                Sound ID (from libraries/sound_library.xml, uses default if not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="volume" type="expression">
            <xs:annotation>
              <xs:documentation>
                Sound volume factor (0.0 to 1.0, 1.0 if not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="clear_object_sound_override">
        <xs:annotation>
          <xs:documentation>
            Clear an object's override sound. Currently only room ambient sounds are supported.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Object to clear override for
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="type" use="required">
            <xs:annotation>
              <xs:documentation>
                Sound type (default is &quot;ambient&quot;)
              </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="ambient">
                  <xs:annotation>
                    <xs:documentation>
                      Ambient sound
                    </xs:documentation>
                  </xs:annotation>
                </xs:enumeration>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="write_to_logbook">
        <xs:annotation>
          <xs:documentation>
            Write an entry into the logbook
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="category" type="logcategorylookup" use="required" />
          <xs:attribute name="text" type="expression">
            <xs:annotation>
              <xs:documentation>
                Logbook entry text, either a single string with possible line breaks, or a list of strings in notification format (see &lt;show_notification&gt;).
                When using the notification format and both left and right columns of a row contain text, the texts will be concatenated with a single space as separator.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="separator" type="expression">
            <xs:annotation>
              <xs:documentation>
                Separator to be used between left and right texts of a notification row, in case the notification format is used in the text attribute (default is a single space)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="interaction" type="loginteractionlookup" />
          <xs:attribute name="object" type="expression">
            <xs:annotation>
              <xs:documentation>
                Interaction object, depending on the interaction type
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="title" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Logbook entry title
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="entity" type="expression">
            <xs:annotation>
              <xs:documentation>
                Optional source entity for logbook entry (either a real entity, in which case the entity name will be used, or an arbitrary name as text)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="faction" type="expression">
            <xs:annotation>
              <xs:documentation>
                Optional source faction logbook entry (either a real faction, in which case the faction name will be used, or an arbitrary name as text)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="money" type="expression">
            <xs:annotation>
              <xs:documentation>
                Optional amount of money associated with the logbook entry (if not supplied, or 0, then will not be shown in the logbook)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="bonus" type="expression">
            <xs:annotation>
              <xs:documentation>
                Optional bonus amount of money associated with the logbook entry (if not supplied, or 0, then will not be shown in the logbook)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="highlighted" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Optional flag specifying whether the logbook entry should be highlighted.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="write_incoming_message">
        <xs:annotation>
          <xs:documentation>
            Write a message that is received by the player
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="cutscene" minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
                  Cutscene data to be passed to UI when message is displayed
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attribute name="key" type="cutscenekey" use="required" />
                <xs:attribute name="param" type="expression">
                  <xs:annotation>
                    <xs:documentation>
                      Optional cutscene parameter
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="comment" type="comment" />
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="source" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Message source, either a string or an object. If an object is provided, the message will be deleted automatically in case the source object is killed.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="title" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Message title
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="text" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Message text
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="highpriority" type="boolean">
            <xs:annotation>
              <xs:documentation>
                High priority message?
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="interaction" type="loginteractionlookup" />
          <xs:attribute name="object" type="expression">
            <xs:annotation>
              <xs:documentation>
                Interaction object, depending on the interaction type
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="autodelete" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Should the message be auto-deleted when the interaction object is destroyed? Default is false.
                (NOTE: This flag only refers to the interaction object. The autodelete handling for a supplied source object is not adjustable.)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="read" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Should the message already be marked as read by the player? Default is false.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                ID of the incoming message
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="add_trade_subscription">
        <xs:annotation>
          <xs:documentation>
            Add permanent player subscription to trade offer updates of the specified object. This also immediately adds the current trade offers to the trade memory.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="duration" type="expression">
            <xs:annotation>
              <xs:documentation>
                How long this subscription is valid for. Unlimited duration if omitted. (optional)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_trade_subscription">
        <xs:annotation>
          <xs:documentation>
            Remove permanent player subscription to trade offer updates of the specified object. Offers remain known as long as live view coverage exists.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="forget" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Forget that there ever was information about trade offers at the specified object (defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="store_trade_offer_snapshot">
        <xs:annotation>
          <xs:documentation>
            Store a snapshot of the current trade offers on the specified object in the player trade memory.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="add_encyclopedia_entry">
        <xs:annotation>
          <xs:documentation>
            Add an entry to the encyclopedia (blueprints and spaces are not supported)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="type" type="infolibrarytypelookup">
            <xs:annotation>
              <xs:documentation>
                Encyclopedia entry type (must be used together with item attribute, cannot be used together with value attribute)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="item" type="expression">
            <xs:annotation>
              <xs:documentation>
                Encyclopedia entry item ID (must be used together with type attribute, cannot be used together with value attribute)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="value" type="expression">
            <xs:annotation>
              <xs:documentation>
                Value from which encyclopedia type and item are derived (cannot be used together with type and item attributes)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="add_blueprints">
        <xs:annotation>
          <xs:documentation>
            Add blueprints to player's blueprint library
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="wares" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Ware or list of wares for which to add blueprints (can be combined with macros and object in a single call)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="macros" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Macro or list of macros for which to add blueprints (can be combined with wares and object in a single call)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="object" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Object (station or ship) for which to add blueprints (can be combined with wares and macros in a single call)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="method" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Production method for blueprint(s) (will be the same for all added blueprints, uses default method if not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="cycle" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Cycle efficiency for blueprint(s) (will be the same for all added blueprints, uses 1.0 if not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="resource" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Resource efficiency for blueprint(s) (will be the same for all added blueprints, uses 1.0 if not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="product" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Product efficiency for blueprint(s) (will be the same for all added blueprints, uses 1.0 if not supplied)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="modules" type="booleanexpression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Include blueprints for modules (used only with object attribute, default is true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="flags" type="loadoutflagbitmask" use="optional">
            <xs:annotation>
              <xs:documentation>
                Include blueprints for equipment in specific loadout elements (used only with object attribute, default is all loadout elements)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="start_player_autopilot">
        <xs:annotation>
          <xs:documentation>
            Start playership autopilot to the selected destination (follow for moving targets)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="destination" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="stop_player_autopilot">
        <xs:annotation>
          <xs:documentation>
            Stop playership autopilot
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="toggle_timewarp">
        <xs:annotation>
          <xs:documentation>
            Toggle time warp (SETA). NOTE: Activation requires that SETA is in the player's inventory and the activation conditions are met. For example, SETA is not possible during a conversation.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="activate_platform_trigger">
        <xs:annotation>
          <xs:documentation>
            Activate a platform trigger (e.g. a button or certain doors)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="room" type="room" use="required" />
          <xs:attribute name="group" type="expression" use="required" />
          <xs:attribute name="result" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                True if the activation succeeded or is not necessary, false if it failed (this can happen if the deactivating animation is currently running; wait a short time and retry)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="deactivate_platform_trigger">
        <xs:annotation>
          <xs:documentation>
            Deactivate a platform trigger (e.g. a button or certain doors)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="room" type="room" use="required" />
          <xs:attribute name="group" type="expression" use="required" />
          <xs:attribute name="result" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                True if the deactivation succeeded or is not necessary, false if it failed (this can happen if the activating animation is currently running; wait a short time and retry)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="patch_macro">
        <xs:annotation>
          <xs:documentation>
            Patch an object based on its macro, to add components that may be missing when loading a savegame. This action is only required by extensions and should normally only be used when loading a savegame
            in which the extension was not active yet. The script is responsible for finding the objects, usually ships or stations, that need patching.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="patch_macros">
        <xs:annotation>
          <xs:documentation>
            Finds objects with given filter criteria and patches them based on their macro (see &lt;patch_macro&gt;)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="matchbase">
              <xs:attributeGroup ref="action" />
              <xs:attributeGroup ref="findobject" />
              <xs:attribute name="space" type="expression">
                <xs:annotation>
                  <xs:documentation>
                    Space in which to find objects to be patched. The galaxy is used if no space is supplied.
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="install_software">
        <xs:annotation>
          <xs:documentation>
            Installs the given software on object. If the software is not compatible with object this will fail silently!
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="software" type="ware" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="uninstall_software">
        <xs:annotation>
          <xs:documentation>
            Uninstalls the given software (and all previous versions) from object. If the software to be uninstalled (or any of its previous versions) are part of the default software, these will remain installed!
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="software" type="ware" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="downgrade_software">
        <xs:annotation>
          <xs:documentation>
            Uninstalls all newer versions of software from object. If any of the software versions about to be removed are part of the default software, they will remain installed!
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="software" type="ware" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_playership_throttle">
        <xs:annotation>
          <xs:documentation>
            Set the throttle value of the playership.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="value" type="expression">
            <xs:annotation>
              <xs:documentation>
                Value for throttle setting between full reverse (-1) and full forward (1)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="add_stock">
        <xs:annotation>
          <xs:documentation>
            Add inventory to a given entity using the entity's stock ID, as defined in the character definition.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="entity" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The entity that should receive some stock.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_stock_reference">
        <xs:annotation>
          <xs:documentation>
            Set the stock entry the given entity should use
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="entity" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The entity that gets the stock reference.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="stock" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The stock reference.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="add_clothing_mod">
        <xs:annotation>
          <xs:documentation>
            Add clothing mod to an NPC or the player
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action"/>
          <xs:attribute name="entity" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The NPC or player that should receive clothing mod.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="ware" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Clothing mod ware (from clothingmods.xml, defines a quality level and visual properties of a clothing mod)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="add_workforce">
        <xs:annotation>
          <xs:documentation>
            Add workforce of the specified race to a given object. (will not add more than can fit, see $container.workforce.{$race}.capacity)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="race" type="race" use="required" />
          <xs:attributeGroup ref="random" />
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_workforce">
        <xs:annotation>
          <xs:documentation>
            Remove workforce of the specified race from a given object.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="race" type="race" use="required" />
          <xs:attributeGroup ref="random" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_equipment_wares_excluded">
        <xs:annotation>
          <xs:documentation>
            Define equipment wares from the default equipment for the object owners' faction that should not be available for construction (only applies to objects with build modules such as shipyards or equipment docks).
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="buildexcludewares" />
          <xs:attribute name="object" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_equipment_wares_included">
        <xs:annotation>
          <xs:documentation>
            Define equipment wares outside the default equipment for the object owners' faction that should be available for construction regardless (only applies to objects with build modules such as shipyards or equipment docks).
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="buildincludewares" />
          <xs:attribute name="object" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_ship_wares_excluded">
        <xs:annotation>
          <xs:documentation>
            Define ship wares from the default ships for the object owners' faction that should not be available for construction (only applies to objects with build modules such as shipyards or equipment docks).
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="buildexcludewares" />
          <xs:attribute name="object" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_ship_wares_included">
        <xs:annotation>
          <xs:documentation>
            Define ship wares outside the default ships for the object owners' faction that should be available for construction regardless (only applies to objects with build modules such as shipyards or equipment docks).
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="buildincludewares" />
          <xs:attribute name="object" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="report_online_encounter">
        <xs:annotation>
          <xs:documentation>
            Report that the object had an encounter which should be tracked and submitted to the server as potentially relevant for transmission to original owner. Will fail silently if the object does not originate from another universe.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="type" type="encountertypelookup" use="required" />
          <xs:attribute name="param" type="expression" />
          <xs:attribute name="param2" type="expression" />
          <xs:attribute name="param3" type="expression" />
        </xs:complexType>
      </xs:element>

      <xs:element name="assign_venture_dock">
        <xs:annotation>
          <xs:documentation>
            Assign a ship to a venture dock
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="ship" type="ship" use="required" />
          <xs:attribute name="dockingbay" type="expression" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="clear_venture_dock_assignment">
        <xs:annotation>
          <xs:documentation>
            Clear a ship's assignment to a venture dock
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required">
            <xs:annotation>
              <xs:documentation>
                The assigned ship or the venture dock
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="start_venture">
        <xs:annotation>
          <xs:documentation>
            Start a venture for a group of ships
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="module" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The venture platform
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="id" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The venture ID string
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="fuel" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Amount of brane fuel
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="successwares" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Ware table of success factor wares
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="create_trade_computer">
        <xs:annotation>
          <xs:documentation>
            Creates a trade computer entity on the specified object that will attempt to perform the first trade order in the current order queue, provided the tradepartner is the container the object is currently docked at.
            After completion of the order the trade computer will remove itself. (see orders.base.tradecomputer)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="result" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                The trade computer entity, if one was created.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="estimate_travel_time">
        <xs:annotation>
          <xs:documentation>
            Estimate the time it takes to fly to a target location (takes highways and travel mode into account).
            Either the ship, the ship macro or all engine parameters have to be supplied.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="startposition" type="position" minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
                  Start position relative to the start component.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="targetposition" type="position" minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
                  Target position relative to the target component.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="start" type="object" use="required" />
          <xs:attribute name="target" type="object" use="required" />
          <xs:attribute name="ship" type="expression">
            <xs:annotation>
              <xs:documentation>
                The ship from which to get the engine parameters. This cannot be used in conjunction with the macro attribute.
                Engine parameters can be provided individually to override the ship values.
                If neither ship nor macro are provided, all engine parameters must be defined.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="macro" type="expression">
            <xs:annotation>
              <xs:documentation>
                A ship macro from which to get the engine parameters. This cannot be used in conjunction with the ship attribute.
                A custom loadout with an engine macro can be provided in the loadout attribute, otherwise a default loadout is required to exist for this macro.
                Engine parameters can be provided individually to override the macro values.
                If neither ship nor macro are provided, all engine parameters must be defined.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="loadout" type="expression">
            <xs:annotation>
              <xs:documentation>
                Custom loadout with an engine macro to provide engine parameters. This can only be used together with the macro attribute, and it has no effect when the ship attribute is provided.
                If a ship macro is provided without this attribute, the default loadout is required to exist and will be used to get the engine parameters.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="uselocalhighways" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether local highways are to be included in time estimations.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="speed" type="expression">
            <xs:annotation>
              <xs:documentation>
                The maximum forward speed without using boost or travel mode.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="travelfactor" type="expression">
            <xs:annotation>
              <xs:documentation>
                The travel drive's thrust factor. Multiplies the forward speed.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="travelcharge" type="expression">
            <xs:annotation>
              <xs:documentation>
                The time it takes to charge travel mode.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="travelattack" type="expression">
            <xs:annotation>
              <xs:documentation>
                The time it takes to reach maximum travel speed after charging has finished.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvalueexpression" use="required">
            <xs:annotation>
              <xs:documentation>
                The estimated travel time (or a negative time value if no path exists).
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_production_paused">
        <xs:annotation>
          <xs:documentation>
            Set a production module to be manually paused or resume production if it has been manually paused before. (see also .ispausedmanually property)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                ProductionModule which should be paused/unpaused.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="paused" type="boolean" use="optional">
            <xs:annotation>
              <xs:documentation>
                Pause the production if it is not already manually paused. (defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="fade_screen">
        <xs:annotation>
          <xs:documentation>
            Fades the screen to black and back to normal.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="fadeout" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The duration over which the screen should fade out, in seconds. (must be non-negative)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="fadein" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The duration over which the screen should fade in, in seconds. (must be non-negative)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="starttime" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                The time at which the fade out should start. (defaults to the current time)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="color" use="optional">
            <xs:annotation>
              <xs:documentation>
                Color to fade to (defaults to black)
              </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="black" />
                <xs:enumeration value="white" />
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_control_mode_messages_disabled">
        <xs:annotation>
          <xs:documentation>
            Suppresses the display of control mode messages, no matter whether or not they're enabled in the user config.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="reset_control_mode_messages">
        <xs:annotation>
          <xs:documentation>
            Resets the display of control mode messages to what has been configured by the user.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_adaptive_steering_forced">
        <xs:annotation>
          <xs:documentation>
            Forces the use of adaptive steering, no matter whether or not it's enabled in the user config.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="reset_adaptive_steering">
        <xs:annotation>
          <xs:documentation>
            Resets the use of adaptive steering to what has been configured by the user.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
        </xs:complexType>
      </xs:element>

      <xs:element name="initialise_terraforming">
        <xs:annotation>
          <xs:documentation>
            Initialises the terraforming data in this cluster.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="cluster" type="cluster" use="required" />
          <xs:attribute name="partname" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The template part name of the world
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_terraforming_mission_activated">
        <xs:annotation>
          <xs:documentation>
            Tells the cluster that a terraforming mission for it has been activated.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="cluster" type="cluster" use="required" />
          <xs:attribute name="missioncue" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Mission cue
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_terraforming_mission_completed">
        <xs:annotation>
          <xs:documentation>
            Tells the cluster that its terraforming mission has been completed.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="cluster" type="cluster" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_terraforming_mission_deactivated">
        <xs:annotation>
          <xs:documentation>
            Tells the cluster that its terraforming mission has been deactivated.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="cluster" type="cluster" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="add_terraforming_project">
        <xs:annotation>
          <xs:documentation>
            Adds a new terraforming project.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="terraformingaction">
              <xs:attribute name="postfix" type="expression">
                <xs:annotation>
                  <xs:documentation>
                    Optional ID postfix, must be used when adding multiple projects based on the same library entry.
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_terraforming_project">
        <xs:annotation>
          <xs:documentation>
            Removes a terraforming project.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="cluster" type="cluster" use="required" />
          <xs:attribute name="id" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The ID of the project.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_terraforming_project_data">
        <xs:annotation>
          <xs:documentation>
            Changes the properties of a previously added terraforming project.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="terraformingaction" />
          </xs:complexContent>
        </xs:complexType>
      </xs:element>

      <xs:element name="add_terraforming_event" type="terraformingaction">
        <xs:annotation>
          <xs:documentation>
            Adds a new terraforming event.
          </xs:documentation>
        </xs:annotation>
      </xs:element>

      <xs:element name="remove_terraforming_event">
        <xs:annotation>
          <xs:documentation>
            Removes a terraforming event.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="cluster" type="cluster" use="required" />
          <xs:attribute name="id" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The ID of the event.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_terraforming_stat">
        <xs:annotation>
          <xs:documentation>
            Sets a terraforming stat to the given value.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="terraformingstat" />
          <xs:attribute name="value" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The value to set the stat to.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_terraforming_stat">
        <xs:annotation>
          <xs:documentation>
            Removes a terraforming stat - it will no longer be displayed or be an effect or condition projects.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attributeGroup ref="terraformingstat" />
        </xs:complexType>
      </xs:element>

      <xs:element name="rename_all_worlds">
        <xs:annotation>
          <xs:documentation>
            Renames all planets and moons in the cluster that don't have unique names of their own and use the cluster's name plus a letter. Use this after renaming a cluster if you want the planet names to match.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="cluster" type="cluster" use="required" />
          <xs:attribute name="page" type="page" use="required" />
          <xs:attribute name="oldline" type="line" use="required" />
          <xs:attribute name="newline" type="line" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_world_atmosphere">
        <xs:annotation>
          <xs:documentation>
            Sets a planet's atmosphere text in the encyclopedia.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="cluster" type="cluster" use="required" />
          <xs:attribute name="partname" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The template part name of the world
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="page" type="page" use="required" />
          <xs:attribute name="line" type="line" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_world_geology">
        <xs:annotation>
          <xs:documentation>
            Sets a planet's geology text in the encyclopedia.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="cluster" type="cluster" use="required" />
          <xs:attribute name="partname" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The template part name of the world
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="page" type="page" use="required" />
          <xs:attribute name="line" type="line" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_world_name">
        <xs:annotation>
          <xs:documentation>
            Sets a planet's name text in the encyclopedia.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="cluster" type="cluster" use="required" />
          <xs:attribute name="partname" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The template part name of the world
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="page" type="page" use="required" />
          <xs:attribute name="line" type="line" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_world_population">
        <xs:annotation>
          <xs:documentation>
            Sets a planet's population text and amount in the encyclopedia. If you just want to display the number use page 1042 and line 10021.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="cluster" type="cluster" use="required" />
          <xs:attribute name="partname" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The template part name of the world
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="page" type="page" use="required" />
          <xs:attribute name="line" type="line" use="required" />
          <xs:attribute name="amount" type="expression">
            <xs:annotation>
              <xs:documentation>
                The new population amount. Only shown if the population text contains the '$POPULATION$' placeholder. If omitted the number is not changed.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_world_settlements">
        <xs:annotation>
          <xs:documentation>
            Sets a planet's settlements text in the encyclopedia.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="cluster" type="cluster" use="required" />
          <xs:attribute name="partname" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The template part name of the world
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="page" type="page" use="required" />
          <xs:attribute name="line" type="line" use="required" />
        </xs:complexType>
      </xs:element>

    </xs:choice>
  </xs:group>

</xs:schema>
